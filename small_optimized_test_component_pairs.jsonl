{"input": "// Copyright 2020 H2O.ai, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { B, Model, Rec, S, unpack } from './core'\nimport React from 'react'\nimport { stylesheet } from 'typestyle'\nimport { Result } from 'vega-embed'\nimport { cards } from './layout'\nimport { formItemWidth } from './theme'\nimport { bond, debounce } from './ui'\nimport { Command } from './toolbar'\nimport { CARD_TITLE_HEIGHT, CARD_TITLE_PADDING_TOP } from './parts/styleConstants'\n\nconst\n  css = stylesheet({\n    card: {\n      display: 'flex',\n      flexDirection: 'column',\n      padding: 24\n    },\n    body: {\n      flexGrow: 1,\n      display: 'flex',\n    },\n    plot: {\n      $nest: {\n        'canvas': {\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          right: 0,\n          bottom: 0\n        }\n      }\n    }\n  })\n\n/** Create a Vega-lite plot for display inside a form. */\nexport interface VegaVisualization {\n  /** The Vega-lite specification. */\n  specification: S\n  /** Data for the plot, if any. */\n  data?: Rec\n  /** The width of the visualization. Defaults to '100%'. */\n  width?: S\n  /** The height of the visualization. Defaults to '300px'. */\n  height?: S\n  /** An identifying name for this component. */\n  name?: S\n  /** True if the component should be visible. Defaults to True. */\n  visible?: B\n  /** Vega grammar to use. Defaults to 'vega-lite'. */\n  grammar?: 'vega-lite' | 'vega'\n}\n\nexport const\n  XVegaVisualization = ({ model }: { model: VegaVisualization }) => {\n    const\n      ref = React.useRef<HTMLDivElement>(null),\n      vegaRef = React.useRef<Result>(),\n      dataRef = React.useRef<unknown[]>(unpack<unknown[]>(model.data)),\n      updateData = React.useCallback(async () => {\n        if (!vegaRef.current || !dataRef.current) return\n\n        const changeset = (await import('vega')).changeset().remove(() => true).insert(dataRef.current)\n        // source_0 is default dataset for some reason in Vega.\n        vegaRef.current.view.change('source_0', changeset).run()\n      }, []),\n      init = React.useCallback(async () => {\n        const el = ref.current\n        if (!el) return\n\n        const spec = JSON.parse(model.specification)\n        // HACK: Vega calculates dimensions with extra 10px for some reason, increase container for 10px as well.\n        if (!isNaN(spec.height)) el.style.height = `${spec.height + 10}px`\n        // If card does not have specified height, it uses content. Since the wrapper is empty, it takes very little space - set to 300px by default.\n        else if (el.clientHeight < 30) el.style.height = '300px'\n\n        const\n          width = el.clientWidth - 10, // HACK: Vega calculates dimensions with extra 10px for some reason.\n          height = el.clientHeight - 10 // HACK: Vega calculates dimensions with extra 10px for some reason.\n\n        if (dataRef.current) spec.data = { values: dataRef.current }\n        const { default: vegaEmbed } = await import('vega-embed')\n        vegaRef.current = await vegaEmbed(el, spec, {\n          mode: model.grammar || 'vega-lite',\n          defaultStyle: false,\n          renderer: 'canvas',\n          actions: false,\n          config: {\n            autosize: {\n              type: 'fit',\n              resize: true\n            },\n            view: {\n              discreteWidth: width,\n              discreteHeight: height,\n              continuousWidth: width,\n              continuousHeight: height,\n            }\n          }\n        })\n      }, [model.grammar, model.specification]),\n      { name, width = 'auto', height = 'auto' } = model,\n      style: React.CSSProperties = (width === 'auto' && height === 'auto')\n        ? { flexGrow: 1 }\n        : { width: formItemWidth(width), height }\n\n    React.useEffect(() => {\n      dataRef.current = unpack<unknown[]>(model.data)\n      updateData()\n    }, [updateData, model.data, model])\n    React.useEffect(() => {\n      init()\n      const onResize = debounce(1000, init)\n      window.addEventListener('resize', onResize)\n      return () => window.removeEventListener('resize', onResize)\n    }, [init])\n\n    return <div data-test={name} className={css.plot} style={{ ...style, position: 'relative' }} ref={ref} />\n  }\n\n/** Create a card containing a Vega-lite plot. */\ninterface State {\n  /** The title of this card. */\n  title: S\n  /** The Vega-lite specification. */\n  specification: S\n  /** Data for the plot, if any. */\n  data?: Rec\n  /** Vega grammar to use. Defaults to 'vega-lite'. */\n  grammar?: 'vega-lite' | 'vega'\n}\n\nexport const\n  View = bond(({ name, state, changed }: Model<State & { commands?: Command[] }>) => {\n    const\n      render = () => {\n        const { specification, data, title, grammar = 'vega-lite', commands } = state\n        return (\n          <div data-test={name} className={css.card}>\n            {title && <div className='wave-s12 wave-w6'>{title}</div>}\n            <div\n              className={css.body}\n              style={{ paddingTop: title ? CARD_TITLE_PADDING_TOP : commands?.length ? CARD_TITLE_PADDING_TOP + CARD_TITLE_HEIGHT : 0 }}\n            >\n              <XVegaVisualization model={{ specification, data, grammar }} />\n            </div>\n          </div>\n        )\n      }\n    return { render, changed }\n  })\n\ncards.register('vega', View)", "output": "// Copyright 2020 H2O.ai, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { render } from '@testing-library/react'\nimport * as T from './core'\nimport React from 'react'\nimport { VegaVisualization, View, XVegaVisualization } from './vega'\n\nconst\n  name = 'vega',\n  specification = `{\n    \"description\": \"A simple bar plot with embedded data.\",\n    \"data\": {\n      \"values\": [\n        {\"a\": \"A\",\"b\": 28}, {\"a\": \"B\",\"b\": 55}, {\"a\": \"C\",\"b\": 43},\n        {\"a\": \"D\",\"b\": 91}, {\"a\": \"E\",\"b\": 81}, {\"a\": \"F\",\"b\": 53},\n        {\"a\": \"G\",\"b\": 19}, {\"a\": \"H\",\"b\": 87}, {\"a\": \"I\",\"b\": 52}\n      ]\n    },\n    \"mark\": \"bar\",\n    \"encoding\": {\n      \"x\": {\"field\": \"a\", \"type\": \"ordinal\"},\n      \"y\": {\"field\": \"b\", \"type\": \"quantitative\"}\n    }\n  }`\n\ndescribe('Vega.tsx', () => {\n\n  describe('Card Vega', () => {\n    const cardVegaProps: T.Model<any> = {\n      name,\n      state: { specification },\n      changed: T.box(false)\n    }\n\n    it('Renders data-test attr', () => {\n      const { queryByTestId } = render(<View {...cardVegaProps} />)\n      expect(queryByTestId(name)).toBeInTheDocument()\n    })\n  })\n\n  describe('Form Vega', () => {\n    const formVegaProps: VegaVisualization = { name, specification }\n\n    it('Does not render data-test attr', () => {\n      const { container } = render(<XVegaVisualization model={{ specification }} />)\n      expect(container.querySelectorAll('[data-test]')).toHaveLength(0)\n    })\n\n    it('Renders data-test attr', () => {\n      const { queryByTestId } = render(<XVegaVisualization model={formVegaProps} />)\n      expect(queryByTestId(name)).toBeInTheDocument()\n    })\n  })\n\n})", "meta": {"repo": "h2oai/wave", "stars": 4114, "component": "ui/src/vega.tsx", "test": "ui/src/vega.test.tsx"}}
{"input": "import { forwardRef, ReactNode, useImperativeHandle, useRef } from 'react';\nimport classnames from 'classnames';\nimport focusStyles from './Focus.css';\nimport getRoundingClassName, { Rounding } from './getRoundingClassName';\nimport styles from './TapArea.css';\nimport useFocusVisible from './useFocusVisible';\nimport useTapFeedback, { keyPressShouldTriggerTap } from './useTapFeedback';\nimport useExperimentalTheme from './utils/useExperimentalTheme';\n\ntype FocusEventHandler = (arg1: { event: React.FocusEvent<HTMLDivElement> }) => void;\n\ntype MouseEventHandler = (arg1: { event: React.MouseEvent<HTMLDivElement> }) => void;\n\ntype KeyboardEventHandler = (arg1: { event: React.KeyboardEvent<HTMLDivElement> }) => void;\n\ntype Props = {\n  /**\n   * Supply a short, descriptive label for screen-readers to replace TapArea texts that do not provide sufficient context about the button component behavior.\n   *\n   * It populates aria-label.\n   */\n  accessibilityLabel?: string;\n  /**\n   *\n   */\n  accessibilityChecked?: boolean;\n  /**\n   * Specify the `id` of an associated element (or elements) whose contents or visibility are controlled by a button component so that screen reader users can identify the relationship between elements.\n   *\n   * Optional with type=\"button\".\n   *\n   * It populates aria-controls.'\n   */\n  accessibilityControls?: string;\n  /**\n   * Indicate that a button component hides or exposes collapsible components and expose whether they are currently expanded or collapsed.\n   *\n   * Optional with type=\"button\".\n   *\n   * It populates aria-expanded.\n   */\n  accessibilityExpanded?: boolean;\n  /**\n   * Indicate that a button component controls the appearance of interactive popup elements, such as menu or dialog\n   *\n   * Optional with type=\"button\".\n   *\n   * It populates aria-haspopup.\n   */\n  accessibilityHaspopup?: boolean;\n  /**\n   * TapArea is a wrapper around non-button components (or children) that provides clicking / touching functionality as if they were a unified button area.\n   */\n  children?: ReactNode;\n  /**\n   * Available for testing purposes, if needed.\n   * Consider [better queries](https://testing-library.com/docs/queries/about/#priority) before using this prop.\n   */\n  dataTestId?: string;\n  /**\n   * Set disabled state so TapArea cannot be interacted with and actions are not available.\n   */\n  disabled?: boolean;\n  /**\n   * Indicates whether this component is hosted in a light or dark container.\n   * Used for improving focus ring color contrast.\n   */\n  focusColor?: 'lightBackground' | 'darkBackground';\n  /**\n   * Indicates whether this component presents a light ('default') or dark ('inverse') inner focus border when focused.\n   * Used for improving focus ring color contrast.\n   */\n  innerFocusColor?: 'default' | 'inverse';\n  /**\n   * Set the TapArea height to expand to the full height of the parent.\n   */\n  fullHeight?: boolean;\n  /**\n   * Set the TapArea width to expand to the full width of the parent.\n   */\n  fullWidth?: boolean;\n  /**\n   * Select a mouse cursor type to convey the TapArea expected behavior.\n   */\n  mouseCursor?:\n    | 'copy'\n    | 'default'\n    | 'grab'\n    | 'grabbing'\n    | 'move'\n    | 'noDrop'\n    | 'pointer'\n    | 'zoomIn'\n    | 'zoomOut';\n  /**\n   * Callback fired when a TapArea component loses focus.\n   */\n  onBlur?: FocusEventHandler;\n  /**\n   * Callback fired when a TapArea component gets focus via keyboard navigation, mouse click (pressed), or focus method.\n   */\n  onFocus?: FocusEventHandler;\n  /**\n   * Callback fired when a keyboard key is pressed\n   */\n  onKeyDown?: KeyboardEventHandler;\n  /**\n   * Callback fired when a click event begins.\n   */\n  onMouseDown?: MouseEventHandler;\n  /**\n   * Callback fired when a click event ends.\n   */\n  onMouseUp?: MouseEventHandler;\n  /**\n   * Callback fired when a mouse pointer moves onto a TapArea component.\n   */\n  onMouseEnter?: MouseEventHandler;\n  /**\n   * Callback fired when a mouse pointer moves out a TapArea component.\n   */\n  onMouseLeave?: MouseEventHandler;\n  /**\n   * Callback fired when a TapArea component is clicked (pressed and released) with a mouse or keyboard.\n   *\n   * Required with type=\"button\".\n   */\n  onTap?: (arg1: {\n    event: React.MouseEvent<HTMLDivElement> | React.KeyboardEvent<HTMLDivElement>;\n  }) => void;\n  /**\n   * Ref that is forwarded to the underlying div element.\n   */\n  ref?: HTMLDivElement;\n  /**\n   * Select 'button' when TapArea acts like regular buttons and 'switch' when the TapArea represents the states \"on\" and \"off.\"\n   */\n  role?: 'button' | 'switch';\n  /**\n   * Sets a border radius for the TapArea. Select a rounding option that aligns with its children.\n   *\n   * Options are \"circle\" or \"pill\" for fully rounded corners or 0-8 representing the radius in boints.\n   */\n  rounding?: Rounding;\n  /**\n   * Remove the component from sequential keyboard navigation to improve accessibility. The component is not focusable with keyboard navigation but it can be focused with Javascript or visually by clicking with the mouse.\n   *\n   * The default behaviour for the component is to be focusable in sequential keyboard navigation in the order defined by the document's source order.\n   *\n   * If component is disabled, the component is also unreachable from keyboard navigation.\n   */\n  tabIndex?: -1 | 0;\n  /**\n   * Set a compressing behavior when the TapArea is clicked / touched.\n   * - 'none' does not compress TapArea.`\n   * `- 'compress' scales down TapArea.`\n   */\n  tapStyle?: 'none' | 'compress';\n};\n\n/**\n * [TapArea](https://gestalt.pinterest.systems/tapArea) allows components to be clickable and touchable in an accessible way\n *\n * ![TapArea](https://raw.githubusercontent.com/pinterest/gestalt/master/docs/graphics/building-blocks/TapArea.svg)\n */\n\nconst TapAreaWithForwardRef = forwardRef<HTMLDivElement, Props>(function TapArea(\n  {\n    accessibilityLabel,\n    accessibilityControls,\n    accessibilityExpanded,\n    accessibilityHaspopup,\n    accessibilityChecked,\n    children,\n    dataTestId,\n    disabled = false,\n    focusColor = 'lightBackground',\n    fullHeight,\n    fullWidth = true,\n    innerFocusColor,\n    mouseCursor = 'pointer',\n    onBlur,\n    onKeyDown,\n    onFocus,\n    onMouseDown,\n    onMouseUp,\n    onMouseEnter,\n    onMouseLeave,\n    onTap,\n    tabIndex = 0,\n    role,\n    rounding = 0,\n    tapStyle = 'none',\n  }: Props,\n  ref,\n) {\n  const innerRef = useRef<null | HTMLDivElement>(null);\n  // When using both forwardRef and innerRef, React.useimperativehandle() allows a parent component\n  // that renders <TapArea ref={inputRef} /> to call inputRef.current.focus()\n  // @ts-expect-error - TS2322 - Type 'HTMLDivElement | null' is not assignable to type 'HTMLDivElement'.\n  useImperativeHandle(ref, () => innerRef.current);\n\n  const theme = useExperimentalTheme();\n\n  const { isFocusVisible } = useFocusVisible();\n\n  const {\n    compressStyle,\n    isTapping,\n    handleBlur,\n    handleMouseDown,\n    handleMouseUp,\n    handleTouchStart,\n    handleTouchMove,\n    handleTouchCancel,\n    handleTouchEnd,\n  } = useTapFeedback({\n    height: innerRef?.current?.clientHeight,\n    width: innerRef?.current?.clientWidth,\n  });\n\n  const buttonRoleClasses = classnames(styles.tapTransition, getRoundingClassName(rounding), {\n    [focusStyles.hideOutline]: !disabled && !isFocusVisible,\n    [focusStyles.accessibilityOutline]: !theme.MAIN && !disabled && isFocusVisible,\n    [focusStyles.accessibilityOutlineLightBackground]:\n      theme.MAIN && focusColor === 'lightBackground' && !disabled && isFocusVisible,\n    [focusStyles.accessibilityOutlineDarkBackground]:\n      theme.MAIN && focusColor === 'darkBackground' && !disabled && isFocusVisible,\n    [focusStyles.accessibilityOutlineBorder]:\n      theme.MAIN && innerFocusColor === 'default' && !disabled && !isFocusVisible,\n    [focusStyles.accessibilityOutlineBorderDefault]:\n      theme.MAIN && innerFocusColor === 'default' && !disabled && isFocusVisible,\n    [focusStyles.accessibilityOutlineBorderInverse]:\n      theme.MAIN && innerFocusColor === 'inverse' && !disabled && isFocusVisible,\n    [styles.fullHeight]: fullHeight,\n    [styles.fullWidth]: fullWidth,\n    [styles.copy]: mouseCursor === 'copy' && !disabled,\n    [styles.grab]: mouseCursor === 'grab' && !disabled,\n    [styles.grabbing]: mouseCursor === 'grabbing' && !disabled,\n    [styles.move]: mouseCursor === 'move' && !disabled,\n    [styles.noDrop]: mouseCursor === 'noDrop' && !disabled,\n    [styles.pointer]: mouseCursor === 'pointer' && !disabled,\n    [styles.zoomIn]: mouseCursor === 'zoomIn' && !disabled,\n    [styles.zoomOut]: mouseCursor === 'zoomOut' && !disabled,\n    [styles.tapCompress]: !disabled && tapStyle === 'compress' && isTapping,\n  });\n\n  return (\n    <div\n      ref={innerRef}\n      aria-checked={role === 'switch' ? accessibilityChecked : undefined}\n      aria-controls={accessibilityControls}\n      aria-disabled={disabled}\n      aria-expanded={accessibilityExpanded}\n      aria-haspopup={accessibilityHaspopup}\n      aria-label={accessibilityLabel}\n      className={buttonRoleClasses}\n      data-test-id={dataTestId}\n      onBlur={(event) => {\n        if (!disabled) onBlur?.({ event });\n        handleBlur();\n      }}\n      onClick={(event) => {\n        if (!disabled) onTap?.({ event });\n      }}\n      onFocus={(event) => {\n        if (!disabled) {\n          onFocus?.({ event });\n        }\n      }}\n      onKeyDown={(event) => {\n        if (!disabled) onKeyDown?.({ event });\n      }}\n      onKeyPress={(event) => {\n        // Check to see if space or enter were pressed\n        if (!disabled && keyPressShouldTriggerTap(event)) {\n          // Prevent the default action to stop scrolling when space is pressed\n          // TODO: this may be preventing ENTER keypress events coming from Buttons/IconButtons within a TapArea\n          event.preventDefault();\n          onTap?.({ event });\n        }\n      }}\n      onMouseDown={(event) => {\n        onMouseDown?.({ event });\n        handleMouseDown();\n      }}\n      onMouseEnter={(event) => {\n        if (!disabled) onMouseEnter?.({ event });\n      }}\n      onMouseLeave={(event) => {\n        if (!disabled) onMouseLeave?.({ event });\n      }}\n      onMouseUp={(event) => {\n        onMouseUp?.({ event });\n        handleMouseUp();\n      }}\n      onTouchCancel={handleTouchCancel}\n      onTouchEnd={handleTouchEnd}\n      onTouchMove={handleTouchMove}\n      onTouchStart={handleTouchStart}\n      role={role ?? 'button'}\n      {...(tapStyle === 'compress' && compressStyle && !disabled ? { style: compressStyle } : {})}\n      // @ts-expect-error - TS2322 - Type '0 | -1 | null' is not assignable to type 'number | undefined'.\n      tabIndex={disabled ? null : tabIndex}\n    >\n      {children}\n    </div>\n  );\n});\n\nTapAreaWithForwardRef.displayName = 'TapArea';\n\nexport default TapAreaWithForwardRef;", "output": "import { create } from 'react-test-renderer';\nimport TapArea from './TapArea';\n\ntest('TapArea renders', () => {\n  const tree = create(<TapArea onTap={() => {}}>TapArea</TapArea>).toJSON();\n  expect(tree).toMatchSnapshot();\n});\n\ntest('TapArea sets correct mouse cursor', () => {\n  const tree = create(\n    <TapArea mouseCursor=\"zoomIn\" onTap={() => {}}>\n      TapArea\n    </TapArea>,\n  ).toJSON();\n  expect(tree).toMatchSnapshot();\n});\n\ntest('TapArea sets correct rounding', () => {\n  const tree = create(\n    <TapArea onTap={() => {}} rounding=\"circle\">\n      TapArea\n    </TapArea>,\n  ).toJSON();\n  expect(tree).toMatchSnapshot();\n});\n\ntest('TapArea sets fullWidth correctly', () => {\n  const tree = create(\n    <TapArea fullWidth={false} onTap={() => {}}>\n      TapArea\n    </TapArea>,\n  ).toJSON();\n  expect(tree).toMatchSnapshot();\n});\n\ntest('TapArea sets fullHeight correctly', () => {\n  const tree = create(\n    <TapArea fullHeight onTap={() => {}}>\n      TapArea\n    </TapArea>,\n  ).toJSON();\n  expect(tree).toMatchSnapshot();\n});\n\ntest('TapArea supports press style', () => {\n  const tree = create(\n    <TapArea onTap={() => {}} tapStyle=\"compress\">\n      TapArea\n    </TapArea>,\n  ).toJSON();\n  expect(tree).toMatchSnapshot();\n});\n\ntest('accessibilityControls', () => {\n  const instance = create(\n    <TapArea accessibilityControls=\"another-element\" onTap={() => {}}>\n      TapArea\n    </TapArea>,\n  ).root;\n  expect(\n    instance.find((element: any) => element.type === 'div' && element.props.role === 'button')\n      .props['aria-controls'],\n  ).toContain('another-element');\n});\n\ntest('accessibilityExpanded', () => {\n  const instance = create(\n    <TapArea accessibilityExpanded onTap={() => {}}>\n      TapArea\n    </TapArea>,\n  ).root;\n  expect(\n    instance.find((element: any) => element.type === 'div' && element.props.role === 'button')\n      .props['aria-expanded'],\n  ).toBe(true);\n});\n\ntest('accessibilityHaspopup', () => {\n  const instance = create(\n    <TapArea accessibilityHaspopup onTap={() => {}}>\n      TapArea\n    </TapArea>,\n  ).root;\n  expect(\n    instance.find((element: any) => element.type === 'div' && element.props.role === 'button')\n      .props['aria-haspopup'],\n  ).toBe(true);\n});\n\ntest('accessibilityLabel', () => {\n  const instance = create(\n    <TapArea accessibilityLabel=\"hello\" onTap={() => {}}>\n      TapArea\n    </TapArea>,\n  ).root;\n  expect(\n    instance.find((element: any) => element.type === 'div' && element.props.role === 'button')\n      .props['aria-label'],\n  ).toContain('hello');\n});", "meta": {"repo": "pinterest/gestalt", "stars": 4310, "component": "packages/gestalt/src/TapArea.tsx", "test": "packages/gestalt/src/TapArea.test.tsx"}}
{"input": "\"use client\";\n\nimport type { ComponentProps } from \"react\";\nimport { forwardRef } from \"react\";\nimport { get } from \"../../helpers/get\";\nimport { resolveProps } from \"../../helpers/resolve-props\";\nimport { useResolveTheme } from \"../../helpers/resolve-theme\";\nimport { twMerge } from \"../../helpers/tailwind-merge\";\nimport { useThemeProvider } from \"../../theme/provider\";\nimport type { DynamicStringEnumKeysOf, FlowbiteBoolean, FlowbiteColors, ThemingProps } from \"../../types\";\nimport { textareaTheme } from \"./theme\";\n\nexport interface TextareaTheme {\n  base: string;\n  colors: TextareaColors;\n  withShadow: FlowbiteBoolean;\n}\n\nexport interface TextareaColors extends Pick<FlowbiteColors, \"gray\" | \"info\" | \"failure\" | \"warning\" | \"success\"> {\n  [key: string]: string;\n}\n\nexport interface TextareaProps extends Omit<ComponentProps<\"textarea\">, \"color\" | \"ref\">, ThemingProps<TextareaTheme> {\n  color?: DynamicStringEnumKeysOf<TextareaColors>;\n  shadow?: boolean;\n}\n\nexport const Textarea = forwardRef<HTMLTextAreaElement, TextareaProps>((props, ref) => {\n  const provider = useThemeProvider();\n  const theme = useResolveTheme(\n    [textareaTheme, provider.theme?.textarea, props.theme],\n    [get(provider.clearTheme, \"textarea\"), props.clearTheme],\n    [get(provider.applyTheme, \"textarea\"), props.applyTheme],\n  );\n\n  const { className, color = \"gray\", shadow, ...restProps } = resolveProps(props, provider.props?.textarea);\n\n  return (\n    <textarea\n      ref={ref}\n      className={twMerge(theme.base, theme.colors[color], theme.withShadow[shadow ? \"on\" : \"off\"], className)}\n      {...restProps}\n    />\n  );\n});\n\nTextarea.displayName = \"Textarea\";", "output": "import { render } from \"@testing-library/react\";\nimport { describe, expect, it } from \"vitest\";\nimport { Textarea } from \"./Textarea\";\n\ndescribe.concurrent(\"Components / Textarea\", () => {\n  describe.concurrent(\"A11y\", () => {\n    it('should have role=\"textbox\" by default', () => {\n      const textArea = render(<Textarea />).getByRole(\"textbox\");\n\n      expect(textArea).toBeInTheDocument();\n    });\n  });\n});", "meta": {"repo": "themesberg/flowbite-react", "stars": 2046, "component": "packages/ui/src/components/Textarea/Textarea.tsx", "test": "packages/ui/src/components/Textarea/Textarea.test.tsx"}}
{"input": "import isUndefined from 'lodash/isUndefined';\n\nimport ExternalLink from './ExternalLink';\nimport styles from './NoData.module.css';\n\ninterface Props {\n  children: string | JSX.Element;\n  className?: string;\n  issuesLinkVisible?: boolean;\n}\n\nconst NoData = (props: Props) => (\n  <div\n    role=\"alert\"\n    className={`alert alert-primary ms-auto me-auto my-5 text-center p-4 p-sm-5 border border-1 ${styles.wrapper} ${props.className}`}\n  >\n    <div className=\"h4\">{props.children}</div>\n    {!isUndefined(props.issuesLinkVisible) && props.issuesLinkVisible && (\n      <div className=\"h6 mt-4\">\n        If this error persists, please create an issue{' '}\n        <ExternalLink href=\"https://github.com/artifacthub/hub/issues/new/choose\" label=\"GitHub issue\">\n          <u>here</u>\n        </ExternalLink>\n      </div>\n    )}\n  </div>\n);\n\nexport default NoData;", "output": "import { render, screen } from '@testing-library/react';\n\nimport NoData from './NoData';\n\nconst defaultProps = {\n  children: 'no data',\n};\n\ndescribe('NoData', () => {\n  it('creates snapshot', () => {\n    const { asFragment } = render(<NoData {...defaultProps} />);\n    expect(asFragment()).toMatchSnapshot();\n  });\n\n  it('renders proper content', () => {\n    render(<NoData {...defaultProps} />);\n    expect(screen.getByRole('alert')).toBeInTheDocument();\n    expect(screen.getByText(defaultProps.children)).toBeInTheDocument();\n  });\n\n  it('renders proper content with issues link visible', () => {\n    render(<NoData {...defaultProps} issuesLinkVisible />);\n    expect(screen.getByText(/If this error persists, please create an issue/i)).toBeInTheDocument();\n    const link = screen.getByRole('button');\n    expect(link).toBeInTheDocument();\n    expect(link).toHaveTextContent('here');\n    expect(link).toHaveAttribute('href', 'https://github.com/artifacthub/hub/issues/new/choose');\n  });\n});", "meta": {"repo": "artifacthub/hub", "stars": 1864, "component": "web/src/layout/common/NoData.tsx", "test": "web/src/layout/common/NoData.test.tsx"}}
{"input": "import React from 'react';\n\nimport { useI18nContext } from '../../../../../../hooks/useI18nContext';\nimport { Box } from '../../../../../../components/component-library';\nimport { BlockSize } from '../../../../../../helpers/constants/design-system';\nimport {\n  ConfirmInfoRow,\n  ConfirmInfoRowText,\n} from '../../../../../../components/app/confirm/info/row';\nimport { parseSanitizeTypedDataMessage } from '../../../../utils';\nimport { DataTree } from '../dataTree';\n\nexport const ConfirmInfoRowTypedSignData = ({\n  data,\n  tokenDecimals,\n  chainId,\n}: {\n  data: string;\n  isPermit?: boolean;\n  tokenDecimals?: number;\n  chainId: string;\n}) => {\n  const t = useI18nContext();\n\n  if (!data) {\n    return null;\n  }\n\n  const { sanitizedMessage, primaryType } = parseSanitizeTypedDataMessage(data);\n\n  return (\n    <Box width={BlockSize.Full}>\n      <ConfirmInfoRow\n        label={`${t('primaryType')}:`}\n        style={{ paddingLeft: 0, paddingRight: 0 }}\n      >\n        <ConfirmInfoRowText text={primaryType} />\n      </ConfirmInfoRow>\n      <Box style={{ marginLeft: -8 }}>\n        <DataTree\n          data={sanitizedMessage.value}\n          primaryType={primaryType}\n          tokenDecimals={tokenDecimals}\n          chainId={chainId}\n        />\n      </Box>\n    </Box>\n  );\n};", "output": "import React from 'react';\nimport {\n  rawMessageV4,\n  unapprovedTypedSignMsgV4,\n} from '../../../../../../../test/data/confirmations/typed_sign';\nimport mockState from '../../../../../../../test/data/mock-state.json';\nimport { renderWithProvider } from '../../../../../../../test/lib/render-helpers';\nimport configureStore from '../../../../../../store/store';\nimport { ConfirmInfoRowTypedSignData } from './typedSignData';\n\nconst CHAIN_ID_MOCK = '0x123';\n\ndescribe('ConfirmInfoRowTypedSignData', () => {\n  const renderWithComponentData = (\n    data = unapprovedTypedSignMsgV4.msgParams?.data as string,\n  ) => {\n    const store = configureStore(mockState);\n\n    return renderWithProvider(\n      <ConfirmInfoRowTypedSignData data={data} chainId={CHAIN_ID_MOCK} />,\n      store,\n    );\n  };\n\n  it('should match snapshot', () => {\n    const { container } = renderWithComponentData(\n      unapprovedTypedSignMsgV4.msgParams?.data as string,\n    );\n    expect(container).toMatchSnapshot();\n  });\n\n  it('should return null if data is not defined', () => {\n    const { container } = renderWithComponentData('');\n    expect(container).toBeEmptyDOMElement();\n  });\n\n  it('should not render data whose type is not defined', () => {\n    // TODO: Fix in https://github.com/MetaMask/metamask-extension/issues/31973\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const mockRawMessageV4 = { ...rawMessageV4 } as any;\n\n    mockRawMessageV4.message.do_not_display = 'one';\n    mockRawMessageV4.message.do_not_display_2 = {\n      do_not_display: 'two',\n    };\n\n    const mockV4MsgParamsData = JSON.stringify(mockRawMessageV4);\n    const { queryByText } = renderWithComponentData(mockV4MsgParamsData);\n\n    expect(queryByText('do_not_display')).not.toBeInTheDocument();\n    expect(queryByText('one')).not.toBeInTheDocument();\n    expect(queryByText('do_not_display_2')).not.toBeInTheDocument();\n    expect(queryByText('two')).not.toBeInTheDocument();\n  });\n});", "meta": {"repo": "MetaMask/metamask-extension", "stars": 12621, "component": "ui/pages/confirmations/components/confirm/row/typed-sign-data/typedSignData.tsx", "test": "ui/pages/confirmations/components/confirm/row/typed-sign-data/typedSignData.test.tsx"}}
{"input": "import * as React from 'react';\nimport { styled } from '../../Utilities';\nimport { PersonaBase } from './Persona.base';\nimport { getStyles } from './Persona.styles';\nimport type { IPersonaProps, IPersonaStyleProps, IPersonaStyles } from './Persona.types';\n\n/**\n * Personas are used for rendering an individual's avatar, presence and details.\n * They are used within the PeoplePicker components.\n */\nexport const Persona: React.FunctionComponent<IPersonaProps> = styled<\n  IPersonaProps,\n  IPersonaStyleProps,\n  IPersonaStyles\n>(PersonaBase, getStyles, undefined, {\n  scope: 'Persona',\n});", "output": "import '@testing-library/jest-dom';\nimport * as React from 'react';\nimport { create } from '@fluentui/test-utilities';\nimport { TestImages } from '@fluentui/example-data';\nimport { Icon } from '../../Icon';\nimport { setRTL } from '../../Utilities';\nimport { Persona } from './Persona';\nimport { render, screen } from '@testing-library/react';\nimport { getIcon } from '../../Styling';\nimport { PersonaPresence, PersonaSize } from './index';\nimport { isConformant } from '../../common/isConformant';\nimport type { IPersonaSharedProps, IPersonaCoinProps } from './index';\nimport { wrapPersona } from './test-utils';\n\nconst testImage1x1 =\n  'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQImWP4DwQACfsD/eNV8pwAAAAASUVORK5CYII=';\n// NOTES: The following styles have been used with enzyme previously, keeping here for reference.\n// const STYLES = {\n//   green: '.ms-Persona-initials--green',\n//   initials: '.ms-Persona-initials',\n//   primaryText: '.ms-Persona-primaryText',\n//   black: '.ms-Persona-initials--black',\n//   red: '.ms-Persona-initials--red',\n// };\n\nconst customOnRenderPersonaFunction = (props: IPersonaCoinProps): JSX.Element | null => {\n  return <Icon iconName=\"Dictionary\" />;\n};\n\nconst examplePersona: IPersonaSharedProps = {\n  imageUrl: TestImages.personaMale,\n  imageInitials: 'SV',\n  text: 'Swapnil Vaibhav',\n  secondaryText: 'Software Engineer',\n  tertiaryText: 'In a meeting',\n  optionalText: 'Available at 4:00pm',\n  size: PersonaSize.size100,\n  presence: PersonaPresence.blocked,\n};\n\ndescribe('Persona', () => {\n  beforeEach(() => {\n    setRTL(false);\n  });\n\n  it('renders Persona correctly with no props', () => {\n    const component = create(<Persona />);\n    const tree = component.toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('renders Persona correctly with initials', () => {\n    const component = create(<Persona text=\"Kat Larrson\" />);\n    const tree = component.toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('renders Persona correctly with image', () => {\n    const component = create(<Persona text=\"Kat Larrson\" imageUrl={testImage1x1} />);\n    const tree = component.toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('renders Persona correctly with UnknownPersona coin', () => {\n    const component = create(<Persona text=\"Kat Larrson\" showUnknownPersonaCoin={true} />);\n    const tree = component.toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('renders Persona which calls onRenderCoin callback without imageUrl', () => {\n    // removing imageUrl prop from example\n    const { imageUrl, ...exampleWithoutImage } = examplePersona;\n    const component = create(\n      <Persona\n        {...exampleWithoutImage}\n        // eslint-disable-next-line @typescript-eslint/no-deprecated\n        onRenderCoin={wrapPersona(exampleWithoutImage, true)}\n      />,\n    );\n    const tree = component.toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('renders Persona which calls onRenderPersonaCoin callback with custom render', () => {\n    const component = create(<Persona {...examplePersona} onRenderPersonaCoin={customOnRenderPersonaFunction} />);\n    const tree = component.toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('renders correctly with onRender callback', () => {\n    const component = create(\n      <Persona\n        {...examplePersona}\n        onRenderPrimaryText={wrapPersona(examplePersona)}\n        onRenderSecondaryText={wrapPersona(examplePersona)}\n        onRenderTertiaryText={wrapPersona(examplePersona)}\n      />,\n    );\n    const tree = component.toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('renders Persona children correctly', () => {\n    const component = create(\n      <Persona text=\"Kat Larrson\">\n        <span>Persona Children</span>\n      </Persona>,\n    );\n    const tree = component.toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n\n  isConformant({\n    Component: Persona,\n    displayName: 'Persona',\n  });\n\n  describe('initials and colors', () => {\n    it('calculates an expected initials in LTR if one was not specified', () => {\n      const { rerender } = render(<Persona text=\"Kat Larrson\" />);\n      const initials = screen.getByText('KL');\n      expect(initials).toBeInTheDocument();\n\n      rerender(<Persona text=\"David Zearing-Goff\" />);\n      const initialsDZ = screen.getByText('DZ');\n      expect(initialsDZ).toBeInTheDocument();\n\n      rerender(<Persona text=\"4lex 5loo\" />);\n      const initials45 = screen.getByText('45');\n      expect(initials45).toBeInTheDocument();\n\n      rerender(<Persona text=\"Swapnil Vaibhav\" />);\n      const primaryText = screen.getByText('SV');\n      expect(primaryText).toBeInTheDocument();\n\n      const contactIconCode = getIcon('contact')?.code || '';\n      rerender(<Persona text=\"+1 (555) 6789\" />);\n      const contactIcon = screen.getByText(contactIconCode);\n      expect(contactIcon).toBeInTheDocument();\n\n      rerender(<Persona text=\"+1 (555) 6789\" allowPhoneInitials={true} />);\n      const phoneInitials = screen.getByText('16');\n      expect(phoneInitials).toBeInTheDocument();\n\n      rerender(<Persona text=\"David (The man) Goff\" />);\n      const initialsDG = screen.getByText('DG');\n      expect(initialsDG).toBeInTheDocument();\n\n      rerender(<Persona text=\"David [The man] Goff\" />);\n      const initialsDGBracket = screen.getByText('DG');\n      expect(initialsDGBracket).toBeInTheDocument();\n\n      rerender(<Persona text=\"David Goff {The man}\" />);\n      const initialsDGCurly = screen.getByText('DG');\n      expect(initialsDGCurly).toBeInTheDocument();\n\n      rerender(<Persona text=\"David Goff <The man>\" />);\n      const initialsDGAngle = screen.getByText('DG');\n      expect(initialsDGAngle).toBeInTheDocument();\n\n      rerender(<Persona text=\"David Goff (The man) <David.Goff@example.com>\" />);\n      const initialsDGComplex = screen.getByText('DG');\n      expect(initialsDGComplex).toBeInTheDocument();\n    });\n\n    it('calculates an expected initials in RTL if one was not specified', () => {\n      setRTL(true);\n      render(<Persona text=\"Kat Larrson\" />);\n      const initials = screen.getByText('LK');\n      expect(initials).toBeInTheDocument();\n      setRTL(false);\n    });\n\n    it('uses provided initial', () => {\n      setRTL(true);\n      render(<Persona text=\"Kat Larrson\" imageInitials=\"AT\" />);\n      const initials = screen.getByText('AT');\n      expect(initials).toBeInTheDocument();\n      setRTL(false);\n    });\n  });\n\n  describe('image', () => {\n    it('renders empty alt text by default', () => {\n      const { container } = render(<Persona text=\"Kat Larrson\" imageUrl={testImage1x1} />);\n      const image = container.querySelector('img');\n      expect(image).toHaveAttribute('alt', '');\n    });\n\n    it('renders its given alt text', () => {\n      const { container } = render(<Persona text=\"Kat Larrson\" imageUrl={testImage1x1} imageAlt=\"ALT TEXT\" />);\n      const image = container.querySelector('img');\n      expect(image).toHaveAttribute('alt', 'ALT TEXT');\n    });\n  });\n});", "meta": {"repo": "microsoft/fluentui", "stars": 19349, "component": "packages/react/src/components/Persona/Persona.tsx", "test": "packages/react/src/components/Persona/Persona.test.tsx"}}
{"input": "/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0; you may not use this file except in compliance with the Elastic License\n * 2.0.\n */\n\nimport { lazy } from 'react';\nimport { i18n } from '@kbn/i18n';\nimport type {\n  GenericValidationResult,\n  ActionTypeModel as ConnectorTypeModel,\n} from '@kbn/triggers-actions-ui-plugin/public';\nimport { MAX_OTHER_FIELDS_LENGTH } from '../../../common/jira/constants';\nimport { JiraConfig, JiraSecrets, JiraActionParams } from './types';\nimport { validateJSON } from '../lib/validate_json';\n\nexport const JIRA_DESC = i18n.translate('xpack.stackConnectors.components.jira.selectMessageText', {\n  defaultMessage: 'Create an incident in Jira.',\n});\n\nexport const JIRA_TITLE = i18n.translate(\n  'xpack.stackConnectors.components.jira.connectorTypeTitle',\n  {\n    defaultMessage: 'Jira',\n  }\n);\n\nexport function getConnectorType(): ConnectorTypeModel<JiraConfig, JiraSecrets, JiraActionParams> {\n  return {\n    id: '.jira',\n    iconClass: lazy(() => import('./logo')),\n    selectMessage: JIRA_DESC,\n    actionTypeTitle: JIRA_TITLE,\n    actionConnectorFields: lazy(() => import('./jira_connectors')),\n    validateParams: async (\n      actionParams: JiraActionParams\n    ): Promise<GenericValidationResult<unknown>> => {\n      const translations = await import('./translations');\n      const errors = {\n        'subActionParams.incident.summary': new Array<string>(),\n        'subActionParams.incident.labels': new Array<string>(),\n        'subActionParams.incident.otherFields': new Array<string>(),\n      };\n      const validationResult = {\n        errors,\n      };\n      if (\n        actionParams.subActionParams &&\n        actionParams.subActionParams.incident &&\n        !actionParams.subActionParams.incident.summary?.length\n      ) {\n        errors['subActionParams.incident.summary'].push(translations.SUMMARY_REQUIRED);\n      }\n\n      if (actionParams.subActionParams?.incident?.labels?.length) {\n        // Jira do not allows empty spaces on labels. If the label includes a whitespace show an error.\n        if (actionParams.subActionParams.incident.labels.some((label) => label.match(/\\s/g)))\n          errors['subActionParams.incident.labels'].push(translations.LABELS_WHITE_SPACES);\n      }\n\n      const jsonErrors = validateJSON({\n        value: actionParams.subActionParams?.incident?.otherFields,\n        maxProperties: MAX_OTHER_FIELDS_LENGTH,\n      });\n\n      if (jsonErrors) {\n        errors['subActionParams.incident.otherFields'] = [jsonErrors];\n      }\n\n      return validationResult;\n    },\n    actionParamsFields: lazy(() => import('./jira_params')),\n  };\n}", "output": "/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0; you may not use this file except in compliance with the Elastic License\n * 2.0.\n */\n\nimport { TypeRegistry } from '@kbn/triggers-actions-ui-plugin/public/application/type_registry';\nimport { registerConnectorTypes } from '..';\nimport type { ActionTypeModel as ConnectorTypeModel } from '@kbn/triggers-actions-ui-plugin/public/types';\nimport { experimentalFeaturesMock, registrationServicesMock } from '../../mocks';\nimport { ExperimentalFeaturesService } from '../../common/experimental_features_service';\nimport { MAX_OTHER_FIELDS_LENGTH } from '../../../common/jira/constants';\n\nconst CONNECTOR_TYPE_ID = '.jira';\nlet connectorTypeModel: ConnectorTypeModel;\n\nbeforeAll(() => {\n  const connectorTypeRegistry = new TypeRegistry<ConnectorTypeModel>();\n  ExperimentalFeaturesService.init({ experimentalFeatures: experimentalFeaturesMock });\n  registerConnectorTypes({ connectorTypeRegistry, services: registrationServicesMock });\n  const getResult = connectorTypeRegistry.get(CONNECTOR_TYPE_ID);\n  if (getResult !== null) {\n    connectorTypeModel = getResult;\n  }\n});\n\ndescribe('connectorTypeRegistry.get() works', () => {\n  test('connector type static data is as expected', () => {\n    expect(connectorTypeModel.id).toEqual(CONNECTOR_TYPE_ID);\n  });\n});\n\ndescribe('jira action params validation', () => {\n  test('action params validation succeeds when action params is valid', async () => {\n    const actionParams = {\n      subActionParams: { incident: { summary: 'some title {{test}}' }, comments: [] },\n    };\n\n    expect(await connectorTypeModel.validateParams(actionParams)).toEqual({\n      errors: {\n        'subActionParams.incident.summary': [],\n        'subActionParams.incident.labels': [],\n        'subActionParams.incident.otherFields': [],\n      },\n    });\n  });\n\n  test('params validation fails when body is not valid', async () => {\n    const actionParams = {\n      subActionParams: { incident: { summary: '' }, comments: [] },\n    };\n\n    expect(await connectorTypeModel.validateParams(actionParams)).toEqual({\n      errors: {\n        'subActionParams.incident.summary': ['Summary is required.'],\n        'subActionParams.incident.labels': [],\n        'subActionParams.incident.otherFields': [],\n      },\n    });\n  });\n\n  test('params validation fails when labels contain spaces', async () => {\n    const actionParams = {\n      subActionParams: {\n        incident: { summary: 'some title', labels: ['label with spaces'] },\n        comments: [],\n      },\n    };\n\n    expect(await connectorTypeModel.validateParams(actionParams)).toEqual({\n      errors: {\n        'subActionParams.incident.summary': [],\n        'subActionParams.incident.labels': ['Labels cannot contain spaces.'],\n        'subActionParams.incident.otherFields': [],\n      },\n    });\n  });\n\n  test('params validation fails when otherFields is not valid JSON', async () => {\n    const actionParams = {\n      subActionParams: {\n        incident: { summary: 'some title', otherFields: 'invalid json' },\n        comments: [],\n      },\n    };\n\n    expect(await connectorTypeModel.validateParams(actionParams)).toEqual({\n      errors: {\n        'subActionParams.incident.summary': [],\n        'subActionParams.incident.labels': [],\n        'subActionParams.incident.otherFields': ['Invalid JSON.'],\n      },\n    });\n  });\n\n  test(`params validation succeeds when its valid json and otherFields has ${MAX_OTHER_FIELDS_LENGTH} fields`, async () => {\n    const longJSON: { [key in string]: string } = {};\n    for (let i = 0; i < MAX_OTHER_FIELDS_LENGTH; i++) {\n      longJSON[`key${i}`] = 'value';\n    }\n    const actionParams = {\n      subActionParams: {\n        incident: {\n          summary: 'some title',\n          otherFields: JSON.stringify(longJSON),\n        },\n        comments: [],\n      },\n    };\n\n    expect(await connectorTypeModel.validateParams(actionParams)).toEqual({\n      errors: {\n        'subActionParams.incident.summary': [],\n        'subActionParams.incident.labels': [],\n        'subActionParams.incident.otherFields': [],\n      },\n    });\n  });\n\n  test(`params validation fails when otherFields has ${\n    MAX_OTHER_FIELDS_LENGTH + 1\n  } fields`, async () => {\n    const longJSON: { [key in string]: string } = {};\n    for (let i = 0; i < MAX_OTHER_FIELDS_LENGTH + 1; i++) {\n      longJSON[`key${i}`] = 'value';\n    }\n    const actionParams = {\n      subActionParams: {\n        incident: {\n          summary: 'some title',\n          otherFields: JSON.stringify(longJSON),\n        },\n        comments: [],\n      },\n    };\n\n    expect(await connectorTypeModel.validateParams(actionParams)).toEqual({\n      errors: {\n        'subActionParams.incident.summary': [],\n        'subActionParams.incident.labels': [],\n        'subActionParams.incident.otherFields': [\n          `A maximum of ${MAX_OTHER_FIELDS_LENGTH} additional fields can be defined at a time.`,\n        ],\n      },\n    });\n  });\n});", "meta": {"repo": "elastic/kibana", "stars": 20552, "component": "x-pack/platform/plugins/shared/stack_connectors/public/connector_types/jira/jira.tsx", "test": "x-pack/platform/plugins/shared/stack_connectors/public/connector_types/jira/jira.test.tsx"}}
{"input": "/*\n * Copyright (C) 2021 - present Instructure, Inc.\n *\n * This file is part of Canvas.\n *\n * Canvas is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Affero General Public License as published by the Free\n * Software Foundation, version 3 of the License.\n *\n * Canvas is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the GNU Affero General Public License for more\n * details.\n *\n * You should have received a copy of the GNU Affero General Public License along\n * with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport React, {useRef, useEffect, useCallback} from 'react'\nimport {useShallow} from 'zustand/react/shallow'\nimport {camelizeProperties} from '@canvas/convert-case'\nimport PostGradesStore from '../SISGradePassback/PostGradesStore'\nimport Gradebook from './Gradebook'\nimport {findFilterValuesOfType} from './Gradebook.utils'\nimport type {GradebookOptions} from './gradebook.d'\nimport PerformanceControls from './PerformanceControls'\nimport {RequestDispatch} from '@canvas/network'\nimport useStore from './stores/index'\n\ntype Props = {\n  actionMenuNode: HTMLSpanElement\n  anonymousSpeedGraderAlertNode: HTMLSpanElement\n  applyScoreToUngradedModalNode: HTMLElement\n  currentUserId: string\n  enhancedActionMenuNode: HTMLSpanElement\n  flashMessageContainer: HTMLElement\n  gradebookEnv: GradebookOptions\n  gradebookGridNode: HTMLElement\n  gradebookMenuNode: HTMLElement\n  gradebookSettingsModalContainer: HTMLSpanElement\n  gridColorNode: HTMLElement\n  locale: string\n  settingsModalButtonContainer: HTMLElement\n  viewOptionsMenuNode: HTMLElement\n}\n\nexport default function GradebookData(props: Props) {\n  const performanceControls = useRef(\n    new PerformanceControls(camelizeProperties(props.gradebookEnv.performance_controls)),\n  )\n  const dispatch = useRef(\n    new RequestDispatch({\n      activeRequestLimit: performanceControls.current.activeRequestLimit,\n    }),\n  )\n  const postGradesStore = useRef(\n    PostGradesStore({\n      course: {id: props.gradebookEnv.context_id, sis_id: props.gradebookEnv.context_sis_id},\n    }),\n  )\n  const courseId = props.gradebookEnv.context_id\n  const flashMessages = useStore(state => state.flashMessages)\n\n  const appliedFilters = useStore(useShallow(state => state.appliedFilters))\n  const isFiltersLoading = useStore(state => state.isFiltersLoading)\n  const initializeAppliedFilters = useStore(state => state.initializeAppliedFilters)\n  const initializeStagedFilters = useStore(state => state.initializeStagedFilters)\n  const fetchFilters = useStore(state => state.fetchFilters)\n\n  const modules = useStore(state => state.modules)\n  const isModulesLoading = useStore(state => state.isModulesLoading)\n  const fetchModules = useStore(state => state.fetchModules)\n\n  const customColumns = useStore(useShallow(state => state.customColumns))\n  const isCustomColumnsLoaded = useStore(state => state.isCustomColumnsLoaded)\n  const fetchCustomColumns = useStore(state => state.fetchCustomColumns)\n  const loadDataForCustomColumn = useStore(state => state.loadDataForCustomColumn)\n  const recentlyLoadedCustomColumnData = useStore(state => state.recentlyLoadedCustomColumnData)\n  const reorderCustomColumns = useStore(state => state.reorderCustomColumns)\n  const updateColumnOrder = useStore(state => state.updateColumnOrder)\n\n  const finalGradeOverrides = useStore(state => state.finalGradeOverrides)\n  const fetchFinalGradeOverrides = useStore(state => state.fetchFinalGradeOverrides)\n\n  const studentIds = useStore(useShallow(state => state.studentIds))\n  const isStudentIdsLoading = useStore(state => state.isStudentIdsLoading)\n  const recentlyLoadedStudents = useStore(state => state.recentlyLoadedStudents)\n  const recentlyLoadedSubmissions = useStore(state => state.recentlyLoadedSubmissions)\n  const loadStudentData = useStore(state => state.loadStudentData)\n  const isStudentDataLoaded = useStore(state => state.isStudentDataLoaded)\n  const isSubmissionDataLoaded = useStore(state => state.isSubmissionDataLoaded)\n  const totalSubmissionsLoaded = useStore(state => state.totalSubmissionsLoaded)\n  const totalStudentsToLoad = useStore(state => state.totalStudentsToLoad)\n\n  const sisOverrides = useStore(state => state.sisOverrides)\n  const fetchSisOverrides = useStore(state => state.fetchSisOverrides)\n\n  const gradingPeriodAssignments = useStore(state => state.gradingPeriodAssignments)\n  const fetchGradingPeriodAssignments = useStore(state => state.fetchGradingPeriodAssignments)\n  const loadAssignmentGroups = useStore(state => state.loadAssignmentGroups)\n  const recentlyLoadedAssignmentGroups = useStore(state => state.recentlyLoadedAssignmentGroups)\n  const assignmentMap = useStore(state => state.assignmentMap)\n\n  const currentGradingPeriodId = findFilterValuesOfType('grading-period', appliedFilters)[0]\n  const gradingPeriodSet = props.gradebookEnv.grading_period_set\n\n  // Initial state\n  useEffect(() => {\n    useStore.setState({\n      courseId,\n      dispatch: dispatch.current,\n      performanceControls: performanceControls.current,\n      hasModules: props.gradebookEnv.has_modules,\n      allowFinalGradeOverride: props.gradebookEnv.course_settings.allow_final_grade_override,\n      reorderCustomColumnsUrl: props.gradebookEnv.reorder_custom_columns_url,\n    })\n    initializeAppliedFilters(\n      props.gradebookEnv.settings.filter_rows_by || {},\n      props.gradebookEnv.settings.filter_columns_by || {},\n      props.gradebookEnv.custom_grade_statuses_enabled\n        ? props.gradebookEnv.custom_grade_statuses\n        : [],\n      props.gradebookEnv.multiselect_gradebook_filters_enabled,\n    )\n  }, [\n    courseId,\n    props.gradebookEnv.enhanced_gradebook_filters,\n    props.gradebookEnv.settings.filter_rows_by,\n    props.gradebookEnv.settings.filter_columns_by,\n    props.gradebookEnv.has_modules,\n    props.gradebookEnv.course_settings.allow_final_grade_override,\n    props.gradebookEnv.reorder_custom_columns_url,\n    initializeAppliedFilters,\n    props.gradebookEnv.custom_grade_statuses_enabled,\n    props.gradebookEnv.custom_grade_statuses,\n    props.gradebookEnv.multiselect_gradebook_filters_enabled,\n  ])\n\n  // Data loading logic goes here\n  useEffect(() => {\n    if (props.gradebookEnv.enhanced_gradebook_filters) {\n      fetchFilters()\n    }\n    if (props.gradebookEnv.has_modules) {\n      fetchModules()\n    }\n    if (props.gradebookEnv.course_settings.allow_final_grade_override) {\n      fetchFinalGradeOverrides()\n    }\n    if (props.gradebookEnv.post_grades_feature) {\n      fetchSisOverrides()\n    }\n    fetchCustomColumns()\n    loadStudentData(props.gradebookEnv.performance_improvements_for_gradebook)\n  }, [\n    fetchCustomColumns,\n    fetchFilters,\n    fetchFinalGradeOverrides,\n    fetchModules,\n    loadStudentData,\n    fetchSisOverrides,\n    initializeStagedFilters,\n    props.gradebookEnv.course_settings.allow_final_grade_override,\n    props.gradebookEnv.enhanced_gradebook_filters,\n    props.gradebookEnv.has_modules,\n    props.gradebookEnv.post_grades_feature,\n    props.gradebookEnv.settings.filter_columns_by,\n    props.gradebookEnv.settings.filter_rows_by,\n    props.gradebookEnv.performance_improvements_for_gradebook,\n  ])\n\n  useEffect(() => {\n    if (gradingPeriodSet) {\n      fetchGradingPeriodAssignments().then(() => {\n        loadAssignmentGroups({\n          useGraphQL: props.gradebookEnv.performance_improvements_for_gradebook,\n          hideZeroPointQuizzes: props.gradebookEnv.hide_zero_point_quizzes,\n          currentGradingPeriodId,\n        })\n      })\n    } else {\n      loadAssignmentGroups({\n        useGraphQL: props.gradebookEnv.performance_improvements_for_gradebook,\n        hideZeroPointQuizzes: props.gradebookEnv.hide_zero_point_quizzes,\n      })\n    }\n  }, [\n    gradingPeriodSet,\n    currentGradingPeriodId,\n    fetchGradingPeriodAssignments,\n    loadAssignmentGroups,\n    props.gradebookEnv.hide_zero_point_quizzes,\n    props.gradebookEnv.performance_improvements_for_gradebook,\n  ])\n\n  const reloadStudentData = useCallback(() => {\n    loadStudentData(props.gradebookEnv.performance_improvements_for_gradebook)\n  }, [loadStudentData, props.gradebookEnv.performance_improvements_for_gradebook])\n\n  return (\n    <Gradebook\n      {...props}\n      appliedFilters={appliedFilters}\n      assignmentMap={assignmentMap}\n      customColumns={customColumns}\n      fetchFinalGradeOverrides={fetchFinalGradeOverrides}\n      fetchGradingPeriodAssignments={fetchGradingPeriodAssignments}\n      finalGradeOverrides={finalGradeOverrides}\n      flashAlerts={flashMessages}\n      gradingPeriodAssignments={gradingPeriodAssignments}\n      isCustomColumnsLoaded={isCustomColumnsLoaded}\n      isFiltersLoading={isFiltersLoading}\n      isGridLoaded={false}\n      isModulesLoading={isModulesLoading}\n      isStudentDataLoaded={isStudentDataLoaded}\n      isStudentIdsLoading={isStudentIdsLoading}\n      loadDataForCustomColumn={loadDataForCustomColumn}\n      isSubmissionDataLoaded={isSubmissionDataLoaded}\n      modules={modules}\n      postGradesStore={postGradesStore.current}\n      recentlyLoadedAssignmentGroups={recentlyLoadedAssignmentGroups}\n      recentlyLoadedCustomColumnData={recentlyLoadedCustomColumnData}\n      recentlyLoadedStudents={recentlyLoadedStudents}\n      recentlyLoadedSubmissions={recentlyLoadedSubmissions}\n      reloadStudentData={reloadStudentData}\n      reorderCustomColumns={reorderCustomColumns}\n      sisOverrides={sisOverrides}\n      totalSubmissionsLoaded={totalSubmissionsLoaded}\n      studentIds={studentIds}\n      totalStudentsToLoad={totalStudentsToLoad}\n      updateColumnOrder={updateColumnOrder}\n    />\n  )\n}", "output": "// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-nocheck\n/*\n * Copyright (C) 2021 - present Instructure, Inc.\n *\n * This file is part of Canvas.\n *\n * Canvas is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Affero General Public License as published by the Free\n * Software Foundation, version 3 of the License.\n *\n * Canvas is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the GNU Affero General Public License for more\n * details.\n *\n * You should have received a copy of the GNU Affero General Public License along\n * with this program. If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport React from 'react'\nimport {render, screen} from '@testing-library/react'\nimport GradebookData from '../GradebookData'\nimport {defaultGradebookEnv, defaultGradebookProps} from './GradebookSpecHelper'\n\nconst defaultProps = {\n  ...defaultGradebookProps,\n  gradebookEnv: {\n    ...defaultGradebookEnv,\n  },\n  performance_controls: {\n    students_chunk_size: 2, // students per page\n  },\n}\n\nwindow.ENV.SETTINGS = {}\n\ndescribe('GradebookData', () => {\n  it('renders', () => {\n    render(<GradebookData {...defaultProps} />)\n    expect(screen.getByTitle(/Loading Gradebook/i)).toBeInTheDocument()\n    expect(screen.getByText(/Student Names/i)).toBeInTheDocument()\n    expect(screen.getByText(/Assignment Names/i)).toBeInTheDocument()\n  })\n})", "meta": {"repo": "instructure/canvas-lms", "stars": 6062, "component": "ui/features/gradebook/react/default_gradebook/GradebookData.tsx", "test": "ui/features/gradebook/react/default_gradebook/__tests__/GradebookData.test.tsx"}}
{"input": "// --- React Methods\nimport { useCallback, useEffect, useMemo } from \"react\";\n\nimport { datadogLogs } from \"@datadog/browser-logs\";\nimport { datadogRum } from \"@datadog/browser-rum\";\nimport passportOnchainInfo from \"../../deployments/onchainInfo.json\";\nimport { ChainId, chains, wagmiTransports } from \"../utils/chains\";\n\nimport { PROVIDER_ID } from \"@gitcoin/passport-types\";\n\nimport { getAttestationData } from \"../utils/onChainStamps\";\nimport { FeatureFlags } from \"../config/feature_flags\";\nimport { UseQueryResult, useQueries, useQueryClient } from \"@tanstack/react-query\";\nimport { parseValidChains } from \"./useOnChainStatus\";\nimport { useCustomization } from \"./useCustomization\";\nimport { useAccount, useChains } from \"wagmi\";\nimport { createPublicClient, PublicClient } from \"viem\";\n\nexport interface OnChainProviderMap {\n  [chainId: string]: OnChainProviderType[];\n}\n\nexport interface OnChainLastUpdates {\n  [chainId: string]: Date;\n}\n\ntype SingleChainData = {\n  score: number;\n  providers: OnChainProviderType[];\n  expirationDate?: Date;\n};\n\nexport interface OnChainScores {\n  [chainId: string]: number;\n}\n\nexport type OnChainProviderType = {\n  providerName: PROVIDER_ID;\n  expirationDate: Date;\n  issuanceDate: Date;\n};\n\nexport interface OnChainData {\n  data: Record<string, SingleChainData | undefined>;\n  activeChainProviders: OnChainProviderType[];\n  isPending: boolean;\n  refresh: (chainId?: ChainId) => void;\n}\n\nexport type DecodedProviderInfo = {\n  providerName: PROVIDER_ID;\n  providerNumber: number;\n};\n\nconst ALL_CHAIN_DATA_QUERY_KEY = [\"onChain\", \"passport\"];\n\ntype GetOnChainDataForChainResult = SingleChainData & { chainId: ChainId };\n\nconst getOnChainDataForChain = async ({\n  address,\n  chainId,\n  customScorerId,\n  publicClient,\n}: {\n  address: `0x${string}`;\n  chainId: ChainId;\n  customScorerId?: number;\n  publicClient: PublicClient;\n}): Promise<GetOnChainDataForChainResult> => {\n  const attestationData = await getAttestationData({\n    publicClient,\n    address,\n    chainId: chainId as keyof typeof passportOnchainInfo,\n    customScorerId,\n  });\n\n  const score = attestationData?.score.value || 0;\n  const expirationDate = attestationData?.score.expirationDate;\n  const providers = attestationData?.providers || [];\n\n  return {\n    chainId,\n    providers,\n    score,\n    expirationDate,\n  };\n};\n\nconst useOnChainDataQuery = (address?: string) => {\n  const wagmiChains = useChains();\n  const customization = useCustomization();\n  const enabledChains = chains\n    .filter(({ attestationProvider }) => attestationProvider?.status === \"enabled\")\n    .filter((chain) => parseValidChains(customization, chain));\n\n  // Combines results of all queries into a single object\n  const combine = useCallback((results: UseQueryResult<GetOnChainDataForChainResult>[]) => {\n    const isPending = results.some((result) => result.isPending);\n    const isError = results.some((result) => result.isError);\n    const error = results.find((result) => result.isError)?.error;\n\n    const data = results.reduce(\n      (acc, { data }) => {\n        if (data) {\n          const { chainId, ...rest } = data;\n          acc[chainId] = rest;\n        }\n        return acc;\n      },\n      {} as Record<ChainId, SingleChainData>\n    );\n\n    return {\n      data,\n      isPending,\n      isError,\n      error,\n    };\n  }, []);\n\n  return useQueries({\n    queries: enabledChains.map((chain) => {\n      const wagmiChain = wagmiChains.find(({ id }) => id === parseInt(chain.id));\n      if (!wagmiChain) throw new Error(`Chain ${chain.id} not found in wagmiChains`);\n\n      const publicClient = createPublicClient({\n        chain: wagmiChain,\n        transport: wagmiTransports[wagmiChain.id],\n      });\n\n      const customScorerId = chain.useCustomCommunityId && customization.scorer ? customization.scorer.id : undefined;\n      return {\n        enabled: FeatureFlags.FF_CHAIN_SYNC && Boolean(address) && Boolean(publicClient),\n        queryKey: [...ALL_CHAIN_DATA_QUERY_KEY, address, chain.id, customScorerId],\n        queryFn: () =>\n          getOnChainDataForChain({\n            address: address as `0x${string}`,\n            chainId: chain.id,\n            customScorerId,\n            publicClient: publicClient!,\n          }),\n      };\n    }),\n    combine,\n  });\n};\n\nconst decimalToHexChainId = (chainId: number): ChainId => {\n  const hex = chainId.toString(16);\n  return `0x${hex}`;\n};\n\nexport const useOnChainData = (): OnChainData => {\n  const { address, chain } = useAccount();\n  const chainId = decimalToHexChainId(chain?.id || 0);\n  const queryClient = useQueryClient();\n\n  const { data, isError, error, isPending } = useOnChainDataQuery(address);\n\n  const activeChainProviders = useMemo(\n    () => (chainId && data ? data[chainId]?.providers : null) || [],\n    [chainId, data]\n  );\n\n  useEffect(() => {\n    if (isError && error) {\n      console.error(\"Failed to check onchain status\", error);\n      datadogLogs.logger.error(\"Failed to check onchain status\", error);\n      datadogRum.addError(error);\n    }\n  }, [isError, error]);\n\n  const refresh = useCallback(\n    (chainId?: string) => {\n      const queryKey = [...ALL_CHAIN_DATA_QUERY_KEY, address];\n      if (chainId) {\n        queryKey.push(chainId);\n      }\n      queryClient.invalidateQueries({ queryKey });\n    },\n    [address, queryClient]\n  );\n\n  return useMemo(\n    () => ({\n      data: data || {},\n      activeChainProviders,\n      isPending,\n      refresh,\n    }),\n    [data, activeChainProviders, isPending, refresh]\n  );\n};", "output": "// useOnChainData.test.ts\nimport { vi, describe, it, expect, beforeEach } from \"vitest\";\nimport { renderHook, act } from \"@testing-library/react-hooks\";\nimport { QueryClient, QueryClientProvider } from \"@tanstack/react-query\";\nimport { useAccount, useChains } from \"wagmi\";\nimport { createPublicClient } from \"viem\";\nimport { getAttestationData } from \"../../utils/onChainStamps\";\nimport { useCustomization } from \"../../hooks/useCustomization\";\nimport { chains, wagmiTransports } from \"../../utils/chains\";\nimport { FeatureFlags } from \"../../config/feature_flags\";\nimport { useOnChainData } from \"../../hooks/useOnChainData\";\nimport { PROVIDER_ID } from \"@gitcoin/passport-types\";\n\n// Mock dependencies\nvi.mock(\"@datadog/browser-logs\");\nvi.mock(\"@datadog/browser-rum\");\nvi.mock(\"wagmi\");\nvi.mock(\"viem\");\nvi.mock(\"../../hooks/useCustomization\");\nvi.mock(\"../../utils/onChainStamps\");\n\n// Sample data for tests\nconst mockAddress = \"0x1234567890123456789012345678901234567890\";\nconst mockDecimalChainId = 1;\nconst mockHexChainId = \"0x1\";\nconst mockProviders = [\n  {\n    providerName: \"github\" as PROVIDER_ID,\n    expirationDate: new Date(\"2023-12-31\"),\n    issuanceDate: new Date(\"2023-01-01\"),\n  },\n];\n\n// Create wrapper with QueryClient\nconst createWrapper = () => {\n  const queryClient = new QueryClient({\n    defaultOptions: {\n      queries: {\n        retry: false,\n      },\n    },\n  });\n\n  return ({ children }: { children: React.ReactNode }) => (\n    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>\n  );\n};\n\ndescribe(\"useOnChainData hook\", () => {\n  const mockQueryInvalidate = vi.fn();\n  const mockConsoleError = vi.fn();\n\n  beforeEach(() => {\n    vi.resetAllMocks();\n\n    // Setup feature flag\n    FeatureFlags.FF_CHAIN_SYNC = true;\n\n    // Mock chain data\n    const mockChains = [\n      {\n        id: mockHexChainId,\n        attestationProvider: { status: \"enabled\" },\n        useCustomCommunityId: false,\n      },\n    ];\n    Object.defineProperty(chains, \"length\", { value: mockChains.length });\n    Object.assign(chains, mockChains);\n\n    // Mock wagmi hooks\n    vi.mocked(useChains).mockReturnValue([{ id: mockDecimalChainId, name: \"Ethereum\" } as any]);\n    vi.mocked(useAccount).mockReturnValue({\n      address: mockAddress,\n      chain: { id: mockDecimalChainId },\n    } as any);\n\n    // Mock useCustomization\n    vi.mocked(useCustomization).mockReturnValue({\n      scorer: { id: 1 },\n    } as any);\n\n    // Mock createPublicClient\n    const mockPublicClient = {};\n    vi.mocked(createPublicClient).mockReturnValue(mockPublicClient as any);\n\n    // Mock wagmiTransports\n    Object.assign(wagmiTransports, {\n      [mockDecimalChainId]: vi.fn(),\n    });\n\n    // Mock getAttestationData\n    vi.mocked(getAttestationData).mockResolvedValue({\n      score: { value: 10, expirationDate: new Date(\"2023-12-31\") },\n      providers: mockProviders,\n    } as any);\n\n    // Mock QueryClient's invalidateQueries\n    vi.spyOn(QueryClient.prototype, \"invalidateQueries\").mockImplementation(mockQueryInvalidate);\n\n    // Mock console.error\n    console.error = mockConsoleError;\n  });\n\n  it(\"returns initial state while loading\", async () => {\n    // Arrange\n    vi.mocked(getAttestationData).mockImplementation(\n      () =>\n        new Promise((resolve) => {\n          setTimeout(() => {\n            resolve({\n              score: { value: 10, expirationDate: new Date(\"2023-12-31\") },\n              providers: mockProviders,\n            } as any);\n          }, 100);\n        })\n    );\n\n    // Act\n    const { result, waitForNextUpdate } = renderHook(() => useOnChainData(), {\n      wrapper: createWrapper(),\n    });\n\n    // Assert\n    expect(result.current.isPending).toBe(true);\n    expect(result.current.data).toEqual({});\n    expect(result.current.activeChainProviders).toEqual([]);\n\n    // Wait for update to complete\n    await waitForNextUpdate();\n  });\n\n  it(\"returns data when loaded successfully\", async () => {\n    // Arrange\n    const expectedData = {\n      score: 10,\n      providers: mockProviders,\n      expirationDate: new Date(\"2023-12-31\"),\n    };\n\n    // Act\n    const { result, waitForNextUpdate } = renderHook(() => useOnChainData(), {\n      wrapper: createWrapper(),\n    });\n\n    // Wait for the query to complete\n    await waitForNextUpdate();\n\n    // Assert\n    expect(result.current.isPending).toBe(false);\n    expect(result.current.data[mockHexChainId]).toEqual(expectedData);\n    expect(result.current.activeChainProviders).toEqual(mockProviders);\n  });\n\n  it(\"refreshes all chains when called without chainId\", async () => {\n    // Arrange\n    const { result, waitForNextUpdate } = renderHook(() => useOnChainData(), {\n      wrapper: createWrapper(),\n    });\n\n    // Wait for initial query to complete\n    await waitForNextUpdate();\n\n    // Act\n    await act(async () => {\n      result.current.refresh();\n    });\n\n    // Assert\n    expect(mockQueryInvalidate).toHaveBeenCalledWith({\n      queryKey: [\"onChain\", \"passport\", mockAddress],\n    });\n  });\n\n  it(\"refreshes specific chain when chainId is provided\", async () => {\n    // Arrange\n    const { result, waitForNextUpdate } = renderHook(() => useOnChainData(), {\n      wrapper: createWrapper(),\n    });\n\n    // Wait for initial query to complete\n    await waitForNextUpdate();\n\n    // Act\n    await act(async () => {\n      result.current.refresh(mockHexChainId);\n    });\n\n    // Assert\n    expect(mockQueryInvalidate).toHaveBeenCalledWith({\n      queryKey: [\"onChain\", \"passport\", mockAddress, mockHexChainId],\n    });\n  });\n\n  it(\"returns active chain providers for current chain\", async () => {\n    // Arrange\n    const customProviders = [\n      {\n        providerName: \"twitter\" as PROVIDER_ID,\n        expirationDate: new Date(\"2023-12-31\"),\n        issuanceDate: new Date(\"2023-01-01\"),\n      },\n    ];\n\n    vi.mocked(getAttestationData).mockResolvedValue({\n      score: { value: 10, expirationDate: new Date(\"2023-12-31\") },\n      providers: customProviders,\n    } as any);\n\n    // Act\n    const { result, waitForNextUpdate } = renderHook(() => useOnChainData(), {\n      wrapper: createWrapper(),\n    });\n\n    // Wait for the query to complete\n    await waitForNextUpdate();\n\n    // Assert\n    expect(result.current.activeChainProviders).toEqual(customProviders);\n  });\n});", "meta": {"repo": "passportxyz/passport", "stars": 1179, "component": "app/hooks/useOnChainData.tsx", "test": "app/__tests__/hooks/useOnChainData.test.tsx"}}
{"input": "import React from 'react'\nimport styled from 'styled-components'\nimport { MediaType } from '../../../__generated__/globalTypes'\nimport { exhaustiveCheck } from '../../../helpers/utils'\nimport { ProtectedImage, ProtectedVideo } from '../ProtectedMedia'\nimport { MediaGalleryFields } from '../__generated__/MediaGalleryFields'\n\nconst StyledPhoto = styled(ProtectedImage)`\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100vw;\n  height: 100vh;\n  object-fit: contain;\n  object-position: center;\n`\n\nconst StyledVideo = styled(ProtectedVideo)`\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100vw;\n  height: 100vh;\n`\n\ntype PresentMediaProps = {\n  media: MediaGalleryFields\n  imageLoaded?(): void\n}\n\nconst PresentMedia = ({\n  media,\n  imageLoaded,\n  ...otherProps\n}: PresentMediaProps) => {\n  switch (media.type) {\n    case MediaType.Photo:\n      return (\n        <div {...otherProps}>\n          <StyledPhoto\n            key={`${media.id}-thumb`}\n            src={media.thumbnail?.url}\n            data-testid=\"present-img-thumbnail\"\n          />\n          <StyledPhoto\n            key={`${media.id}-highres`}\n            style={{ display: 'none' }}\n            src={media.highRes?.url}\n            data-testid=\"present-img-highres\"\n            onLoad={e => {\n              const elem = e.target as HTMLImageElement\n              elem.style.display = 'initial'\n              imageLoaded && imageLoaded()\n            }}\n          />\n        </div>\n      )\n    case MediaType.Video:\n      return <StyledVideo media={media} data-testid=\"present-video\" />\n  }\n\n  exhaustiveCheck(media.type)\n}\n\nexport default PresentMedia", "output": "import { render, screen } from '@testing-library/react'\n\nimport React from 'react'\nimport { MediaType } from '../../../__generated__/globalTypes'\nimport { MediaGalleryFields } from '../__generated__/MediaGalleryFields'\nimport PresentMedia from './PresentMedia'\n\ntest('render present image', () => {\n  const media: MediaGalleryFields = {\n    __typename: 'Media',\n    id: '123',\n    type: MediaType.Photo,\n    highRes: null,\n    blurhash: null,\n    videoWeb: null,\n    favorite: false,\n    thumbnail: {\n      __typename: 'MediaURL',\n      url: '/sample_image.jpg',\n      width: 300,\n      height: 200,\n    },\n  }\n\n  render(<PresentMedia media={media} />)\n\n  expect(screen.getByTestId('present-img-thumbnail')).toHaveAttribute(\n    'src',\n    'http://localhost:3000/sample_image.jpg'\n  )\n  expect(screen.getByTestId('present-img-highres')).toHaveStyle({\n    display: 'none',\n  })\n})\n\ntest('render present video', () => {\n  const media: MediaGalleryFields = {\n    __typename: 'Media',\n    id: '123',\n    type: MediaType.Video,\n    highRes: null,\n    blurhash: null,\n    favorite: false,\n    videoWeb: {\n      __typename: 'MediaURL',\n      url: '/sample_video.mp4',\n    },\n    thumbnail: {\n      __typename: 'MediaURL',\n      url: '/sample_video_thumb.jpg',\n      width: 300,\n      height: 200,\n    },\n  }\n\n  render(<PresentMedia media={media} />)\n\n  expect(screen.getByTestId('present-video')).toHaveAttribute(\n    'poster',\n    'http://localhost:3000/sample_video_thumb.jpg'\n  )\n\n  expect(\n    screen.getByTestId('present-video').querySelector('source')\n  ).toHaveAttribute('src', 'http://localhost:3000/sample_video.mp4')\n})", "meta": {"repo": "photoview/photoview", "stars": 5959, "component": "ui/src/components/photoGallery/presentView/PresentMedia.tsx", "test": "ui/src/components/photoGallery/presentView/PresentMedia.test.tsx"}}
{"input": "import * as LabelPrimitive from '@radix-ui/react-label';\nimport { cva, VariantProps } from 'cva';\nimport { isNil } from 'lodash-es';\nimport { ComponentProps, forwardRef, useId } from 'react';\nimport { cn } from 'tailwind-preset';\n\nimport HelperText from '@/components/input/HelperText';\nimport { ObjectWithNonNullableValues } from '@/types/utils';\n\nexport interface TextInputAreaProps\n  extends Omit<ComponentProps<'textarea'>, 'ref' | 'color' | 'className'>,\n    ObjectWithNonNullableValues<\n      Omit<VariantProps<typeof inputElementClassnames>, 'isFullWidth'>\n    > {\n  label?: string;\n  helperText?: string;\n}\n\nconst inputElementClassnames = cva(\n  [\n    'text-p4 px-2 pt-[5px] block w-full disabled:cursor-not-allowed',\n    'focus:outline-none',\n    'border-b',\n    'transition-[background-size] duration-[0.2s] ease-[ease]',\n  ],\n  {\n    variants: {\n      color: {\n        default: [\n          cn(\n            // border\n            'border-bg-border-form dark:disabled:border-text-text-and-icon disabled:border-bg-border-form',\n            // placeholder styles\n            'placeholder-df-gray-500 disabled:placeholder-severity-unknown/60',\n            'dark:placeholder-df-gray-600 dark:disabled:placeholder-df-gray-600',\n            // text styles\n            'dark:text-text-input-value text-text-text-and-icon',\n            // disabled text color\n            'disabled:text-severity-unknown/60 dark:disabled:text-df-gray-600',\n            // focus style\n            'bg-[length:0%_100%] dark:focus:bg-[length:100%_100%]',\n            'focus:border-b-accent-accent',\n            // dark and bg styles\n            'bg-[length:0%_100%] bg-no-repeat',\n            'bg-gradient-to-b from-transparent from-95% to-accent-accent to-95%',\n            'focus:bg-[length:100%_100%]',\n          ),\n        ],\n        error: [\n          cn(\n            // border\n            'dark:border-chart-red border-status-error dark:disabled:border-text-text-and-icon disabled:border-bg-border-form',\n            // placeholder styles\n            'placeholder-df-gray-500 disabled:placeholder-severity-unknown/60',\n            'dark:placeholder-df-gray-600 dark:disabled:placeholder-df-gray-600',\n            // text font\n            // text styles\n            'dark:text-text-input-value text-text-text-and-icon',\n            // disabled text color\n            'disabled:text-severity-unknown dark:disabled:text-df-gray-600',\n            // focus style\n            'bg-[length:0%_100%] focus:bg-[length:100%_100%]',\n            'dark:focus:border-b-chart-red focus:border-b-status-error',\n            // dark and bg styles\n            'bg-[length:0%_100%] bg-no-repeat',\n            'bg-gradient-to-b from-transparent from-95% dark:to-chart-red-500 to-status-error to-95%',\n            'focus:bg-[length:100%_100%]',\n          ),\n        ],\n      },\n\n      isFullWidth: {\n        true: 'w-full',\n      },\n    },\n    defaultVariants: {\n      color: 'default',\n      isFullWidth: false,\n    },\n  },\n);\n\nconst COLOR_DEFAULT = 'default';\n\nexport const TextInputArea = forwardRef<HTMLTextAreaElement, TextInputAreaProps>(\n  ({ label, id, cols, helperText, color = COLOR_DEFAULT, ...rest }, ref) => {\n    const internalId = useId();\n    const _id = id ? id : internalId;\n\n    return (\n      <div className=\"flex flex-col gap-2\">\n        {label && (\n          <LabelPrimitive.Root\n            htmlFor={_id}\n            className=\"font-medium dark:text-text-input-value text-text-text-and-icon\"\n          >\n            {label}\n          </LabelPrimitive.Root>\n        )}\n        <div>\n          <textarea\n            className={cn(\n              inputElementClassnames({\n                color,\n                isFullWidth: isNil(cols),\n              }),\n            )}\n            id={_id}\n            ref={ref}\n            data-testid={`textinputarea-${_id}`}\n            cols={cols}\n            {...rest}\n            style={{\n              backgroundColor: 'transparent',\n            }}\n          />\n        </div>\n        {helperText && <HelperText color={color} text={helperText} className=\"mb-2.5\" />}\n      </div>\n    );\n  },\n);\nTextInputArea.displayName = 'TextInputArea';\nexport default TextInputArea;", "output": "import '@testing-library/jest-dom';\n\nimport { fireEvent } from '@testing-library/react';\nimport { describe, expect, it, vi } from 'vitest';\n\nimport { TextInputArea } from '@/components/input/TextInputArea';\nimport { renderUI } from '@/tests/utils';\n\ndescribe(`Component TextInputArea`, () => {\n  it(`render with placehoder, label, onChange, startIcon, endIcon, helperText`, () => {\n    const onChange = vi.fn();\n    const { getByTestId, getByPlaceholderText, getByText, getByLabelText } = renderUI(\n      <TextInputArea\n        placeholder=\"test@email.com\"\n        id=\"id\"\n        onChange={onChange}\n        label=\"Comments\"\n        helperText=\"Put your comments\"\n      />,\n    );\n    expect(getByPlaceholderText('test@email.com')).toBeInTheDocument();\n\n    expect(getByLabelText('Comments')).toBeInTheDocument();\n\n    expect(getByText('Put your comments')).toBeInTheDocument();\n\n    const textInputArea = getByTestId('textinputarea-id');\n\n    // action\n    fireEvent.change(textInputArea, { target: { value: 'I am very satisfied' } });\n    expect(onChange).toHaveBeenCalledTimes(1);\n    expect(onChange).toHaveBeenCalledWith(\n      expect.objectContaining({\n        target: expect.objectContaining({\n          value: 'I am very satisfied',\n        }),\n      }),\n    );\n  });\n});", "meta": {"repo": "deepfence/ThreatMapper", "stars": 5030, "component": "deepfence_frontend/packages/ui-components/src/components/input/TextInputArea.tsx", "test": "deepfence_frontend/packages/ui-components/src/components/input/TextInputArea.test.tsx"}}
{"input": "import * as React from 'react';\nimport {useTranslation} from 'react-i18next';\nimport {isElectronRenderer} from '../../util/is-electron';\nimport './storage-quota.css';\n\nexport interface StorageQuotaProps {\n\twatch: any;\n}\n\nexport const StorageQuota: React.FC<StorageQuotaProps> = props => {\n\tconst {watch} = props;\n\tconst [lastWatch, setLastWatch] = React.useState<any>();\n\tconst [working, setWorking] = React.useState(false);\n\tconst [percentFree, setPercentFree] = React.useState<string>();\n\n\t// This is set to -1 so that we can hide the percentage while doing the\n\t// initial calculation. Later ones will show the same percentage but with a\n\t// loading icon beside it until finishes.\n\n\tconst {t} = useTranslation();\n\n\tconst hide = isElectronRenderer() || !navigator.storage?.estimate;\n\n\t// When the watch prop changes, start calculating space.\n\n\tReact.useEffect(() => {\n\t\tasync function run() {\n\t\t\tsetWorking(true);\n\n\t\t\tconst {quota, usage} = await navigator.storage.estimate();\n\n\t\t\tif (quota !== undefined && usage !== undefined) {\n\t\t\t\tsetPercentFree(((1 - usage / quota) * 100).toFixed(0));\n\t\t\t}\n\n\t\t\tsetLastWatch(watch);\n\t\t\tsetWorking(false);\n\t\t}\n\n\t\tif (!hide && !working && lastWatch !== watch) {\n\t\t\trun();\n\t\t}\n\t}, [hide, lastWatch, watch, working]);\n\n\tif (hide) {\n\t\treturn null;\n\t}\n\n\treturn (\n\t\t<span className=\"storage-quota\">\n\t\t\t{percentFree &&\n\t\t\t\tt('components.storageQuota.freeSpace', {\n\t\t\t\t\tpercent: percentFree\n\t\t\t\t})}\n\t\t</span>\n\t);\n};", "output": "import {cleanup, render, screen} from '@testing-library/react';\nimport {axe} from 'jest-axe';\nimport * as React from 'react';\nimport {isElectronRenderer} from '../../../util/is-electron';\nimport {StorageQuota, StorageQuotaProps} from '../storage-quota';\n\njest.mock('../../../util/is-electron');\n\ndescribe('<StorageQuota>', () => {\n\tconst isElectronRendererMock = isElectronRenderer as jest.Mock;\n\n\tbeforeEach(() => {\n\t\t(window.navigator as any).storage = {\n\t\t\testimate: jest.fn(() => ({\n\t\t\t\tquota: 100,\n\t\t\t\tusage: 0\n\t\t\t}))\n\t\t};\n\t});\n\n\tafterAll(() => {\n\t\tdelete (window.navigator as any).storage;\n\t});\n\n\tfunction renderComponent(props?: Partial<StorageQuotaProps>) {\n\t\treturn render(<StorageQuota watch=\"\" {...props} />);\n\t}\n\n\tit('does not display if in an Electron context', () => {\n\t\tisElectronRendererMock.mockReturnValue(true);\n\t\trenderComponent();\n\t\texpect(document.body.textContent).toBe('');\n\t});\n\n\tit('does not display if navigator.storage or navigator.storage.estimate is not available', async () => {\n\t\tdelete (window.navigator as any).storage.estimate;\n\t\trenderComponent();\n\t\texpect(document.body.textContent).toBe('');\n\t\tdelete (window.navigator as any).storage;\n\t\tcleanup();\n\t\trenderComponent();\n\t\texpect(document.body.textContent).toBe('');\n\t});\n\n\tit('displays the amount of free space available', async () => {\n\t\trenderComponent();\n\t\texpect(\n\t\t\tawait screen.findByText('components.storageQuota.freeSpace')\n\t\t).toBeInTheDocument();\n\t});\n\n\t// Can't see the change because our translate prop only shows the string, not\n\t// params.\n\tit.todo('updates if the watch prop changes');\n\n\tit('is accessible', async () => {\n\t\tconst {container} = renderComponent();\n\n\t\texpect(\n\t\t\tawait screen.findByText('components.storageQuota.freeSpace')\n\t\t).toBeInTheDocument();\n\t\texpect(await axe(container)).toHaveNoViolations();\n\t});\n});", "meta": {"repo": "klembot/twinejs", "stars": 2374, "component": "src/components/storage-quota/storage-quota.tsx", "test": "src/components/storage-quota/__tests__/storage-quota.test.tsx"}}
{"input": "import { debounce } from \"lodash\";\nimport type { TextareaHTMLAttributes } from \"react\";\nimport React, { useEffect, useLayoutEffect, useRef } from \"react\";\nimport styled from \"styled-components\";\nimport useComposedRef from \"utils/UseComposeRef\";\n\ninterface AutoResizeTextAreaStyledProps {\n  autoResize: boolean;\n}\n\ntype AutoResizeTextAreaProps = TextareaHTMLAttributes<HTMLTextAreaElement> &\n  AutoResizeTextAreaStyledProps;\n\nconst StyledTextArea = styled.textarea<AutoResizeTextAreaStyledProps>`\n  padding: 10px;\n  box-sizing: border-box;\n  width: 100%;\n  height: ${(props) => (!props.autoResize ? \"100%\" : \"auto\")};\n  overflow: ${(props) => (!props.autoResize ? \"unset\" : \"hidden\")};\n`;\n\n// This proxy textarea will never be visible\n// nor it will receive any pointer events\nconst ProxyTextArea = styled(StyledTextArea)`\n  position: absolute;\n  height: auto;\n  opacity: 0;\n  pointer-events: none;\n  visibility: hidden;\n  overflow: hidden;\n  resize: none;\n`;\n\n// Updates the height of the element\n// wrt to the scroll height of the proxy element\nfunction updateHeight<T extends HTMLElement | null>({\n  autoResize,\n  elementRef,\n  proxyElementRef,\n}: {\n  autoResize: boolean;\n  elementRef: React.MutableRefObject<T>;\n  proxyElementRef: React.MutableRefObject<T>;\n}) {\n  if (autoResize) {\n    const height = proxyElementRef.current?.scrollHeight;\n\n    if (height) {\n      if (elementRef.current !== null) {\n        elementRef.current.style.height = `${height}px`;\n      }\n    }\n  }\n}\n\nconst AutoResizeTextArea: React.ForwardRefRenderFunction<\n  HTMLTextAreaElement,\n  AutoResizeTextAreaProps\n> = (props, userRef) => {\n  const textAreaRef = useRef<HTMLTextAreaElement | null>(null);\n  const proxyTextAreaRef = useRef<HTMLTextAreaElement | null>(null);\n\n  // Here we have two refs, one internal and one forwarded to the\n  // user, used useComposedRef which gives a single ref to attach\n  // to dom node while also set the respective refs.\n  const ref = useComposedRef(textAreaRef, userRef);\n\n  // Added resize observer to detect height changes\n  // in the proxy textarea\n  // this is added to know the height changes when the width\n  // of the widget changes which in turn changes the height\n  // of the proxy textarea\n  const observer = React.useRef(\n    new ResizeObserver(\n      // Added a debounce of 100\n      // Sometimes we change the width very fast\n      // so it's better to optimise this\n      debounce(() => {\n        // As soon as the height of the proxy textarea\n        // changes we change the height of the main\n        // textarea\n        updateHeight({\n          autoResize: props.autoResize,\n          proxyElementRef: proxyTextAreaRef,\n          elementRef: textAreaRef,\n        });\n      }, 100),\n    ),\n  );\n\n  useEffect(() => {\n    if (proxyTextAreaRef.current) {\n      observer.current.observe(proxyTextAreaRef.current);\n    }\n\n    return () => {\n      if (proxyTextAreaRef.current) {\n        observer.current.unobserve(proxyTextAreaRef.current);\n      }\n    };\n  }, []);\n\n  // Update the height of the element\n  // when the value changes or\n  // whether we want to autoResize or not\n  useLayoutEffect(() => {\n    updateHeight({\n      autoResize: props.autoResize,\n      proxyElementRef: proxyTextAreaRef,\n      elementRef: textAreaRef,\n    });\n  }, [props.value, props.autoResize]);\n\n  return (\n    <>\n      <StyledTextArea {...props} ref={ref} />\n      {\n        // This is added to get the correct scroll height of a similar\n        // textarea which is not displayed on the screen whose height\n        // is always auto.\n        props.autoResize ? (\n          <ProxyTextArea\n            autoResize={props.autoResize}\n            // making it read only as we will\n            // never use this textarea, it's\n            // always hidden\n            readOnly\n            ref={proxyTextAreaRef}\n            value={props.value}\n          />\n        ) : null\n      }\n    </>\n  );\n};\n\nexport default React.forwardRef(AutoResizeTextArea);", "output": "import React from \"react\";\nimport \"@testing-library/jest-dom\";\nimport \"jest-styled-components\";\nimport renderer from \"react-test-renderer\";\nimport AutoResizeTextArea from \"./AutoResizeTextArea\";\n\ndescribe(\"<AutoResizeTextArea />\", () => {\n  describe(\"when autoResize is true\", () => {\n    it(\"it should render a proxy textarea\", async () => {\n      const tree = renderer.create(<AutoResizeTextArea autoResize />);\n\n      // eslint-disable-next-line testing-library/await-async-queries\n      expect(tree.root.findAllByType(\"textarea\").length).toBe(2);\n    });\n  });\n\n  describe(\"when autoResize is false\", () => {\n    it(\"it should not render a proxy textarea if autoResize is false\", async () => {\n      const tree = renderer.create(<AutoResizeTextArea autoResize={false} />);\n\n      // eslint-disable-next-line testing-library/await-async-queries\n      expect(tree.root.findAllByType(\"textarea\").length).toBe(1);\n    });\n  });\n});", "meta": {"repo": "appsmithorg/appsmith", "stars": 37312, "component": "app/client/src/components/editorComponents/AutoResizeTextArea.tsx", "test": "app/client/src/components/editorComponents/AutoResizeTextArea.test.tsx"}}
{"input": "/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the \"Elastic License\n * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n * Public License v 1\"; you may not use this file except in compliance with, at\n * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n * License v3.0 only\", or the \"Server Side Public License, v 1\".\n */\n\nimport React, { FC } from 'react';\nimport PropTypes from 'prop-types';\nimport { EuiButtonEmpty, EuiFlexGroup, EuiFlexItem, EuiSpacer, EuiTitle } from '@elastic/eui';\nimport { FormattedMessage } from '@kbn/i18n-react';\nimport { CoreStart } from '@kbn/core/public';\nimport { useKibana } from '@kbn/kibana-react-plugin/public';\nimport { RedirectAppLinks } from '@kbn/shared-ux-link-redirect-app';\nimport { FeatureCatalogueEntry } from '@kbn/home-plugin/public';\nimport { Synopsis } from '../synopsis';\nimport { METRIC_TYPE, trackUiMetric } from '../../lib/ui_metric';\n\ninterface Props {\n  addBasePath: (path: string) => string;\n  features: FeatureCatalogueEntry[];\n}\n\nexport const AddData: FC<Props> = ({ addBasePath, features }) => {\n  const {\n    services: { application },\n  } = useKibana<CoreStart>();\n\n  return (\n    <section className=\"kbnOverviewDataAdd\" aria-labelledby=\"kbnOverviewDataAdd__title\">\n      <EuiFlexGroup alignItems=\"center\">\n        <EuiFlexItem grow={1}>\n          <EuiTitle size=\"s\">\n            <h2 id=\"kbnOverviewDataAdd__title\">\n              <FormattedMessage\n                id=\"kibanaOverview.addData.sectionTitle\"\n                defaultMessage=\"Ingest your data\"\n              />\n            </h2>\n          </EuiTitle>\n        </EuiFlexItem>\n\n        <EuiFlexItem className=\"kbnOverviewDataAdd__actions\" grow={false}>\n          <div>\n            <EuiButtonEmpty\n              className=\"kbnOverviewDataAdd__actionButton\"\n              flush=\"both\"\n              href={addBasePath('#/tutorial_directory/sampleData')}\n              iconType=\"visTable\"\n              size=\"xs\"\n            >\n              <FormattedMessage\n                id=\"kibanaOverview.addData.sampleDataButtonLabel\"\n                defaultMessage=\"Try our sample data\"\n              />\n            </EuiButtonEmpty>\n          </div>\n        </EuiFlexItem>\n      </EuiFlexGroup>\n      <EuiSpacer size=\"m\" />\n      <EuiFlexGroup className=\"kbnOverviewDataAdd__content\">\n        {features.map((feature) => (\n          <EuiFlexItem key={feature.id}>\n            <RedirectAppLinks\n              coreStart={{\n                application,\n              }}\n            >\n              <Synopsis\n                id={feature.id}\n                description={feature.description}\n                iconType={feature.icon}\n                title={feature.title}\n                url={addBasePath(feature.path)}\n                wrapInPanel\n                onClick={() => {\n                  trackUiMetric(METRIC_TYPE.CLICK, `ingest_data_card_${feature.id}`);\n                }}\n              />\n            </RedirectAppLinks>\n          </EuiFlexItem>\n        ))}\n      </EuiFlexGroup>\n    </section>\n  );\n};\n\nAddData.propTypes = {\n  addBasePath: PropTypes.func.isRequired,\n  features: PropTypes.arrayOf(\n    PropTypes.shape({\n      id: PropTypes.string.isRequired,\n      title: PropTypes.string.isRequired,\n      description: PropTypes.string.isRequired,\n      icon: PropTypes.string.isRequired,\n      path: PropTypes.string.isRequired,\n      showOnHomePage: PropTypes.bool.isRequired,\n      category: PropTypes.string.isRequired,\n      order: PropTypes.number as PropTypes.Validator<number | undefined>,\n    }).isRequired\n  ).isRequired,\n};", "output": "/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the \"Elastic License\n * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n * Public License v 1\"; you may not use this file except in compliance with, at\n * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n * License v3.0 only\", or the \"Server Side Public License, v 1\".\n */\n\nimport React from 'react';\nimport { AddData } from './add_data';\nimport { shallowWithIntl } from '@kbn/test-jest-helpers';\n\nconst mockFeatures = [\n  {\n    category: 'data' as const,\n    description: 'Ingest data from popular apps and services.',\n    showOnHomePage: true,\n    icon: 'indexOpen',\n    id: 'home_tutorial_directory',\n    order: 500,\n    path: '/app/home#/tutorial_directory',\n    title: 'Ingest data',\n  },\n  {\n    category: 'admin' as const,\n    description: 'Add and manage your fleet of Elastic Agents and integrations.',\n    showOnHomePage: true,\n    icon: 'indexManagementApp',\n    id: 'ingestManager',\n    order: 510,\n    path: '/app/ingestManager',\n    title: 'Add Elastic Agent',\n  },\n  {\n    category: 'data' as const,\n    description: 'Import your own CSV, NDJSON, or log file',\n    showOnHomePage: true,\n    icon: 'document',\n    id: 'ml_file_data_visualizer',\n    order: 520,\n    path: '/app/ml#/filedatavisualizer',\n    title: 'Upload a file',\n  },\n];\n\njest.mock('../../lib/ui_metric', () => ({\n  trackUiMetric: jest.fn(),\n}));\n\nconst addBasePathMock = jest.fn((path: string) => (path ? path : 'path'));\n\ndescribe('AddData', () => {\n  test('render', () => {\n    const component = shallowWithIntl(\n      <AddData addBasePath={addBasePathMock} features={mockFeatures} />\n    );\n    expect(component).toMatchSnapshot();\n  });\n});", "meta": {"repo": "elastic/kibana", "stars": 20552, "component": "src/platform/plugins/private/kibana_overview/public/components/add_data/add_data.tsx", "test": "src/platform/plugins/private/kibana_overview/public/components/add_data/add_data.test.tsx"}}
{"input": "import { ACTION_TYPE_ICON_LOOKUP } from \"@/app/(app)/environments/[environmentId]/actions/utils\";\nimport { timeSince } from \"@/lib/time\";\nimport { TActionClass } from \"@formbricks/types/action-classes\";\nimport { TUserLocale } from \"@formbricks/types/user\";\n\nexport const ActionClassDataRow = ({\n  actionClass,\n  locale,\n}: {\n  actionClass: TActionClass;\n  locale: TUserLocale;\n}) => {\n  return (\n    <div className=\"m-2 grid h-16 grid-cols-6 content-center rounded-lg transition-colors ease-in-out hover:bg-slate-100\">\n      <div className=\"col-span-4 flex items-center pl-6 text-sm\">\n        <div className=\"flex items-center\">\n          <div className=\"h-5 w-5 flex-shrink-0 text-slate-500\">\n            {ACTION_TYPE_ICON_LOOKUP[actionClass.type]}\n          </div>\n          <div className=\"ml-4 text-left\">\n            <div className=\"font-medium text-slate-900\">{actionClass.name}</div>\n            <div className=\"text-xs text-slate-400\">{actionClass.description}</div>\n          </div>\n        </div>\n      </div>\n      <div className=\"col-span-2 my-auto whitespace-nowrap text-center text-sm text-slate-500\">\n        {timeSince(actionClass.createdAt.toString(), locale)}\n      </div>\n      <div className=\"text-center\"></div>\n    </div>\n  );\n};", "output": "import { timeSince } from \"@/lib/time\";\nimport { cleanup, render, screen } from \"@testing-library/react\";\nimport { afterEach, describe, expect, test, vi } from \"vitest\";\nimport { TActionClass } from \"@formbricks/types/action-classes\";\nimport { ActionClassDataRow } from \"./ActionRowData\";\n\nvi.mock(\"@/lib/time\", () => ({\n  timeSince: vi.fn(),\n}));\n\nconst mockActionClass: TActionClass = {\n  id: \"testId\",\n  createdAt: new Date(),\n  updatedAt: new Date(),\n  name: \"Test Action\",\n  description: \"This is a test action\",\n  type: \"code\",\n  noCodeConfig: null,\n  environmentId: \"envId\",\n  key: null,\n};\n\nconst locale = \"en-US\";\nconst timeSinceOutput = \"2 hours ago\";\n\ndescribe(\"ActionClassDataRow\", () => {\n  afterEach(() => {\n    cleanup();\n    vi.clearAllMocks();\n  });\n\n  test(\"renders code action correctly\", () => {\n    vi.mocked(timeSince).mockReturnValue(timeSinceOutput);\n    const actionClass = { ...mockActionClass, type: \"code\" } as TActionClass;\n    render(<ActionClassDataRow actionClass={actionClass} locale={locale} />);\n\n    expect(screen.getByText(actionClass.name)).toBeInTheDocument();\n    expect(screen.getByText(actionClass.description!)).toBeInTheDocument();\n    expect(screen.getByText(timeSinceOutput)).toBeInTheDocument();\n    expect(timeSince).toHaveBeenCalledWith(actionClass.createdAt.toString(), locale);\n  });\n\n  test(\"renders no-code action correctly\", () => {\n    vi.mocked(timeSince).mockReturnValue(timeSinceOutput);\n    const actionClass = { ...mockActionClass, type: \"noCode\" } as TActionClass;\n    render(<ActionClassDataRow actionClass={actionClass} locale={locale} />);\n\n    expect(screen.getByText(actionClass.name)).toBeInTheDocument();\n    expect(screen.getByText(actionClass.description!)).toBeInTheDocument();\n    expect(screen.getByText(timeSinceOutput)).toBeInTheDocument();\n    expect(timeSince).toHaveBeenCalledWith(actionClass.createdAt.toString(), locale);\n  });\n\n  test(\"renders without description\", () => {\n    vi.mocked(timeSince).mockReturnValue(timeSinceOutput);\n    const actionClass = { ...mockActionClass, description: undefined } as unknown as TActionClass;\n    render(<ActionClassDataRow actionClass={actionClass} locale={locale} />);\n\n    expect(screen.getByText(actionClass.name)).toBeInTheDocument();\n    expect(screen.queryByText(\"This is a test action\")).not.toBeInTheDocument();\n    expect(screen.getByText(timeSinceOutput)).toBeInTheDocument();\n  });\n});", "meta": {"repo": "formbricks/formbricks", "stars": 10833, "component": "apps/web/app/(app)/environments/[environmentId]/actions/components/ActionRowData.tsx", "test": "apps/web/app/(app)/environments/[environmentId]/actions/components/ActionRowData.test.tsx"}}
{"input": "/*\n *  This file is part of CoCalc: Copyright \u00a9 2020 Sagemath, Inc.\n *  License: MS-RSL \u2013 see LICENSE.md for details\n */\n\n/* Use this component to make an anchor tag that\n   opens in a new tab in the right way, namely\n   with rel=noopener.  This avoids sharing cpu\n   with the main cocalc page.\n*/\n\nimport { CSSProperties, ReactNode } from \"react\";\nimport { Tooltip } from \"antd\";\n\ninterface AProps {\n  href: string;\n  children: ReactNode;\n  title?: string;\n  placement?: string;\n  style?: CSSProperties;\n  onClick?: (any) => void;\n  onMouseDown?: (any) => void;\n}\n\nexport function A({\n  href,\n  children,\n  style,\n  title,\n  placement,\n  onClick,\n  onMouseDown,\n}: AProps) {\n  if (title) {\n    // use nicer antd tooltip.\n    return (\n      <Tooltip title={title} placement={placement as any}>\n        <a\n          href={href}\n          target={\"_blank\"}\n          rel={\"noopener\"}\n          style={style}\n          onClick={onClick}\n          onMouseDown={onMouseDown}\n        >\n          {children}\n        </a>\n      </Tooltip>\n    );\n  }\n  return (\n    <a\n      href={href}\n      target={\"_blank\"}\n      rel={\"noopener\"}\n      style={style}\n      title={title}\n      onClick={onClick}\n      onMouseDown={onMouseDown}\n    >\n      {children}\n    </a>\n  );\n}", "output": "import { A } from \"./A\";\nimport renderer from \"react-test-renderer\";\n\ntest(\"some basic properties of A are correct so will open a new tab at right url\", () => {\n  const component = renderer.create(<A href=\"https://cocalc.com\">CoCalc</A>);\n  let tree = component.toJSON();\n  expect(tree.type).toBe(\"a\");\n  expect(tree.props.target).toBe(\"_blank\");\n  expect(tree.props.href).toBe(\"https://cocalc.com\");\n  expect(tree.props.rel).toBe(\"noopener\");\n});", "meta": {"repo": "sagemathinc/cocalc", "stars": 1218, "component": "src/packages/frontend/components/A.tsx", "test": "src/packages/frontend/components/A.test.tsx"}}
{"input": "import {\n  type AllHTMLAttributes,\n  type UIEvent,\n  type FormEvent,\n  forwardRef,\n  useState,\n  useRef,\n  useCallback,\n} from 'react';\n\nimport { Box } from '../Box/Box';\nimport {\n  type FieldBaseProps,\n  type FieldLabelVariant,\n  Field,\n} from '../private/Field/Field';\nimport { getCharacterLimitStatus } from '../private/Field/getCharacterLimitStatus';\n\nimport { formatRanges } from './formatRanges';\n\nimport * as styles from './Textarea.css';\n\ntype NativeTextareaProps = AllHTMLAttributes<HTMLTextAreaElement>;\n\nexport type TextareaBaseProps = Omit<\n  FieldBaseProps,\n  'value' | 'secondaryMessage' | 'icon' | 'prefix'\n> & {\n  value: NonNullable<NativeTextareaProps['value']>;\n  onChange: NonNullable<NativeTextareaProps['onChange']>;\n  onBlur?: NativeTextareaProps['onBlur'];\n  onFocus?: NativeTextareaProps['onFocus'];\n  onPaste?: NativeTextareaProps['onPaste'];\n  placeholder?: NativeTextareaProps['placeholder'];\n  spellCheck?: NativeTextareaProps['spellCheck'];\n  highlightRanges?: Array<{\n    start: number;\n    end?: number;\n  }>;\n  characterLimit?: number;\n  lines?: number;\n  lineLimit?: number;\n  grow?: boolean;\n};\nexport type TextareaLabelProps = FieldLabelVariant;\nexport type TextareaProps = TextareaBaseProps & TextareaLabelProps;\n\nconst pxToInt = (str: string | null) =>\n  typeof str === 'string' ? parseInt(str.replace('px', ''), 10) : 0;\n\nconst calculateLines = (\n  target: HTMLTextAreaElement,\n  lines: number,\n  lineLimit?: number,\n) => {\n  const { paddingBottom, paddingTop, lineHeight } =\n    window.getComputedStyle(target);\n\n  // If line height is not a pixel value (e.g. 'normal' or unitless),\n  // bail out of grow behaviour as we cannot calculate accurately.\n  if (!lineHeight.endsWith('px')) {\n    return lines;\n  }\n\n  const padding = pxToInt(paddingTop) + pxToInt(paddingBottom);\n  const currentRows = Math.floor(\n    (target.scrollHeight - padding) / pxToInt(lineHeight),\n  );\n\n  if (target && target.value === '') {\n    return lines;\n  }\n\n  return typeof lineLimit === 'number' && currentRows > lineLimit\n    ? lineLimit\n    : currentRows;\n};\n\nexport const Textarea = forwardRef<HTMLTextAreaElement, TextareaProps>(\n  (\n    {\n      value,\n      onChange,\n      onBlur,\n      onFocus,\n      onPaste,\n      placeholder,\n      characterLimit,\n      highlightRanges: highlightRangesProp = [],\n      lines = 3,\n      lineLimit,\n      grow = true,\n      tone,\n      spellCheck,\n      ...restProps\n    },\n    ref,\n  ) => {\n    const [rows, setRows] = useState(lines);\n    const highlightsRef = useRef<HTMLDivElement>(null);\n    const updateScroll = useCallback(\n      (scrollTop: number) => {\n        if (highlightsRef.current) {\n          highlightsRef.current.scrollTop = scrollTop;\n        }\n      },\n      [highlightsRef],\n    );\n    const inputLength = String(value).length;\n    const hasExceededCharacterLimit =\n      characterLimit && inputLength > characterLimit;\n    const highlightTone =\n      !hasExceededCharacterLimit && (tone === 'critical' || tone === 'caution')\n        ? tone\n        : 'critical';\n    const highlightRanges = hasExceededCharacterLimit\n      ? [{ start: characterLimit }]\n      : highlightRangesProp;\n    const hasHighlights = highlightRanges.length > 0;\n\n    return (\n      <Field\n        {...restProps}\n        componentName=\"Textarea\"\n        tone={tone}\n        value={value}\n        icon={undefined}\n        prefix={undefined}\n        secondaryMessage={\n          characterLimit\n            ? getCharacterLimitStatus({\n                value,\n                characterLimit,\n              })\n            : null\n        }\n      >\n        {(overlays, { className, borderRadius, background, ...fieldProps }) => (\n          <Box\n            position=\"relative\"\n            width=\"full\"\n            zIndex={0}\n            background={background}\n            borderRadius={borderRadius}\n          >\n            {hasHighlights ? (\n              <Box\n                ref={highlightsRef}\n                position=\"absolute\"\n                overflow=\"hidden\"\n                pointerEvents=\"none\"\n                height=\"full\"\n                aria-hidden=\"true\"\n                top={0}\n                left={0}\n                className={[styles.highlights, className]}\n                {...fieldProps}\n              >\n                {formatRanges(String(value), highlightRanges, highlightTone)}\n              </Box>\n            ) : null}\n            <Box\n              component=\"textarea\"\n              position=\"relative\"\n              zIndex={1}\n              rows={rows}\n              value={value}\n              onChange={(e: FormEvent<HTMLTextAreaElement>) => {\n                if (grow) {\n                  setRows(calculateLines(e.currentTarget, lines, lineLimit));\n                }\n                if (typeof onChange === 'function') {\n                  onChange(e);\n                }\n                if (hasHighlights) {\n                  updateScroll(e.currentTarget.scrollTop);\n                }\n              }}\n              onBlur={onBlur}\n              onFocus={onFocus}\n              onPaste={onPaste}\n              onScroll={\n                hasHighlights\n                  ? (event: UIEvent<HTMLTextAreaElement>) =>\n                      updateScroll(event.currentTarget.scrollTop)\n                  : undefined\n              }\n              placeholder={!restProps.disabled ? placeholder : undefined}\n              spellCheck={spellCheck}\n              className={[styles.field, className]}\n              {...fieldProps}\n              ref={ref}\n            />\n            {overlays}\n          </Box>\n        )}\n      </Field>\n    );\n  },\n);\n\nTextarea.displayName = 'Textarea';", "output": "import '@testing-library/jest-dom';\nimport { render } from '@testing-library/react';\n\nimport { Textarea } from '..';\nimport { BraidTestProvider } from '../../../entries/test';\n\ndescribe('Textarea', () => {\n  it('associates field with label correctly', () => {\n    const { getByLabelText } = render(\n      <BraidTestProvider>\n        <Textarea label=\"My field\" value=\"\" onChange={() => {}} />\n      </BraidTestProvider>,\n    );\n\n    expect(getByLabelText('My field').tagName).toBe('TEXTAREA');\n  });\n\n  it('associates field with aria-label correctly', () => {\n    const { getByLabelText } = render(\n      <BraidTestProvider>\n        <Textarea aria-label=\"My field\" value=\"\" onChange={() => {}} />\n      </BraidTestProvider>,\n    );\n\n    expect(getByLabelText('My field').tagName).toBe('TEXTAREA');\n  });\n\n  it('associates field with aria-labelledby correctly', () => {\n    const { getByLabelText } = render(\n      <BraidTestProvider>\n        <div id=\"fieldLabel\">My field</div>\n        <Textarea\n          id=\"field\"\n          aria-labelledby=\"fieldLabel\"\n          value=\"\"\n          onChange={() => {}}\n        />\n      </BraidTestProvider>,\n    );\n\n    expect(getByLabelText('My field').tagName).toBe('TEXTAREA');\n  });\n\n  it('associates field with message correctly', () => {\n    const { getByLabelText } = render(\n      <BraidTestProvider>\n        <Textarea\n          label=\"My field\"\n          message=\"Required\"\n          value=\"\"\n          onChange={() => {}}\n        />\n      </BraidTestProvider>,\n    );\n\n    expect(getByLabelText('My field')).toHaveAccessibleDescription('Required');\n  });\n\n  it('associates field with description correctly', () => {\n    const { getByLabelText } = render(\n      <BraidTestProvider>\n        <Textarea\n          label=\"My field\"\n          description=\"More detail about field\"\n          value=\"\"\n          onChange={() => {}}\n        />\n      </BraidTestProvider>,\n    );\n\n    expect(getByLabelText('My field')).toHaveAccessibleDescription(\n      'More detail about field',\n    );\n  });\n\n  it('associates field with custom description correctly', () => {\n    const { getByLabelText } = render(\n      <BraidTestProvider>\n        <span id=\"detail\">Custom description</span>\n        <Textarea\n          label=\"My field\"\n          aria-describedby=\"detail\"\n          value=\"\"\n          onChange={() => {}}\n        />\n      </BraidTestProvider>,\n    );\n\n    expect(getByLabelText('My field')).toHaveAccessibleDescription(\n      'Custom description',\n    );\n  });\n\n  it('associates field with multiple description elements correctly', () => {\n    const { getByLabelText } = render(\n      <BraidTestProvider>\n        <span id=\"detail\">Custom description</span>\n        <Textarea\n          label=\"My field\"\n          message=\"Required\"\n          description=\"More detail about field\"\n          aria-describedby=\"detail\"\n          value=\"\"\n          onChange={() => {}}\n        />\n      </BraidTestProvider>,\n    );\n\n    expect(getByLabelText('My field')).toHaveAccessibleDescription(\n      'Custom description Required More detail about field',\n    );\n  });\n\n  it('field is not marked as having a description without a message or description', () => {\n    const { getByLabelText } = render(\n      <BraidTestProvider>\n        <Textarea label=\"My field\" value=\"\" onChange={() => {}} />\n      </BraidTestProvider>,\n    );\n\n    expect(\n      getByLabelText('My field').getAttribute('aria-describedby'),\n    ).toBeNull();\n  });\n});", "meta": {"repo": "seek-oss/braid-design-system", "stars": 1546, "component": "packages/braid-design-system/src/lib/components/Textarea/Textarea.tsx", "test": "packages/braid-design-system/src/lib/components/Textarea/Textarea.test.tsx"}}
{"input": "import { FormattedMessage } from \"react-intl\";\nimport ButtonLoader from \"components/ButtonLoader\";\nimport TextBlock from \"components/TextBlock\";\nimport JiraIcon from \"icons/JiraIcon\";\nimport { JIRA_MARKETPLACE } from \"urls\";\nimport { isEmpty } from \"utils/arrays\";\nimport Integration from \"../Integration\";\nimport Title from \"../Title\";\n\nexport const JIRA = \"jira\";\n\nconst Jira = ({\n  totalEmployees,\n  connectedEmployees,\n  connectedWorkspaces,\n  isCurrentEmployeeConnectedToJira,\n  isLoadingProps = {}\n}) => {\n  const { isGetEmployeesLoading = false, isGetJiraOrganizationStatusLoading = false } = isLoadingProps;\n\n  return (\n    <Integration\n      id={JIRA}\n      title={<Title icon={<JiraIcon />} label={<FormattedMessage id=\"jira\" />} />}\n      button={\n        <ButtonLoader\n          messageId=\"getOptScaleJiraApp\"\n          isLoading={isGetJiraOrganizationStatusLoading}\n          startIcon={<JiraIcon />}\n          color=\"primary\"\n          href={JIRA_MARKETPLACE}\n        />\n      }\n      blocks={[\n        <TextBlock key=\"description1\" messageId=\"integrationsJiraDescription1\" />,\n        <TextBlock\n          key=\"jiraConnected\"\n          messageId=\"integrationsJiraConnected\"\n          isVisible={isCurrentEmployeeConnectedToJira}\n          color=\"success\"\n        />,\n        <TextBlock\n          key=\"description2\"\n          messageId=\"integrationsJiraDescription2\"\n          isLoading={isGetEmployeesLoading}\n          values={{\n            total: totalEmployees,\n            connected: connectedEmployees,\n            strong: (chunks) => <strong>{chunks}</strong>\n          }}\n        />,\n        <TextBlock\n          key=\"noJiraWorkspacesConnected\"\n          messageId=\"noJiraWorkspacesAreConnected\"\n          isLoading={isGetJiraOrganizationStatusLoading}\n          color=\"error\"\n          isVisible={isEmpty(connectedWorkspaces)}\n        />,\n        <TextBlock\n          key=\"connectedWorkspacesTitle\"\n          messageId=\"connectedWorkspaces\"\n          isLoading={isGetJiraOrganizationStatusLoading}\n          isVisible={!isEmpty(connectedWorkspaces)}\n        />,\n        !isGetJiraOrganizationStatusLoading && (\n          <ul key=\"connectedWorkspaces\" style={{ marginTop: 0 }}>\n            {connectedWorkspaces.map(({ display_url: url }) => (\n              <li key={url}>{url}</li>\n            ))}\n          </ul>\n        )\n      ]}\n    />\n  );\n};\n\nexport default Jira;", "output": "import { createRoot } from \"react-dom/client\";\nimport TestProvider from \"tests/TestProvider\";\nimport Jira from \"./Jira\";\n\nit(\"renders without crashing\", () => {\n  const div = document.createElement(\"div\");\n  const root = createRoot(div);\n  root.render(\n    <TestProvider>\n      <Jira totalEmployees={0} connectedEmployees={0} isCurrentEmployeeConnectedToJira connectedWorkspaces={[]} />\n    </TestProvider>\n  );\n  root.unmount();\n});", "meta": {"repo": "hystax/optscale", "stars": 1515, "component": "ngui/ui/src/components/Integrations/Jira/Jira.tsx", "test": "ngui/ui/src/components/Integrations/Jira/Jira.test.tsx"}}
{"input": "import { forwardRef, ReactElement, ReactNode, useState } from 'react';\nimport classnames from 'classnames';\nimport Box from './Box';\nimport focusStyles from './Focus.css';\nimport formElement from './sharedSubcomponents/FormElement.css';\nimport FormErrorMessage from './sharedSubcomponents/FormErrorMessage';\nimport FormHelperText from './sharedSubcomponents/FormHelperText';\nimport FormLabel from './sharedSubcomponents/FormLabel';\nimport TagArea from './TagArea/TagArea';\nimport styles from './TextArea.css';\nimport VRTextArea from './TextArea/VRTextArea';\nimport useExperimentalTheme from './utils/useExperimentalTheme';\n\nconst ROW_HEIGHT = 24;\nconst INPUT_PADDING_WITH_TAGS = 20;\n\ntype Props = {\n  /**\n   * Indicate if the input is currently disabled. See the [disabled example](https://gestalt.pinterest.systems/web/textarea#Disabled) for more details.\n   */\n  disabled?: boolean;\n  /**\n   * Available for testing purposes, if needed. Consider [better queries](https://testing-library.com/docs/queries/about/#priority) before using this prop.\n   */\n  dataTestId?: string;\n  /**\n   * For most use cases, pass a string with a helpful error message (be sure to localize!). In certain instances it can be useful to make some text clickable; to support this, you may instead pass a React.Node to wrap text in Link or TapArea. See the [error message example](https://gestalt.pinterest.systems/web/textarea#Error-message) for more details.\n   */\n  errorMessage?: ReactNode;\n  /**\n   * This field is deprecated and will be removed soon. Please do not use.\n   */\n  hasError?: boolean;\n  /**\n   * More information about how to complete the form field. See the [helper text example](https://gestalt.pinterest.systems/web/textarea#Helper-text) for more details.\n   */\n  helperText?: string;\n  /**\n   * A unique identifier for the input.\n   */\n  id: string;\n  /**\n   * The label for the input. Be sure to localize the text.\n   */\n  label?: string;\n  /**\n   * Whether the label should be visible or not. If `hidden`, the label is still available for screen reader users, but does not appear visually. See the [label visibility variant](https://gestalt.pinterest.systems/web/textarea#Label-visibility) for more info.\n   */\n  labelDisplay?: 'visible' | 'hidden';\n  /**\n   * The maximum number of characters allowed in TextArea. `maxLength` must be an integer value 0 or higher. See the [maximum length variant](https://gestalt.pinterest.systems/web/textarea#Maximum-length) for more details.\n   */\n  maxLength?: {\n    characterCount: number;\n    errorAccessibilityLabel: string;\n  };\n  /**\n   * A unique name for the input.\n   */\n  name?: string;\n  /**\n   * Callback triggered when the user blurs the input.!\n   */\n  onBlur?: (arg1: { event: React.FocusEvent<HTMLTextAreaElement>; value: string }) => void;\n  /**\n   * Callback triggered when the value of the input changes.\n   */\n  onChange: (arg1: { event: React.ChangeEvent<HTMLTextAreaElement>; value: string }) => void;\n  /**\n   * Callback triggered when the user focuses the input.\n   */\n  onFocus?: (arg1: { event: React.FocusEvent<HTMLTextAreaElement>; value: string }) => void;\n  /**\n   * Callback triggered when the user presses any key while the input is focused.\n   */\n  onKeyDown?: (arg1: { event: React.KeyboardEvent<HTMLTextAreaElement>; value: string }) => void;\n  /**\n   * Placeholder text shown the the user has not yet input a value.\n   */\n  placeholder?: string;\n  /**\n   * Indicate if the input is currently readOnly. See the [readOnly example](https://gestalt.pinterest.systems/web/textarea#Read-only) for more details.\n   */\n  readOnly?: boolean;\n  /**\n   * Ref that is forwarded to the underlying input element. See the [ref example](https://gestalt.pinterest.systems/web/textarea#With-a-ref) for more details.\n   */\n  ref?: ReactElement; // eslint-disable-line react/no-unused-prop-types,\n  /**\n   * Number of text rows to display. Note that tags take up more space, and will show fewer rows than specified.\n   */\n  rows?: number;\n  /**\n   * List of tags to display in the component. See the [tags example](https://gestalt.pinterest.systems/web/textarea#With-tags) for more details.\n   */\n  tags?: ReadonlyArray<ReactElement>;\n  /**\n   * The current value of the input.\n   */\n  value?: string;\n};\n\n/**\n * [TextArea](https://gestalt.pinterest.systems/web/textarea) allows for multi-line input.\n *\n * ![TextArea light mode](https://raw.githubusercontent.com/pinterest/gestalt/master/playwright/visual-test/TextArea.spec.ts-snapshots/TextArea-chromium-darwin.png)\n * ![TextArea dark mode](https://raw.githubusercontent.com/pinterest/gestalt/master/playwright/visual-test/TextArea-dark.spec.ts-snapshots/TextArea-dark-chromium-darwin.png)\n *\n */\n\nconst TextAreaWithForwardRef = forwardRef<HTMLTextAreaElement, Props>(function TextArea(\n  {\n    dataTestId,\n    disabled = false,\n    errorMessage,\n    hasError = false,\n    helperText,\n    id,\n    label,\n    labelDisplay = 'visible',\n    maxLength,\n    name,\n    onBlur,\n    onChange,\n    onFocus,\n    onKeyDown,\n    placeholder,\n    readOnly = false,\n    rows,\n    tags,\n    value,\n  }: Props,\n  ref,\n) {\n  const [focused, setFocused] = useState(false);\n  const [currentLength, setCurrentLength] = useState(value?.length ?? 0);\n\n  const theme = useExperimentalTheme();\n\n  const defaultRows = theme.MAIN ? 2 : 3;\n\n  const overridenRows = rows ?? defaultRows;\n\n  const handleChange = (event: React.ChangeEvent<HTMLTextAreaElement>) => {\n    setCurrentLength(event.currentTarget.value?.length ?? 0);\n    onChange({ event, value: event.currentTarget.value });\n  };\n\n  const handleBlur = (event: React.FocusEvent<HTMLTextAreaElement>) => {\n    setFocused(false);\n    if (onBlur) {\n      onBlur({ event, value: event.currentTarget.value });\n    }\n  };\n\n  const handleFocus = (event: React.FocusEvent<HTMLTextAreaElement>) => {\n    setFocused(true);\n    if (onFocus) {\n      onFocus({ event, value: event.currentTarget.value });\n    }\n  };\n\n  const handleKeyDown = (event: React.KeyboardEvent<HTMLTextAreaElement>) => {\n    if (onKeyDown) {\n      onKeyDown({ event, value: event.currentTarget.value });\n    }\n  };\n\n  const hasErrorMessage = Boolean(errorMessage);\n\n  const classes = classnames(\n    styles.textArea,\n    formElement.base,\n    formElement.lg,\n    disabled ? formElement.disabled : formElement.enabled,\n    (hasError || hasErrorMessage) && !focused ? formElement.errored : formElement.normal,\n    tags\n      ? {\n          [focusStyles.accessibilityOutlineFocus]: focused,\n          [styles.textAreaWrapper]: true,\n        }\n      : {},\n  );\n\n  if (maxLength && maxLength.characterCount < 0) {\n    throw new Error('`maxLength` must be an integer value 0 or higher.');\n  }\n\n  let ariaDescribedby;\n\n  if (hasErrorMessage) {\n    ariaDescribedby = `${id}-error`;\n  }\n\n  if (helperText || maxLength) {\n    ariaDescribedby = `${id}-helperText`;\n  }\n\n  const inputElement = (\n    <textarea\n      // checking for \"focused\" is not required by screenreaders but it prevents a11y integration tests to complain about missing label, as aria-describedby seems to shadow label in tests though it's a W3 accepeted pattern https://www.w3.org/TR/WCAG20-TECHS/ARIA1.html\n      ref={ref}\n      aria-describedby={focused ? ariaDescribedby : undefined}\n      aria-invalid={hasErrorMessage || hasError ? 'true' : 'false'}\n      className={tags ? styles.unstyledTextArea : classes}\n      data-test-id={dataTestId}\n      disabled={disabled}\n      id={id}\n      maxLength={maxLength?.characterCount}\n      name={name}\n      onBlur={handleBlur}\n      onChange={handleChange}\n      onFocus={handleFocus}\n      onKeyDown={handleKeyDown}\n      placeholder={placeholder}\n      readOnly={readOnly}\n      rows={tags ? undefined : overridenRows}\n      value={value}\n    />\n  );\n\n  const tagsWrapperStyle = {\n    minHeight: overridenRows * ROW_HEIGHT + INPUT_PADDING_WITH_TAGS,\n    maxHeight: overridenRows * ROW_HEIGHT + INPUT_PADDING_WITH_TAGS,\n  } as const;\n\n  if (theme.MAIN && !tags)\n    return (\n      <VRTextArea\n        ref={ref}\n        dataTestId={dataTestId}\n        disabled={disabled}\n        errorMessage={errorMessage}\n        hasError={hasError}\n        helperText={helperText}\n        id={id}\n        label={label}\n        labelDisplay={labelDisplay}\n        maxLength={maxLength}\n        name={name}\n        onBlur={onBlur}\n        onChange={onChange}\n        onFocus={onFocus}\n        onKeyDown={onKeyDown}\n        placeholder={placeholder}\n        readOnly={readOnly}\n        rows={overridenRows}\n        value={value}\n      />\n    );\n\n  if (theme.MAIN && tags)\n    return (\n      <TagArea\n        ref={ref}\n        dataTestId={dataTestId}\n        disabled={disabled}\n        errorMessage={errorMessage}\n        hasError={hasError}\n        helperText={helperText}\n        id={id}\n        label={label}\n        labelDisplay={labelDisplay}\n        maxLength={maxLength}\n        name={name}\n        // @ts-expect-error - TS2322\n        onBlur={onBlur}\n        // @ts-expect-error - TS2322\n        onChange={onChange}\n        // @ts-expect-error - TS2322\n        onFocus={onFocus}\n        // @ts-expect-error - TS2322\n        onKeyDown={onKeyDown}\n        placeholder={placeholder}\n        readOnly={readOnly}\n        rows={overridenRows}\n        size=\"md\"\n        tags={tags}\n        value={value}\n      />\n    );\n\n  return (\n    <span>\n      {label && <FormLabel id={id} label={label} labelDisplay={labelDisplay} size=\"lg\" />}\n      {tags ? (\n        <div className={classes} style={tagsWrapperStyle}>\n          {tags.map((tag, tagIndex) => (\n            // eslint-disable-next-line react/no-array-index-key\n            <Box key={tagIndex} marginBottom={1} marginEnd={1}>\n              {tag}\n            </Box>\n          ))}\n          <Box flex=\"grow\" maxWidth=\"100%\" overflow=\"hidden\" position=\"relative\">\n            {/* This is an invisible spacer div which mirrors the input's\n             * content. We use it to implement the flex wrapping behavior\n             * which is not supported by inputs, by having the actual input\n             * track it with absolute positioning. */}\n            <div aria-hidden className={styles.textAreaSpacer}>\n              {/* Keep a non-empty value so that the div doesn't collapse */}\n              {value || '-'}\n            </div>\n            {inputElement}\n          </Box>\n        </div>\n      ) : (\n        inputElement\n      )}\n      {(helperText || maxLength) && !errorMessage ? (\n        <FormHelperText\n          currentLength={currentLength}\n          id={`${id}-helperText`}\n          maxLength={maxLength}\n          text={helperText}\n        />\n      ) : null}\n      {hasErrorMessage && <FormErrorMessage id={`${id}-error`} text={errorMessage} />}\n    </span>\n  );\n});\n\nTextAreaWithForwardRef.displayName = 'TextArea';\n\nexport default TextAreaWithForwardRef;", "output": "import { create } from 'react-test-renderer';\nimport Tag from './Tag';\nimport TextArea from './TextArea';\n\ndescribe('TextArea', () => {\n  it('Renders an FormErrorMessage if an error message is passed in', () => {\n    const component = create(\n      <TextArea errorMessage=\"Error message\" id=\"test\" onChange={jest.fn()} />,\n    );\n    expect(JSON.stringify(component.toJSON())).toContain('Error message');\n  });\n\n  it('Does not render an FormErrorMessage when errorMessage is null', () => {\n    const component = create(<TextArea id=\"test\" onChange={jest.fn()} />);\n    expect(JSON.stringify(component.toJSON())).not.toContain('Error message');\n  });\n\n  it('TextArea normal', () => {\n    const tree = create(\n      <TextArea id=\"test\" onBlur={jest.fn()} onChange={jest.fn()} onFocus={jest.fn()} />,\n    ).toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('TextArea with error', () => {\n    const tree = create(\n      <TextArea\n        errorMessage=\"error message\"\n        id=\"test\"\n        onBlur={jest.fn()}\n        onChange={jest.fn()}\n        onFocus={jest.fn()}\n      />,\n    ).toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('TextArea with hasError', () => {\n    const tree = create(\n      <TextArea hasError id=\"test\" onBlur={jest.fn()} onChange={jest.fn()} onFocus={jest.fn()} />,\n    ).toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('TextField with maxLength character counter', () => {\n    const tree = create(\n      <TextArea\n        id=\"test\"\n        maxLength={{\n          characterCount: 20,\n          errorAccessibilityLabel: 'Exceeded',\n        }}\n        name=\"maxLength\"\n        onBlur={jest.fn()}\n        onChange={jest.fn()}\n        onFocus={jest.fn()}\n      />,\n    ).toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('TextArea with readOnly', () => {\n    const tree = create(\n      <TextArea id=\"test\" onBlur={jest.fn()} onChange={jest.fn()} onFocus={jest.fn()} readOnly />,\n    ).toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('TextArea with disabled', () => {\n    const tree = create(\n      <TextArea disabled id=\"test\" onBlur={jest.fn()} onChange={jest.fn()} onFocus={jest.fn()} />,\n    ).toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('TextArea with rows', () => {\n    const tree = create(<TextArea id=\"test\" onChange={jest.fn()} rows={5} />).toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n\n  it('renders tags when supplied', () => {\n    const tree = create(\n      <TextArea\n        id=\"test\"\n        onChange={jest.fn()}\n        tags={[\n          <Tag\n            key=\"a\"\n            accessibilityRemoveIconLabel=\"Remove email tag\"\n            onRemove={() => {}}\n            text=\"a@pinterest.com\"\n          />,\n          <Tag\n            key=\"b\"\n            accessibilityRemoveIconLabel=\"Remove email tag\"\n            onRemove={() => {}}\n            text=\"b@pinterest.com\"\n          />,\n          <Tag\n            key=\"c\"\n            accessibilityRemoveIconLabel=\"Remove email tag\"\n            onRemove={() => {}}\n            text=\"c@pinterest.com\"\n          />,\n        ]}\n      />,\n    ).toJSON();\n    expect(tree).toMatchSnapshot();\n  });\n});", "meta": {"repo": "pinterest/gestalt", "stars": 4310, "component": "packages/gestalt/src/TextArea.tsx", "test": "packages/gestalt/src/TextArea.test.tsx"}}
{"input": "import { Component, h, Host, Listen, State } from '@stencil/core';\n\n@Component({\n  tag: 'listen-reattach',\n  styles: ':host { display: block; background: gray;}',\n  scoped: true,\n})\nexport class ListenReattach {\n  @State() clicked = 0;\n\n  @Listen('click')\n  click() {\n    this.clicked++;\n  }\n\n  render() {\n    return (\n      <Host>\n        <div id=\"clicked\">Clicked: {this.clicked}</div>\n      </Host>\n    );\n  }\n}", "output": "import { Fragment, h } from '@stencil/core';\nimport { render } from '@wdio/browser-runner/stencil';\n\ndescribe('listen-reattach', () => {\n  beforeEach(async () => {\n    render({\n      template: () => (\n        <>\n          <div class=\"box\">\n            <listen-reattach></listen-reattach>\n            <div class=\"other\">Some other content</div>\n          </div>\n          <button id=\"moveIt\">Move it!!</button>\n        </>\n      ),\n    });\n    const box = document.querySelector('.box');\n    const moveable = document.querySelector('listen-reattach');\n    const button = document.querySelector('#moveIt');\n    button.addEventListener('click', function () {\n      box.appendChild(moveable);\n    });\n  });\n\n  it('should receive click events, remove/attach, and receive more events', async () => {\n    await expect($('#clicked')).toHaveText('Clicked: 0');\n\n    for (let clicks = 1; clicks <= 2; clicks++) {\n      await $('listen-reattach').click();\n      await expect($('#clicked')).toHaveText('Clicked: ' + clicks);\n    }\n\n    await $('#moveIt').click();\n\n    for (let clicks = 3; clicks <= 4; clicks++) {\n      await $('listen-reattach').click();\n      await expect($('#clicked')).toHaveText('Clicked: ' + clicks);\n    }\n  });\n});", "meta": {"repo": "stenciljs/core", "stars": 12807, "component": "test/wdio/listen-reattach/cmp-a.tsx", "test": "test/wdio/listen-reattach/cmp-a.test.tsx"}}
{"input": "import { isEmpty, keyBy } from 'lodash';\nimport { useEffect, useMemo } from 'react';\nimport { useRunDetailsPageDataLegacy } from '../useRunDetailsPageDataLegacy';\nimport {\n  type UseGetRunQueryResponseExperiment,\n  useGetRunQuery,\n  UseGetRunQueryDataApiError,\n  UseGetRunQueryResponseDataMetrics,\n  UseGetRunQueryResponseDatasetInputs,\n  type UseGetRunQueryResponseInputs,\n  type UseGetRunQueryResponseOutputs,\n  UseGetRunQueryResponseRunInfo,\n} from './useGetRunQuery';\nimport {\n  KeyValueEntity,\n  RunDatasetWithTags,\n  type ExperimentEntity,\n  type MetricEntitiesByName,\n  type MetricEntity,\n  type RunInfoEntity,\n} from '../../../types';\nimport {\n  shouldEnableGraphQLModelVersionsForRunDetails,\n  shouldEnableGraphQLRunDetailsPage,\n} from '../../../../common/utils/FeatureUtils';\nimport { ThunkDispatch } from '../../../../redux-types';\nimport { useDispatch } from 'react-redux';\nimport { searchModelVersionsApi } from '../../../../model-registry/actions';\nimport { ApolloError } from '@mlflow/mlflow/src/common/utils/graphQLHooks';\nimport { ErrorWrapper } from '../../../../common/utils/ErrorWrapper';\nimport { pickBy } from 'lodash';\nimport {\n  type RunPageModelVersionSummary,\n  useUnifiedRegisteredModelVersionsSummariesForRun,\n} from './useUnifiedRegisteredModelVersionsSummariesForRun';\n\n// Internal util: transforms an array of objects into a keyed object by the `key` field\nconst transformToKeyedObject = <Output, Input = any>(inputArray: Input[]) =>\n  // TODO: fix this type error\n  // @ts-expect-error: Conversion of type 'Dictionary<Input>' to type 'Record<string, Output>' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.\n  keyBy(inputArray, 'key') as Record<string, Output>;\n\n// Internal util: transforms an array of metric values into an array of MetricEntity objects\n// GraphQL uses strings for steps and timestamp so we cast them to numbers\nconst transformMetricValues = (inputArray: UseGetRunQueryResponseDataMetrics): MetricEntity[] =>\n  inputArray\n    .filter(({ key, value, step, timestamp }) => key !== null && value !== null && step !== null && timestamp !== null)\n    .map(({ key, value, step, timestamp }: any) => ({\n      key,\n      value,\n      step: Number(step),\n      timestamp: Number(timestamp),\n    }));\n\n// Internal util: transforms an array of dataset inputs into an array of RunDatasetWithTags objects\nexport const transformDatasets = (inputArray?: UseGetRunQueryResponseDatasetInputs): RunDatasetWithTags[] | undefined =>\n  inputArray?.map((datasetInput) => ({\n    dataset: {\n      digest: datasetInput.dataset?.digest ?? '',\n      name: datasetInput.dataset?.name ?? '',\n      profile: datasetInput.dataset?.profile ?? '',\n      schema: datasetInput.dataset?.schema ?? '',\n      source: datasetInput.dataset?.source ?? '',\n      sourceType: datasetInput.dataset?.sourceType ?? '',\n    },\n    tags:\n      datasetInput.tags\n        ?.map((tag) => ({\n          key: tag.key ?? '',\n          value: tag.value ?? '',\n        }))\n        .filter((tag) => !isEmpty(tag.key)) ?? [],\n  }));\n\ninterface UseRunDetailsPageDataResult {\n  experiment?: ExperimentEntity | UseGetRunQueryResponseExperiment;\n  error: Error | ErrorWrapper | undefined | ApolloError;\n\n  latestMetrics: MetricEntitiesByName;\n  loading: boolean;\n  params: Record<string, KeyValueEntity>;\n  refetchRun: any;\n  runInfo?: RunInfoEntity | UseGetRunQueryResponseRunInfo;\n  tags: Record<string, KeyValueEntity>;\n  datasets?: RunDatasetWithTags[];\n  runInputs?: UseGetRunQueryResponseInputs;\n  runOutputs?: UseGetRunQueryResponseOutputs;\n\n  // Only present in legacy implementation\n  runFetchError?: Error | ErrorWrapper | undefined;\n  experimentFetchError?: Error | ErrorWrapper | undefined;\n\n  registeredModelVersionSummaries: RunPageModelVersionSummary[];\n\n  // Only present in graphQL implementation\n  apiError?: UseGetRunQueryDataApiError;\n}\n\n/**\n * An updated version of the `useRunDetailsPageData` hook that either uses the REST API-based implementation\n * or the GraphQL-based implementation to fetch run details, based on the `shouldEnableGraphQLRunDetailsPage` flag.\n */\nexport const useRunDetailsPageData = ({\n  runUuid,\n  experimentId,\n}: {\n  runUuid: string;\n  experimentId: string;\n}): UseRunDetailsPageDataResult => {\n  const usingGraphQL = shouldEnableGraphQLRunDetailsPage();\n  const dispatch = useDispatch<ThunkDispatch>();\n\n  // If GraphQL flag is enabled, use the graphQL query to fetch the run data.\n  // We can safely disable the eslint rule since feature flag evaluation is stable\n  /* eslint-disable react-hooks/rules-of-hooks */\n  if (usingGraphQL) {\n    const graphQLQuery = () =>\n      useGetRunQuery({\n        runUuid,\n      });\n\n    const detailsPageGraphqlResponse = graphQLQuery();\n\n    // If model versions are colocated in the GraphQL response, we don't need to make an additional API call\n    useEffect(() => {\n      if (shouldEnableGraphQLModelVersionsForRunDetails()) {\n        return;\n      }\n      dispatch(searchModelVersionsApi({ run_id: runUuid }));\n    }, [dispatch, runUuid]);\n\n    const { latestMetrics, tags, params, datasets } = useMemo(() => {\n      // Filter out tags, metrics, and params that are entirely whitespace\n      return {\n        latestMetrics: pickBy(\n          transformToKeyedObject<MetricEntity>(\n            transformMetricValues(detailsPageGraphqlResponse.data?.data?.metrics ?? []),\n          ),\n          (metric) => metric.key.trim().length > 0,\n        ),\n        tags: pickBy(\n          transformToKeyedObject<KeyValueEntity>(detailsPageGraphqlResponse.data?.data?.tags ?? []),\n          (tag) => tag.key.trim().length > 0,\n        ),\n        params: pickBy(\n          transformToKeyedObject<KeyValueEntity>(detailsPageGraphqlResponse.data?.data?.params ?? []),\n          (param) => param.key.trim().length > 0,\n        ),\n        datasets: transformDatasets(detailsPageGraphqlResponse.data?.inputs?.datasetInputs),\n      };\n    }, [detailsPageGraphqlResponse.data]);\n\n    const registeredModelVersionSummaries = useUnifiedRegisteredModelVersionsSummariesForRun({\n      runUuid,\n      queryResult: detailsPageGraphqlResponse,\n    });\n\n    return {\n      runInfo: detailsPageGraphqlResponse.data?.info ?? undefined,\n      experiment: detailsPageGraphqlResponse.data?.experiment ?? undefined,\n      loading: detailsPageGraphqlResponse.loading,\n      error: detailsPageGraphqlResponse.apolloError,\n      apiError: detailsPageGraphqlResponse.apiError,\n      refetchRun: detailsPageGraphqlResponse.refetchRun,\n      runInputs: detailsPageGraphqlResponse.data?.inputs,\n      runOutputs: detailsPageGraphqlResponse.data?.outputs,\n      registeredModelVersionSummaries,\n      datasets,\n      latestMetrics,\n      tags,\n      params,\n    };\n  }\n\n  // If GraphQL flag is disabled, use the legacy implementation to fetch the run data.\n  const detailsPageResponse = useRunDetailsPageDataLegacy(runUuid, experimentId);\n  const error = detailsPageResponse.errors.runFetchError || detailsPageResponse.errors.experimentFetchError;\n\n  const registeredModelVersionSummaries = useUnifiedRegisteredModelVersionsSummariesForRun({\n    runUuid,\n  });\n\n  return {\n    runInfo: detailsPageResponse.data?.runInfo,\n    latestMetrics: detailsPageResponse.data?.latestMetrics,\n    tags: detailsPageResponse.data?.tags,\n    experiment: detailsPageResponse.data?.experiment,\n    params: detailsPageResponse.data?.params,\n    datasets: detailsPageResponse.data?.datasets,\n    loading: detailsPageResponse.loading,\n    error,\n    runFetchError: detailsPageResponse.errors.runFetchError,\n    experimentFetchError: detailsPageResponse.errors.experimentFetchError,\n    refetchRun: detailsPageResponse.refetchRun,\n    registeredModelVersionSummaries,\n  };\n};", "output": "import { renderHook } from '@testing-library/react';\nimport { useRunDetailsPageData } from './useRunDetailsPageData';\nimport { MockedReduxStoreProvider } from '../../../../common/utils/TestUtils';\n\nimport { merge } from 'lodash';\nimport { ReduxState } from '../../../../redux-types';\nimport { DeepPartial } from 'redux';\n\nconst mockAction = (id: string) => ({ type: 'action', payload: Promise.resolve(), meta: { id } });\n\njest.mock('../../../actions', () => ({\n  getExperimentApi: jest.fn(() => mockAction('experiment_request')),\n  getRunApi: jest.fn(() => mockAction('run_request')),\n}));\n\njest.mock('../../../../model-registry/actions', () => ({\n  searchModelVersionsApi: jest.fn(() => mockAction('models_request')),\n}));\n\njest.mock('@mlflow/mlflow/src/common/utils/FeatureUtils', () => ({\n  ...jest.requireActual<typeof import('@mlflow/mlflow/src/common/utils/FeatureUtils')>(\n    '@mlflow/mlflow/src/common/utils/FeatureUtils',\n  ),\n  shouldEnableGraphQLRunDetailsPage: () => false,\n}));\n\nconst testRunUuid = 'test-run-uuid';\nconst testExperimentId = '12345';\n\ndescribe('useRunDetailsPageData', () => {\n  const mountHook = (entities: DeepPartial<ReduxState['entities']> = {}, apis: DeepPartial<ReduxState['apis']> = {}) =>\n    renderHook(() => useRunDetailsPageData({ runUuid: testRunUuid, experimentId: testExperimentId }), {\n      wrapper: ({ children }: { children: React.ReactNode }) => (\n        <MockedReduxStoreProvider\n          state={{\n            entities: merge(\n              {\n                runInfosByUuid: {},\n                experimentsById: {},\n                tagsByRunUuid: {\n                  [testRunUuid]: [\n                    { key: 'testtag1', value: '' },\n                    { key: '\\t', value: 'value1' },\n                  ],\n                },\n                latestMetricsByRunUuid: {\n                  [testRunUuid]: [\n                    { key: 'met1', value: 2, timestamp: 1000, step: 0 },\n                    { key: '', value: 0, timestamp: 1000, step: 0 },\n                  ],\n                },\n                modelVersionsByRunUuid: {},\n                paramsByRunUuid: {\n                  [testRunUuid]: [\n                    { key: 'p1', value: '' },\n                    { key: '\\n', value: '0' },\n                  ],\n                },\n                runDatasetsByUuid: {\n                  [testRunUuid]: [\n                    {\n                      dataset: {\n                        digest: 'digest',\n                        name: 'name',\n                        profile: 'profile',\n                        schema: 'schema',\n                        source: 'source',\n                        sourceType: 'sourceType',\n                      },\n                      tags: [{ key: 'tag1', value: 'value1' }],\n                    },\n                  ],\n                },\n              },\n              entities,\n            ),\n            apis,\n          }}\n        >\n          {children}\n        </MockedReduxStoreProvider>\n      ),\n    });\n\n  test('Fetches metrics, params, and tags with non-empty key and empty value, but not those with empty key', () => {\n    const { result } = mountHook();\n    const { tags, params, latestMetrics, datasets } = result.current;\n\n    expect(tags).toEqual({ '0': { key: 'testtag1', value: '' } });\n    expect(params).toEqual({ '0': { key: 'p1', value: '' } });\n    expect(latestMetrics).toEqual({ '0': { key: 'met1', value: 2, timestamp: 1000, step: 0 } });\n    expect(datasets).toEqual([\n      {\n        dataset: {\n          digest: 'digest',\n          name: 'name',\n          profile: 'profile',\n          schema: 'schema',\n          source: 'source',\n          sourceType: 'sourceType',\n        },\n        tags: [{ key: 'tag1', value: 'value1' }],\n      },\n    ]);\n  });\n});", "meta": {"repo": "mlflow/mlflow", "stars": 21020, "component": "mlflow/server/js/src/experiment-tracking/components/run-page/hooks/useRunDetailsPageData.tsx", "test": "mlflow/server/js/src/experiment-tracking/components/run-page/hooks/useRunDetailsPageData.test.tsx"}}
{"input": "import React from \"react\";\nimport type { clutch as IClutch } from \"@clutch-sh/api\";\nimport {\n  Accordion,\n  AccordionDetails,\n  Button,\n  ButtonGroup,\n  client,\n  Confirmation,\n  MetadataTable,\n  NoteConfig,\n  NotePanel,\n  Resolver,\n  Typography,\n  useWizardContext,\n} from \"@clutch-sh/core\";\nimport { useDataLayout } from \"@clutch-sh/data-layout\";\nimport { Wizard, WizardStep } from \"@clutch-sh/wizard\";\nimport _ from \"lodash\";\nimport { number, ref } from \"yup\";\nimport type Reference from \"yup/lib/Reference\";\n\nimport type { ConfirmChild, ResolverChild, WorkflowProps } from \".\";\n\nconst WARNING_THRESHOLD = 0.5;\n\nconst HPAIdentifier: React.FC<ResolverChild> = ({ resolverType }) => {\n  const { onSubmit } = useWizardContext();\n  const hpaData = useDataLayout(\"hpaData\");\n  const inputData = useDataLayout(\"inputData\");\n\n  const onResolve = ({ results, input }) => {\n    // Decide how to process results.\n    hpaData.assign(results[0]);\n    inputData.assign(input);\n    onSubmit();\n  };\n\n  return <Resolver type={resolverType} searchLimit={1} onResolve={onResolve} />;\n};\n\n// The same notes will be displayed at both the final and next-to-last steps.\nconst HPADetails: React.FC<ConfirmChild> = ({ notes }) => {\n  const { onSubmit, onBack } = useWizardContext();\n  const hpaData = useDataLayout(\"hpaData\");\n  const hpa = hpaData.displayValue() as IClutch.k8s.v1.HPA;\n  const update = (key: string, value: any) => {\n    hpaData.updateData(key, value);\n  };\n\n  const currentHpaData = useDataLayout(\"currentHpaData\");\n\n  const metadataAnnotations = [];\n  const metadataLabels = [];\n\n  const [warnings, setWarnings] = React.useState<{\n    minSize: NoteConfig;\n    maxSize: NoteConfig;\n  }>({ minSize: undefined, maxSize: undefined });\n  const getWarning = React.useCallback(\n    (current: number, newValue: number): boolean =>\n      current * (1 / WARNING_THRESHOLD) < newValue || current / (1 / WARNING_THRESHOLD) > newValue,\n    []\n  );\n\n  React.useEffect(() => {\n    if (hpa.annotations) {\n      _.forEach(hpa.annotations, (annotation, key) => {\n        metadataAnnotations.push({ name: key, value: annotation });\n      });\n    }\n\n    if (hpa.labels) {\n      _.forEach(hpa.labels, (label, key) => {\n        metadataLabels.push({ name: key, value: label });\n      });\n    }\n\n    // save the original values of min and max replicas\n    if (hpa) {\n      currentHpaData.assign(hpa);\n    }\n  }, []);\n\n  React.useEffect(() => {\n    if ((currentHpaData.displayValue() as IClutch.k8s.v1.HPA).sizing) {\n      const {\n        minReplicas,\n        maxReplicas,\n      } = (currentHpaData.displayValue() as IClutch.k8s.v1.HPA).sizing;\n      setWarnings({\n        minSize: getWarning(minReplicas, hpa.sizing.minReplicas)\n          ? {\n              severity: \"warning\",\n              text: `New Min Size is more than ${WARNING_THRESHOLD * 100}% different`,\n            }\n          : undefined,\n        maxSize: getWarning(maxReplicas, hpa.sizing.maxReplicas)\n          ? {\n              severity: \"warning\",\n              text: `New Max Size is more than ${WARNING_THRESHOLD * 100}% different`,\n            }\n          : undefined,\n      });\n    }\n  }, [hpa.sizing.minReplicas, hpa.sizing.maxReplicas]);\n\n  return (\n    <WizardStep error={hpaData.error} isLoading={hpaData.isLoading}>\n      <strong>HPA Details</strong>\n      <MetadataTable\n        onUpdate={update}\n        data={[\n          { name: \"Name\", value: hpa.name },\n          { name: \"Namespace\", value: hpa.namespace },\n          { name: \"Current Replicas\", value: hpa.sizing.currentReplicas },\n          { name: \"Desired Replicas\", value: hpa.sizing.desiredReplicas },\n          {\n            name: \"Min Size\",\n            value: hpa.sizing.minReplicas,\n            textFieldLabels: {\n              disabledField: \"Current min\",\n              updatedField: \"New min\",\n            },\n            input: {\n              type: \"number\",\n              key: \"sizing.minReplicas\",\n              validation:\n                hpa.sizing.minReplicas > 0\n                  ? number().integer().moreThan(0)\n                  : number().integer().min(0),\n              warning: warnings.minSize,\n            },\n          },\n          {\n            name: \"Max Size\",\n            value: hpa.sizing.maxReplicas,\n            textFieldLabels: {\n              disabledField: \"Current max\",\n              updatedField: \"New max\",\n            },\n            input: {\n              type: \"number\",\n              key: \"sizing.maxReplicas\",\n              validation:\n                hpa.sizing.minReplicas > 0\n                  ? number()\n                      .integer()\n                      .min(ref(\"Min Size\") as Reference<number>)\n                  : number().integer().moreThan(0),\n              warning: warnings.maxSize,\n            },\n          },\n          { name: \"Cluster\", value: hpa.cluster },\n        ]}\n      />\n      {metadataAnnotations.length > 0 && (\n        <Accordion title=\"Annotations\">\n          <AccordionDetails>\n            <MetadataTable data={metadataAnnotations} />\n          </AccordionDetails>\n        </Accordion>\n      )}\n      {metadataLabels.length > 0 && (\n        <Accordion title=\"Labels\">\n          <AccordionDetails>\n            <MetadataTable data={metadataLabels} />\n          </AccordionDetails>\n        </Accordion>\n      )}\n      <ButtonGroup>\n        <Button text=\"Back\" variant=\"neutral\" onClick={() => onBack()} />\n        <Button text=\"Execute\" variant=\"destructive\" onClick={onSubmit} />\n      </ButtonGroup>\n      <NotePanel notes={notes} />\n    </WizardStep>\n  );\n};\n\nconst Confirm: React.FC<ConfirmChild> = ({ notes }) => {\n  const hpa = useDataLayout(\"hpaData\").displayValue() as IClutch.k8s.v1.HPA;\n  const resizeData = useDataLayout(\"resizeData\");\n  const currentHpaData = useDataLayout(\"currentHpaData\").displayValue() as IClutch.k8s.v1.HPA;\n\n  React.useEffect(() => {\n    // if new values are either 50% bigger or smaller than old values, add a warning note\n    const { maxReplicas, minReplicas } = currentHpaData.sizing;\n    const maxUpperBound = (1 + WARNING_THRESHOLD) * maxReplicas;\n    const maxLowerBound = (1 - WARNING_THRESHOLD) * maxReplicas;\n    const minUpperBound = (1 + WARNING_THRESHOLD) * minReplicas;\n    const minLowerBound = (1 - WARNING_THRESHOLD) * minReplicas;\n\n    const isMinReplicasDiffTooBig =\n      hpa.sizing.minReplicas > minUpperBound || hpa.sizing.minReplicas < minLowerBound;\n    const isMaxReplicasDiffTooBig =\n      hpa.sizing.maxReplicas > maxUpperBound || hpa.sizing.maxReplicas < maxLowerBound;\n    if (isMaxReplicasDiffTooBig || isMinReplicasDiffTooBig) {\n      notes.unshift({\n        text:\n          \"The new min or max size is more than 50% different from the old size. This may cause a large number of pods to be created or deleted.\",\n        severity: \"warning\",\n      });\n    }\n  }, []);\n\n  return (\n    <WizardStep error={resizeData.error} isLoading={resizeData.isLoading}>\n      <Confirmation action=\"Resize\" />\n      <MetadataTable\n        data={[\n          { name: \"Name\", value: hpa.name },\n          { name: \"Namespace\", value: hpa.namespace },\n          { name: \"Cluster\", value: hpa.cluster },\n          { name: \"Old Min Size\", value: currentHpaData.sizing.minReplicas },\n          { name: \"Old Max Size\", value: currentHpaData.sizing.maxReplicas },\n          { name: \"New Min Size\", value: hpa.sizing.minReplicas },\n          { name: \"New Max Size\", value: hpa.sizing.maxReplicas },\n        ]}\n      />\n      <NotePanel notes={notes} />\n    </WizardStep>\n  );\n};\n\nconst ConfirmResizeHPA = () => {\n  const hpaData = useDataLayout(\"hpaData\").value;\n\n  return (\n    <Typography variant=\"body1\">{`You are about to resize HPA ${hpaData.name}, are you sure to proceed?`}</Typography>\n  );\n};\n\nconst ResizeHPA: React.FC<WorkflowProps> = ({ heading, resolverType, notes = [] }) => {\n  const dataLayout = {\n    hpaData: {},\n    inputData: {},\n    currentHpaData: {},\n    resizeData: {\n      deps: [\"hpaData\", \"inputData\", \"currentHpaData\"],\n      hydrator: (\n        hpaData: IClutch.k8s.v1.HPA,\n        inputData: { clientset: string },\n        currentHpaData: IClutch.k8s.v1.HPA\n      ) => {\n        const clientset = inputData.clientset ?? \"unspecified\";\n\n        return client.post(\"/v1/k8s/resizeHPA\", {\n          clientset,\n          cluster: hpaData.cluster,\n          namespace: hpaData.namespace,\n          name: hpaData.name,\n          sizing: {\n            min: hpaData.sizing.minReplicas,\n            max: hpaData.sizing.maxReplicas,\n          },\n          currentSizing: {\n            min: currentHpaData.sizing.minReplicas,\n            max: currentHpaData.sizing.maxReplicas,\n          },\n        } as IClutch.k8s.v1.IResizeHPARequest);\n      },\n    },\n  };\n\n  return (\n    <Wizard dataLayout={dataLayout} heading={heading}>\n      <HPAIdentifier name=\"Lookup\" resolverType={resolverType} />\n      <HPADetails\n        name=\"Modify\"\n        notes={notes}\n        confirmActionSettings={{\n          title: \"Resize HPA\",\n          description: <ConfirmResizeHPA />,\n        }}\n      />\n      <Confirm name=\"Result\" notes={notes} />\n    </Wizard>\n  );\n};\n\nexport default ResizeHPA;", "output": "import React from \"react\";\nimport { BrowserRouter } from \"react-router-dom\";\nimport { ThemeProvider } from \"@clutch-sh/core/src/Theme\";\nimport { render } from \"@testing-library/react\";\n\nimport \"@testing-library/jest-dom\";\n\nimport ResizeHPA from \"../resize-hpa\";\n\ntest(\"renders correctly\", () => {\n  const { asFragment } = render(\n    <BrowserRouter>\n      <ThemeProvider>\n        <ResizeHPA resolverType=\"clutch.aws.k8s.v1.HPA\" />\n      </ThemeProvider>\n    </BrowserRouter>\n  );\n\n  expect(asFragment()).toMatchSnapshot();\n});", "meta": {"repo": "lyft/clutch", "stars": 1758, "component": "frontend/workflows/k8s/src/resize-hpa.tsx", "test": "frontend/workflows/k8s/src/tests/resize-hpa.test.tsx"}}
{"input": "import type {TextareaHTMLAttributes, ReactElement} from 'react'\nimport React from 'react'\nimport {TextInputBaseWrapper} from '../internal/components/TextInputWrapper'\nimport type {FormValidationStatus} from '../utils/types/FormValidationStatus'\nimport type {SxProp} from '../sx'\nimport classes from './TextArea.module.css'\n\nexport const DEFAULT_TEXTAREA_ROWS = 7\nexport const DEFAULT_TEXTAREA_COLS = 30\nexport const DEFAULT_TEXTAREA_RESIZE = 'both'\n\nexport type TextareaProps = {\n  /**\n   * Apply inactive visual appearance to the Textarea\n   */\n  disabled?: boolean\n  /**\n   * Indicates whether the Textarea validation state\n   */\n  validationStatus?: FormValidationStatus\n  /**\n   * Block\n   */\n  block?: boolean\n  /**\n   * Allows resizing of the textarea\n   */\n  resize?: 'none' | 'both' | 'horizontal' | 'vertical'\n  /**\n   * apply a high contrast color to background\n   */\n  contrast?: boolean\n  /**\n   * The className to apply to the wrapper element\n   */\n  className?: string\n} & TextareaHTMLAttributes<HTMLTextAreaElement> &\n  SxProp\n\n/**\n * An accessible, native textarea component that supports validation states.\n * This component accepts all native HTML <textarea> attributes as props.\n */\nconst Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(\n  (\n    {\n      value,\n      disabled,\n      sx: sxProp,\n      required,\n      validationStatus,\n      rows = DEFAULT_TEXTAREA_ROWS,\n      cols = DEFAULT_TEXTAREA_COLS,\n      resize = DEFAULT_TEXTAREA_RESIZE,\n      block,\n      contrast,\n      className,\n      ...rest\n    }: TextareaProps,\n    ref,\n  ): ReactElement => {\n    return (\n      <TextInputBaseWrapper\n        sx={sxProp}\n        validationStatus={validationStatus}\n        disabled={disabled}\n        block={block}\n        contrast={contrast}\n        className={className}\n      >\n        <textarea\n          value={value}\n          data-resize={resize}\n          aria-required={required}\n          aria-invalid={validationStatus === 'error' ? 'true' : 'false'}\n          ref={ref}\n          disabled={disabled}\n          rows={rows}\n          cols={cols}\n          className={classes.TextArea}\n          {...rest}\n        />\n      </TextInputBaseWrapper>\n    )\n  },\n)\n\nTextarea.displayName = 'Textarea'\n\nexport default Textarea", "output": "import React from 'react'\nimport Textarea from '../Textarea'\nimport {render, screen} from '@testing-library/react'\nimport userEvent from '@testing-library/user-event'\nimport {describe, expect, it, vi, beforeEach} from 'vitest'\nimport classes from './TextArea.module.css'\n\nfunction getCSSRules(selector: string): Array<CSSStyleRule> {\n  return Array.from(document.styleSheets).flatMap(sheet => {\n    return Array.from(sheet.cssRules).filter((rule): rule is CSSStyleRule => {\n      if (rule instanceof CSSStyleRule) {\n        return rule.selectorText === selector\n      }\n      return false\n    })\n  })\n}\n\ndescribe('Textarea', () => {\n  beforeEach(() => {\n    vi.resetAllMocks()\n  })\n\n  it('should support `className` on the outermost element', () => {\n    expect(render(<Textarea className={'test-class-name'} />).container.firstChild).toHaveClass('test-class-name')\n  })\n\n  it('renders a valid textarea input', () => {\n    render(<Textarea />)\n    expect(screen.getByRole('textbox')).toBeInTheDocument()\n  })\n\n  it('renders an empty textarea by default', () => {\n    render(<Textarea />)\n    const textareaElement = screen.getByRole('textbox') as HTMLTextAreaElement\n    expect(textareaElement.value).toEqual('')\n  })\n\n  it('renders an uncontrolled component correctly', () => {\n    const sideEffectValue = 'mock value 2'\n\n    const MockComponent = () => {\n      const ref = React.useRef<HTMLTextAreaElement>(null)\n\n      React.useEffect(() => {\n        if (ref.current) {\n          ref.current.value = sideEffectValue\n        }\n      }, [ref])\n\n      return <Textarea ref={ref} />\n    }\n\n    render(<MockComponent />)\n    const textareaElement = screen.getByRole('textbox') as HTMLTextAreaElement\n    expect(textareaElement.value).toBe(sideEffectValue)\n  })\n\n  it('renders an optional block prop correctly', () => {\n    const {container} = render(<Textarea block />)\n    const style = window.getComputedStyle(container.firstElementChild!)\n    expect(style.display).toBe('flex')\n\n    const rules = getCSSRules(`.${classes.TextArea}`)\n    const has100PercentWidth = rules.some(rule => {\n      return rule.style.width && rule.style.width === '100%'\n    })\n    expect(has100PercentWidth).toBe(true)\n  })\n\n  it('renders default resize values correctly', () => {\n    render(<Textarea />)\n    const textareaElement = screen.getByRole('textbox')\n\n    expect(textareaElement).toBeInTheDocument()\n    const rules = getCSSRules(`.${classes.TextArea}`)\n    const hasResizeDeclaration = rules.some(rule => {\n      return rule.style.resize && rule.style.resize === 'both'\n    })\n    expect(hasResizeDeclaration).toBe(true)\n  })\n\n  it('renders none resize values correctly', () => {\n    render(<Textarea resize=\"none\" />)\n    const textareaElement = screen.getByRole('textbox')\n\n    expect(textareaElement).toBeInTheDocument()\n    const rules = getCSSRules(`.${classes.TextArea}[data-resize=\"none\"]`)\n    const hasResizeDeclaration = rules.some(rule => {\n      return rule.style.resize && rule.style.resize === 'none'\n    })\n    expect(hasResizeDeclaration).toBe(true)\n  })\n\n  it('renders a value in the textarea', () => {\n    const mockValue = 'mock value'\n    const onChange = vi.fn()\n    render(<Textarea onChange={onChange} value={mockValue} />)\n\n    const textareaElement = screen.getByRole('textbox') as HTMLTextAreaElement\n    expect(textareaElement.value).toEqual(mockValue)\n  })\n\n  it('can render an inactive textarea', async () => {\n    const user = userEvent.setup()\n    const handleChange = vi.fn()\n    const {rerender} = render(<Textarea disabled onChange={handleChange} />)\n\n    const textareaElement = screen.getByRole('textbox') as HTMLTextAreaElement\n    expect(textareaElement.disabled).toEqual(true)\n    expect(textareaElement).toHaveAttribute('disabled')\n\n    await user.click(textareaElement)\n\n    expect(handleChange).not.toHaveBeenCalled()\n\n    // remove disabled attribute and retest\n    rerender(<Textarea onChange={handleChange} />)\n\n    expect(textareaElement.disabled).toEqual(false)\n    expect(textareaElement).not.toHaveAttribute('disabled')\n  })\n\n  it('renders an aria-required attribute correctly', () => {\n    render(<Textarea required />)\n    const textareaElement = screen.getByRole('textbox') as HTMLTextAreaElement\n    expect(textareaElement).toHaveAttribute('aria-required', 'true')\n  })\n\n  it('renders an invalid aria state when validation prop indicates an error', () => {\n    const {rerender} = render(<Textarea />)\n    const textareaElement = screen.getByRole('textbox') as HTMLTextAreaElement\n    expect(textareaElement).toHaveAttribute('aria-invalid', 'false')\n\n    rerender(<Textarea validationStatus=\"success\" />)\n    expect(textareaElement).toHaveAttribute('aria-invalid', 'false')\n\n    rerender(<Textarea validationStatus=\"error\" />)\n    expect(textareaElement).toHaveAttribute('aria-invalid', 'true')\n  })\n})", "meta": {"repo": "primer/react", "stars": 3587, "component": "packages/react/src/Textarea/Textarea.tsx", "test": "packages/react/src/Textarea/Textarea.test.tsx"}}
{"input": "/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0; you may not use this file except in compliance with the Elastic License\n * 2.0.\n */\n\nimport { some } from 'lodash/fp';\nimport { useMemo } from 'react';\nimport type { TimelineEventsDetailsItem } from '@kbn/timelines-plugin/common';\nimport { getAlertDetailsFieldValue } from '../../../../common/lib/endpoint/utils/get_event_details_field_values';\n\nexport interface UseBasicDataFromDetailsDataResult {\n  agentId: string;\n  alertId: string;\n  alertUrl: string;\n  data: TimelineEventsDetailsItem[] | null;\n  hostName: string;\n  indexName: string;\n  isAlert: boolean;\n  ruleDescription: string;\n  ruleId: string;\n  ruleName: string;\n  timestamp: string;\n  userName: string;\n}\n\nexport const useBasicDataFromDetailsData = (\n  data: TimelineEventsDetailsItem[] | null\n): UseBasicDataFromDetailsDataResult => {\n  const agentId = useMemo(\n    () => getAlertDetailsFieldValue({ category: 'agent', field: 'agent.id' }, data),\n    [data]\n  );\n\n  const alertId = useMemo(\n    () => getAlertDetailsFieldValue({ category: '_id', field: '_id' }, data),\n    [data]\n  );\n\n  const alertUrl = useMemo(\n    () => getAlertDetailsFieldValue({ category: 'kibana', field: 'kibana.alert.url' }, data),\n    [data]\n  );\n\n  const hostName = useMemo(\n    () => getAlertDetailsFieldValue({ category: 'host', field: 'host.name' }, data),\n    [data]\n  );\n\n  const indexName = useMemo(\n    () => getAlertDetailsFieldValue({ category: '_index', field: '_index' }, data),\n    [data]\n  );\n\n  const isAlert = some({ category: 'kibana', field: 'kibana.alert.rule.uuid' }, data);\n\n  const ruleDescription = useMemo(\n    () =>\n      getAlertDetailsFieldValue(\n        { category: 'kibana', field: 'kibana.alert.rule.description' },\n        data\n      ),\n    [data]\n  );\n\n  const ruleId = useMemo(\n    () =>\n      isAlert\n        ? getAlertDetailsFieldValue({ category: 'kibana', field: 'kibana.alert.rule.uuid' }, data)\n        : getAlertDetailsFieldValue({ category: 'signal', field: 'signal.rule.id' }, data),\n    [isAlert, data]\n  );\n\n  const ruleName = useMemo(\n    () => getAlertDetailsFieldValue({ category: 'kibana', field: 'kibana.alert.rule.name' }, data),\n    [data]\n  );\n\n  const timestamp = useMemo(\n    () => getAlertDetailsFieldValue({ category: 'base', field: '@timestamp' }, data),\n    [data]\n  );\n\n  const userName = useMemo(\n    () => getAlertDetailsFieldValue({ category: 'user', field: 'user.name' }, data),\n    [data]\n  );\n\n  return useMemo(\n    () => ({\n      agentId,\n      alertId,\n      alertUrl,\n      data,\n      hostName,\n      indexName,\n      isAlert,\n      ruleDescription,\n      ruleId,\n      ruleName,\n      timestamp,\n      userName,\n    }),\n    [\n      agentId,\n      alertId,\n      alertUrl,\n      data,\n      hostName,\n      indexName,\n      isAlert,\n      ruleDescription,\n      ruleId,\n      ruleName,\n      timestamp,\n      userName,\n    ]\n  );\n};", "output": "/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0; you may not use this file except in compliance with the Elastic License\n * 2.0.\n */\n\nimport { renderHook } from '@testing-library/react';\nimport { useBasicDataFromDetailsData } from './use_basic_data_from_details_data';\nimport { mockDataFormattedForFieldBrowser } from '../mocks/mock_data_formatted_for_field_browser';\n\ndescribe('useBasicDataFromDetailsData', () => {\n  it('should return all empty properties', () => {\n    const hookResult = renderHook(() => useBasicDataFromDetailsData(null));\n\n    expect(hookResult.result.current.agentId).toEqual('');\n    expect(hookResult.result.current.alertId).toEqual('');\n    expect(hookResult.result.current.alertUrl).toEqual('');\n    expect(hookResult.result.current.data).toEqual(null);\n    expect(hookResult.result.current.hostName).toEqual('');\n    expect(hookResult.result.current.indexName).toEqual('');\n    expect(hookResult.result.current.isAlert).toEqual(false);\n    expect(hookResult.result.current.ruleDescription).toEqual('');\n    expect(hookResult.result.current.ruleId).toEqual('');\n    expect(hookResult.result.current.ruleName).toEqual('');\n    expect(hookResult.result.current.timestamp).toEqual('');\n    expect(hookResult.result.current.userName).toEqual('');\n  });\n\n  it('should return all properties', () => {\n    const hookResult = renderHook(() =>\n      useBasicDataFromDetailsData(mockDataFormattedForFieldBrowser)\n    );\n\n    expect(hookResult.result.current.agentId).toEqual('agent.id');\n    expect(hookResult.result.current.alertId).toEqual('_id');\n    expect(hookResult.result.current.alertUrl).toEqual('alert-url');\n    expect(hookResult.result.current.data).toEqual(mockDataFormattedForFieldBrowser);\n    expect(hookResult.result.current.hostName).toEqual('host-name');\n    expect(hookResult.result.current.indexName).toEqual('index');\n    expect(hookResult.result.current.isAlert).toEqual(true);\n    expect(hookResult.result.current.ruleDescription).toEqual('rule-description');\n    expect(hookResult.result.current.ruleId).toEqual('rule-uuid');\n    expect(hookResult.result.current.ruleName).toEqual('rule-name');\n    expect(hookResult.result.current.timestamp).toEqual('2023-01-01T01:01:01.000Z');\n    expect(hookResult.result.current.userName).toEqual('user-name');\n  });\n});", "meta": {"repo": "elastic/kibana", "stars": 20552, "component": "x-pack/solutions/security/plugins/security_solution/public/flyout/document_details/shared/hooks/use_basic_data_from_details_data.tsx", "test": "x-pack/solutions/security/plugins/security_solution/public/flyout/document_details/shared/hooks/use_basic_data_from_details_data.test.tsx"}}
{"input": "import { useState, useRef, useEffect } from 'react';\nimport styles from './TextArea.styles';\nimport { TextAreaProps } from './types';\n\nconst { TextAreaStyled, LabelStyled, TextAreaWrapper } = styles;\n\nconst TextArea: React.FC<TextAreaProps> = ({\n    autoComplete = true,\n    id,\n    label,\n    name,\n    ref,\n    onChange,\n    onBlur,\n    placeholder,\n    state,\n    validation,\n    value = '',\n    width = '300px',\n    ...props\n}: TextAreaProps) => {\n    const [currentValue, setCurrentValue] = useState(value);\n    const myRef = useRef<HTMLTextAreaElement | null>(ref ? ref.current : null);\n\n    const textareaRef = useRef<HTMLTextAreaElement | null>(null);\n\n    const valueChanged = (event: React.ChangeEvent<HTMLTextAreaElement>) => {\n        setCurrentValue(event.target.value);\n        onChange && onChange(event);\n    };\n\n    useEffect(() => {\n        if (textareaRef && textareaRef.current) {\n            textareaRef.current.style.height = '0px';\n            const scrollHeight = textareaRef.current.scrollHeight;\n            textareaRef.current.style.height = scrollHeight + 'px';\n        }\n    }, [currentValue]);\n\n    return (\n        <TextAreaWrapper\n            className={currentValue.length > 0 ? 'filled' : 'empty'}\n            data-testid=\"test-textarea-wrapper\"\n            state={state}\n            width={width}\n        >\n            <TextAreaStyled\n                autoComplete={`${autoComplete}`}\n                data-testid=\"test-textarea\"\n                disabled={state === 'disabled'}\n                id={id}\n                maxLength={validation?.characterMaxLength}\n                minLength={validation?.characterMinLength}\n                name={name}\n                onChange={(event: React.ChangeEvent<HTMLTextAreaElement>) =>\n                    valueChanged(event)\n                }\n                onBlur={(event: React.FocusEvent<HTMLTextAreaElement>) =>\n                    onBlur && onBlur(event)\n                }\n                placeholder={placeholder}\n                ref={(event) => {\n                    textareaRef.current = event;\n                    if (myRef) myRef.current = event;\n                }}\n                required={validation?.required}\n                rows={4}\n                value={currentValue}\n                {...props}\n            />\n            {label && (\n                <LabelStyled data-testid=\"test-textarea-label\" htmlFor={id}>\n                    {label}\n                </LabelStyled>\n            )}\n        </TextAreaWrapper>\n    );\n};\n\nexport default TextArea;", "output": "import { composeStories } from '@storybook/testing-react';\nimport '@testing-library/jest-dom';\nimport { fireEvent, render, screen } from '@testing-library/react';\n\nimport { color } from '@web3uikit/styles';\nimport * as stories from './TextArea.stories';\nimport { test, expect, describe, vi } from 'vitest';\n\nconst { Default, Error, Confirmed, Disabled, CustomWidth } =\n    composeStories(stories);\n\nconst testValue = 'Test Value';\nconst testPlaceholder = 'Type here field';\nconst testTextAreaId = 'test-textarea';\nconst testWrapperId = 'test-textarea-wrapper';\nconst testLabelId = 'test-textarea-label';\nconst testEvent = vi.fn();\n\ntest('TextArea - Default', async () => {\n    const testLabel = Default?.args?.label;\n    const testName = Default?.args?.name;\n\n    render(\n        <Default\n            onChange={(event: React.ChangeEvent<HTMLTextAreaElement>) =>\n                testEvent(event.target)\n            }\n        />,\n    );\n\n    // renders the component\n    const textarea = screen.getByTestId(\n        testTextAreaId,\n    ) as unknown as HTMLTextAreaElement | null;\n    expect(textarea).not.toBeNull();\n\n    // renders textarea with the value and placeholder passed\n    textarea && expect(textarea.value).toBe(testValue);\n    textarea && expect(textarea.placeholder).toBe(testPlaceholder);\n\n    // renders textarea with the name passed'\n    textarea && expect(textarea.name).toBe(testName);\n\n    // renders wrapper correct border color\n    const textareaWrapper = screen.getByTestId(\n        testWrapperId,\n    ) as unknown as HTMLDivElement | null;\n    const styles = textareaWrapper && getComputedStyle(textareaWrapper);\n    expect(styles?.borderColor.toUpperCase()).toBe(color.gray30);\n\n    // renders label text\n    const label = screen.getByTestId(testLabelId);\n    expect(label).not.toBeNull();\n    expect(label?.textContent).toBe(testLabel);\n\n    // should conditionally render 'empty / filled' className\n    expect(textareaWrapper?.classList.contains('filled')).toBeFalsy;\n    expect(textareaWrapper?.classList.contains('empty')).toBeTruthy;\n\n    textarea?.focus();\n    textarea && fireEvent.change(textarea, { target: { value: 'foo' } });\n    textarea && expect(textarea.value).toBe('foo');\n\n    expect(textareaWrapper?.classList.contains('filled')).toBeTruthy;\n    expect(textareaWrapper?.classList.contains('empty')).toBeFalsy;\n\n    // onChange event is returned, testEvent\n    expect(testEvent).toHaveBeenCalled();\n});\n\ntest('TextArea - Error', async () => {\n    const testLabel = Error?.args?.label;\n    const testName = Error?.args?.name;\n\n    render(<Error />);\n\n    // renders the component\n    const textarea = screen.getByTestId(\n        testTextAreaId,\n    ) as unknown as HTMLTextAreaElement | null;\n    expect(textarea).not.toBeNull();\n\n    // renders textarea with the value and placeholder passed\n    textarea && expect(textarea.value).toBe(testValue);\n    textarea && expect(textarea.placeholder).toBe(testPlaceholder);\n\n    // renders textarea with the name passed'\n    textarea && expect(textarea.name).toBe(testName);\n\n    // renders wrapper correct border color\n    const textareaWrapper = screen.getByTestId(\n        testWrapperId,\n    ) as unknown as HTMLDivElement | null;\n    const styles = textareaWrapper && getComputedStyle(textareaWrapper);\n    expect(styles?.borderColor.toUpperCase()).toBe(color.red40);\n\n    // renders label text\n    const label = screen.getByTestId(testLabelId);\n    expect(label).not.toBeNull();\n    expect(label?.textContent).toBe(testLabel);\n\n    // should conditionally render 'empty / filled' className\n    expect(textareaWrapper?.classList.contains('filled')).toBeFalsy;\n    expect(textareaWrapper?.classList.contains('empty')).toBeTruthy;\n\n    textarea?.focus();\n    textarea && fireEvent.change(textarea, { target: { value: 'foo' } });\n    textarea && expect(textarea.value).toBe('foo');\n\n    expect(textareaWrapper?.classList.contains('filled')).toBeTruthy;\n    expect(textareaWrapper?.classList.contains('empty')).toBeFalsy;\n\n    // onChange event is returned, testEvent\n    expect(testEvent).toHaveBeenCalled();\n});\n\ntest('TextArea - Confirmed', async () => {\n    const testLabel = Confirmed?.args?.label;\n    const testName = Confirmed?.args?.name;\n\n    render(<Confirmed />);\n\n    // renders the component\n    const textarea = screen.getByTestId(\n        testTextAreaId,\n    ) as unknown as HTMLTextAreaElement | null;\n    expect(textarea).not.toBeNull();\n\n    // renders textarea with the value and placeholder passed\n    textarea && expect(textarea.value).toBe(testValue);\n    textarea && expect(textarea.placeholder).toBe(testPlaceholder);\n\n    // renders textarea with the name passed'\n    textarea && expect(textarea.name).toBe(testName);\n\n    // renders wrapper correct border color\n    const textareaWrapper = screen.getByTestId(\n        testWrapperId,\n    ) as unknown as HTMLDivElement | null;\n    const styles = textareaWrapper && getComputedStyle(textareaWrapper);\n    expect(styles?.borderColor.toUpperCase()).toBe(color.mint40);\n\n    // renders label text\n    const label = screen.getByTestId(testLabelId);\n    expect(label).not.toBeNull();\n    expect(label?.textContent).toBe(testLabel);\n\n    // should conditionally render 'empty / filled' className\n    expect(textareaWrapper?.classList.contains('filled')).toBeFalsy;\n    expect(textareaWrapper?.classList.contains('empty')).toBeTruthy;\n\n    textarea?.focus();\n    textarea && fireEvent.change(textarea, { target: { value: 'foo' } });\n    textarea && expect(textarea.value).toBe('foo');\n\n    expect(textareaWrapper?.classList.contains('filled')).toBeTruthy;\n    expect(textareaWrapper?.classList.contains('empty')).toBeFalsy;\n\n    // onChange event is returned, testEvent\n    expect(testEvent).toHaveBeenCalled();\n});\n\ntest('TextArea - Disabled', async () => {\n    const testLabel = Disabled?.args?.label;\n    const testName = Disabled?.args?.name;\n\n    render(<Disabled />);\n\n    // renders the component\n    const textarea = screen.getByTestId(\n        testTextAreaId,\n    ) as unknown as HTMLTextAreaElement | null;\n    expect(textarea).not.toBeNull();\n\n    // renders textarea with the value and placeholder passed\n    textarea && expect(textarea.value).toBe(testValue);\n    textarea && expect(textarea.placeholder).toBe(testPlaceholder);\n\n    // renders textarea with the name passed'\n    textarea && expect(textarea.name).toBe(testName);\n\n    // renders wrapper correct border color\n    const textareaWrapper = screen.getByTestId(\n        testWrapperId,\n    ) as unknown as HTMLDivElement | null;\n    const styles = textareaWrapper && getComputedStyle(textareaWrapper);\n    expect(styles?.borderColor.toUpperCase()).toBe(color.gray30);\n\n    // renders label text\n    const label = screen.getByTestId(testLabelId);\n    expect(label).not.toBeNull();\n    expect(label?.textContent).toBe(testLabel);\n\n    // should conditionally render 'empty / filled' className\n    expect(textareaWrapper?.classList.contains('filled')).toBeFalsy;\n    expect(textareaWrapper?.classList.contains('empty')).toBeTruthy;\n\n    textarea?.focus();\n    textarea && fireEvent.change(textarea, { target: { value: 'foo' } });\n    textarea && expect(textarea.value).toBe('foo');\n\n    expect(textareaWrapper?.classList.contains('filled')).toBeTruthy;\n    expect(textareaWrapper?.classList.contains('empty')).toBeFalsy;\n\n    // onChange event is returned, testEvent\n    expect(testEvent).toHaveBeenCalled();\n});\n\ntest('TextArea - CustomWidth', async () => {\n    const testLabel = CustomWidth?.args?.label;\n    const testName = CustomWidth?.args?.name;\n    const testWidth = CustomWidth?.args?.width;\n\n    render(\n        <CustomWidth\n            onChange={(event: React.ChangeEvent<HTMLTextAreaElement>) =>\n                testEvent(event.target)\n            }\n        />,\n    );\n\n    // renders the component\n    const textarea = screen.getByTestId(\n        testTextAreaId,\n    ) as unknown as HTMLTextAreaElement | null;\n    expect(textarea).not.toBeNull();\n\n    // renders textarea with the value and placeholder passed\n    textarea && expect(textarea.value).toBe('');\n    textarea && expect(textarea.placeholder).toBe(testPlaceholder);\n\n    // renders textarea with the name passed'\n    textarea && expect(textarea.name).toBe(testName);\n\n    // renders wrapper correct border color\n    const textareaWrapper = screen.getByTestId(\n        testWrapperId,\n    ) as unknown as HTMLDivElement | null;\n    const styles = textareaWrapper && getComputedStyle(textareaWrapper);\n    expect(styles?.borderColor.toUpperCase()).toBe(color.gray30);\n\n    // renders label text\n    const label = screen.getByTestId(testLabelId);\n    expect(label).not.toBeNull();\n    expect(label?.textContent).toBe(testLabel);\n\n    // should conditionally render 'empty / filled' className\n    expect(textareaWrapper?.classList.contains('filled')).toBeFalsy;\n    expect(textareaWrapper?.classList.contains('empty')).toBeTruthy;\n\n    textarea?.focus();\n    textarea && fireEvent.change(textarea, { target: { value: 'foo' } });\n    textarea && expect(textarea.value).toBe('foo');\n\n    expect(textareaWrapper?.classList.contains('filled')).toBeTruthy;\n    expect(textareaWrapper?.classList.contains('empty')).toBeFalsy;\n\n    // onChange event is returned, testEvent\n    expect(testEvent).toHaveBeenCalled();\n\n    // renders width property\n    expect(styles?.width).toBe(testWidth);\n});", "meta": {"repo": "web3ui/web3uikit", "stars": 1757, "component": "packages/core/src/lib/TextArea/TextArea.tsx", "test": "packages/core/src/lib/TextArea/TextArea.test.tsx"}}
{"input": "import React, {createContext, useContext, useState, useEffect} from 'react'\nimport {canUseDOM} from '../utils/environment'\nimport {warning} from '../utils/warning'\n\n/**\n * `useMedia` will use the given `mediaQueryString` with `matchMedia` to\n * determine if the document matches the media query string.\n *\n * If `MatchMedia` is used as an ancestor, `useMedia` will instead use the\n * value of the media query string, if available\n *\n * @example\n * function Example() {\n *   const coarsePointer = useMedia('(pointer: coarse)');\n *   // ...\n * }\n */\nexport function useMedia(mediaQueryString: string, defaultState?: boolean) {\n  const features = useContext(MatchMediaContext)\n  const [matches, setMatches] = React.useState(() => {\n    if (features[mediaQueryString] !== undefined) {\n      return features[mediaQueryString] as boolean\n    }\n\n    // Prevent a React hydration mismatch when a default value is provided by not defaulting to window.matchMedia(query).matches.\n    if (defaultState !== undefined) {\n      return defaultState\n    }\n\n    if (canUseDOM) {\n      return window.matchMedia(mediaQueryString).matches\n    }\n\n    // A default value has not been provided, and you are rendering on the server, warn of a possible hydration mismatch when defaulting to false.\n    warning(\n      true,\n      '`useMedia` When server side rendering, defaultState should be defined to prevent a hydration mismatches.',\n    )\n\n    return false\n  })\n\n  useEffect(() => {\n    if (features[mediaQueryString] !== undefined) {\n      setMatches(features[mediaQueryString] as boolean)\n    }\n  }, [features, mediaQueryString])\n\n  useEffect(() => {\n    // If `mediaQueryString` is present in features through `context` defer to\n    // the value present instead of checking with matchMedia\n    if (features[mediaQueryString] !== undefined) {\n      return\n    }\n\n    function listener(event: MediaQueryListEvent) {\n      setMatches(event.matches)\n    }\n\n    const mediaQueryList = window.matchMedia(mediaQueryString)\n\n    // Support fallback to `addListener` for broader browser support\n    // @ts-ignore this is not present in Safari <14\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (mediaQueryList.addEventListener) {\n      mediaQueryList.addEventListener('change', listener)\n    } else {\n      mediaQueryList.addListener(listener)\n    }\n\n    // Make sure the media query list is in sync with the matches state\n    setMatches(mediaQueryList.matches)\n\n    return () => {\n      // @ts-ignore this is not present in Safari <14\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (mediaQueryList.addEventListener) {\n        mediaQueryList.removeEventListener('change', listener)\n      } else {\n        mediaQueryList.removeListener(listener)\n      }\n    }\n  }, [features, mediaQueryString])\n\n  return matches\n}\n\ntype MediaQueryFeatures = {\n  [key: string]: boolean | undefined\n}\n\n// Used to keep track of overrides to specific media query features, this should\n// be used for development and demo purposes to emulate specific features if\n// unavailable through devtools\nconst MatchMediaContext = createContext<MediaQueryFeatures>({})\n\ntype MatchMediaProps = {\n  children: React.ReactNode\n  features?: MediaQueryFeatures\n}\n\nconst defaultFeatures = {}\n\n/**\n * Use `MatchMedia` to emulate media conditions by passing in feature\n * queries to the `features` prop. If a component uses `useMedia` with the\n * feature passed in to `MatchMedia` it will force its value to match what is\n * provided to `MatchMedia`\n *\n * This should be used for development and documentation only in situations\n * where devtools cannot emulate this feature\n *\n * @example\n * <MatchMedia features={{ \"(pointer: coarse)\": true}}>\n *   <Children />\n * </MatchMedia>\n */\nexport function MatchMedia({children, features = defaultFeatures}: MatchMediaProps) {\n  const value = useShallowObject(features)\n  return <MatchMediaContext.Provider value={value}>{children}</MatchMediaContext.Provider>\n}\n\ntype SimpleObject = {\n  [key: string]: boolean | number | string | null | undefined\n}\n\n/**\n * Utility hook to provide a stable identity for a \"simple\" object which\n * contains only primitive values. This provides a `useMemo`-esque signature\n * without dealing with shallow equality checks in the dependency array.\n *\n * Note (perf): this hook iterates through keys and values of the object if the\n * shallow equality check is false each time the hook is called\n */\nfunction useShallowObject<T extends SimpleObject>(object: T): T {\n  const [value, setValue] = useState(object)\n\n  if (value !== object) {\n    const match = Object.keys(object).every(key => {\n      return object[key] === value[key]\n    })\n    if (!match) {\n      setValue(object)\n    }\n  }\n\n  return value\n}", "output": "import {render} from '@testing-library/react'\nimport {afterEach, describe, expect, it, vi} from 'vitest'\nimport {act} from 'react'\nimport ReactDOM from 'react-dom/server'\nimport {useMedia, MatchMedia} from '../useMedia'\n\ntype MediaQueryEventListener = (event: {matches: boolean}) => void\n\nfunction mockMatchMedia({defaultMatch = false} = {}) {\n  const listeners = new Set<MediaQueryEventListener>()\n\n  Object.defineProperty(window, 'matchMedia', {\n    writable: true,\n    value: vi.fn().mockImplementation(query => ({\n      matches: defaultMatch,\n      media: query,\n      onchange: null,\n      addListener: vi.fn(), // deprecated\n      removeListener: vi.fn(), // deprecated\n      addEventListener: (_type: string, listener: MediaQueryEventListener) => {\n        listeners.add(listener)\n      },\n      removeEventListener: (_type: string, listener: MediaQueryEventListener) => {\n        listeners.delete(listener)\n      },\n      dispatchEvent: vi.fn(),\n    })),\n  })\n\n  return {\n    change({matches = false}) {\n      for (const listener of listeners) {\n        listener({\n          matches,\n        })\n      }\n    },\n  }\n}\n\ndescribe('useMedia', () => {\n  afterEach(() => {\n    mockMatchMedia()\n  })\n\n  it('should default to the matchMedia value', () => {\n    mockMatchMedia()\n\n    const match: boolean[] = []\n\n    function TestComponent() {\n      const value = useMedia('(pointer: coarse)')\n      match.push(value)\n      return null\n    }\n\n    render(<TestComponent />)\n    expect(match[0]).toBe(false)\n\n    mockMatchMedia({defaultMatch: true})\n\n    render(<TestComponent />)\n    expect(match[1]).toBe(true)\n  })\n\n  it('should default to false when used during SSR', () => {\n    const match: boolean[] = []\n\n    function TestComponent() {\n      const value = useMedia('(pointer: coarse)')\n      match.push(value)\n      return null\n    }\n\n    ReactDOM.renderToString(<TestComponent />)\n    expect(match[0]).toBe(false)\n  })\n\n  it('should respond to change in matchMedia values', () => {\n    const {change} = mockMatchMedia()\n\n    const match: boolean[] = []\n\n    function TestComponent() {\n      const value = useMedia('(pointer: coarse)')\n      match.push(value)\n      return null\n    }\n\n    render(<TestComponent />)\n    expect(match[0]).toBe(false)\n\n    act(() => {\n      change({matches: true})\n    })\n\n    expect(match[1]).toBe(true)\n  })\n\n  it('should default to the features value in context if available', () => {\n    mockMatchMedia()\n\n    const feature = '(pointer: coarse)'\n    const match: boolean[] = []\n\n    function TestComponent() {\n      const value = useMedia(feature)\n      match.push(value)\n      return null\n    }\n\n    render(\n      <MatchMedia features={{[feature]: true}}>\n        <TestComponent />\n      </MatchMedia>,\n    )\n    expect(match[0]).toBe(true)\n\n    render(\n      <MatchMedia features={{[feature]: false}}>\n        <TestComponent />\n      </MatchMedia>,\n    )\n    expect(match[1]).toBe(false)\n\n    ReactDOM.renderToString(\n      <MatchMedia features={{[feature]: true}}>\n        <TestComponent />\n      </MatchMedia>,\n    )\n    expect(match[2]).toBe(true)\n  })\n})", "meta": {"repo": "primer/react", "stars": 3587, "component": "packages/react/src/hooks/useMedia.tsx", "test": "packages/react/src/hooks/__tests__/useMedia.test.tsx"}}
{"input": "// Copyright 2020 H2O.ai, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { B, box, disconnect, Id, Model, on, S, U } from './core'\nimport React from 'react'\nimport { NotificationBar, notificationBarB } from './notification_bar'\nimport { Dialog, dialogB } from './dialog'\nimport { cards } from './layout'\nimport { showNotification } from './notification'\nimport { executeScript, InlineScript, installScripts, Script } from './script'\nimport { SidePanel, sidePanelB } from './side_panel'\nimport { themeB, themesB } from './theme'\nimport { setupTracker, Tracker } from './tracking'\nimport { bond } from './ui'\n\n\nexport type FlexBox = Partial<{ zone: S, order: U, size: S, width: S, height: S }>\n\n\n/**\n * Create an inline CSS to be injected into a page.\n */\ninterface InlineStylesheet {\n  /** The CSS to be applied to this page. */\n  content: S\n  /** A valid media query to set conditions for when the style should be applied. More info at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style#attr-media. */\n  media?: S\n}\n\n/**\n * Create a reference to an external CSS file to be included on a page.\n */\ninterface Stylesheet {\n  /** The URI of an external stylesheet. */\n  path: S\n  /** A valid media query to set conditions for when the stylesheet should be loaded. More info at https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link#attr-media. */\n  media?: S\n  /** The CORS setting. See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link#attr-crossorigin */\n  cross_origin?: S\n}\n/**\n * Represents the layout structure for a page.\n */\nexport interface Layout {\n  /**\n   * The minimum viewport width at which to use this layout.\n   * Values must be pixel widths (e.g. '0px', '576px', '768px') or a named preset.\n   * The named presets are:\n   * 'xs': '0px' for extra small devices (portrait phones),\n   * 's': '576px' for small devices (landscape phones),\n   * 'm': '768px' for medium devices (tablets),\n   * 'l': '992px' for large devices (desktops),\n   * 'xl': '1200px' for extra large devices (large desktops).\n   *\n   * A breakpoint value of 'xs' (or '0') matches all viewport widths, unless other breakpoints are set.\n  */\n  breakpoint: S\n  /** The zones in this layout. Each zones can in turn contain sub-zones. */\n  zones: Zone[]\n  /** The width of the layout. Defaults to `100%`. */\n  width?: S\n  /** The minimum width of the layout. */\n  min_width?: S\n  /** The maximum width of the layout. */\n  max_width?: S\n  /** The height of the layout. Defaults to `auto`. */\n  height?: S\n  /** The minimum height of the layout. */\n  min_height?: S\n  /** The maximum height of the layout. */\n  max_height?: S\n  /** An identifying name for this zone. */\n  name?: Id\n}\n\n/**\n * Represents an zone within a page layout.\n */\nexport interface Zone {\n  /** An identifying name for this zone. */\n  name: Id\n  /** The size of this zone. */\n  size?: S\n  /** Layout direction. */\n  direction?: 'row' | 'column'\n  /** Layout strategy for main axis. */\n  justify?: 'start' | 'end' | 'center' | 'between' | 'around'\n  /** Layout strategy for cross axis. */\n  align?: 'start' | 'end' | 'center' | 'stretch'\n  /** Wrapping strategy. */\n  wrap?: 'start' | 'end' | 'center' | 'between' | 'around' | 'stretch'\n  /** The sub-zones contained inside this zone. */\n  zones?: Zone[]\n}\n\n/** \n * Theme (color scheme) to apply colors to the app.\n*/\nexport interface Theme {\n  /** An identifying name for this theme. */\n  name: Id\n  /** Base color of the textual components. */\n  text: S\n  /** Card background color. */\n  card: S\n  /** Page background color. */\n  page: S\n  /** Primary color used to accent components. */\n  primary: S\n}\n\n/**\n * Represents page-global state.\n *\n * This card is invisible.\n * It is used to control attributes of the active page.\n*/\ninterface State {\n  /** The title of the page. */\n  title?: S\n  /** Refresh rate in seconds. A value of 0 turns off live-updates. Values != 0 are currently ignored (reserved for future use). */\n  refresh?: U\n  /** Display a desktop notification. */\n  notification?: S\n  /** Display an in-app notification bar. */\n  notification_bar?: NotificationBar\n  /** Redirect the page to a new URL. */\n  redirect?: S\n  /** \n   * Shortcut icon path. Preferably a `.png` file (`.ico` files may not work in mobile browsers). \n   * Not supported in Safari.\n  */\n  icon?: S\n  /** The layouts supported by this page. */\n  layouts?: Layout[]\n  /** Display a dialog on the page. */\n  dialog?: Dialog\n  /** Display a side panel on the page. */\n  side_panel?: SidePanel\n  /** Specify the name of the theme (color scheme) to use on this page. One of 'light', 'neon' or 'h2o-dark'. */\n  theme?: S\n  /** * Themes (color schemes) that define color used in the app. */\n  themes?: Theme[]\n  /** Configure a tracker for the page (for web analytics). */\n  tracker?: Tracker\n  /** External Javascript files to load into the page. */\n  scripts?: Script[]\n  /** Javascript code to execute on this page. */\n  script?: InlineScript\n  /** CSS stylesheet to be applied to this page. */\n  stylesheet?: InlineStylesheet\n  /** External CSS files to load into the page. */\n  stylesheets?: Stylesheet[]\n  /** EXPERIMENTAL: True to turn on the card animations. Defaults to False. */\n  animate?: B\n}\n\nconst\n  windowTitleB = box(''),\n  windowIconB = box('')\n\non(windowTitleB, t => window.document.title = t)\non(windowIconB, icon => {\n  const\n    iconLink = document.querySelector(\"link[rel*='icon']\") as HTMLLinkElement,\n    touchIconLink = document.querySelector(\"link[rel*='apple-touch-icon']\") as HTMLLinkElement\n  if (iconLink) iconLink.href = icon\n  // Not working as of Feb 2021 since Safari does not support dynamic favicon changes.\n  if (touchIconLink) touchIconLink.href = icon\n})\n\nexport const\n  layoutsB = box<Layout[]>([]),\n  preload = ({ state }: Model<State>) => {\n    const {\n      title,\n      icon,\n      refresh,\n      notification,\n      notification_bar,\n      redirect,\n      layouts,\n      dialog,\n      side_panel,\n      theme,\n      themes,\n      tracker,\n      scripts,\n      script,\n      stylesheet,\n      stylesheets,\n      animate\n    } = state\n\n    if (redirect) {\n      try {\n        const\n          { location } = window,\n          url = new URL(`${location.origin}${location.pathname}${redirect}`)\n        if (redirect === url.hash) {\n          location.hash = redirect\n        } else {\n          location.replace(redirect)\n        }\n      } catch (e) {\n        console.error(`Could not redirect: ${redirect} is an invalid URL`, e)\n      }\n      delete state.redirect\n    }\n\n    dialogB(dialog ? { ...dialog } : null)\n    sidePanelB(side_panel ? { ...side_panel } : null)\n    // HACK: Since meta cards are processed within render, wait for React to finish the original render before proceeding.\n    setTimeout(() => notificationBarB(notification_bar ? { ...notification_bar } : null), 0)\n\n    if (animate) document.body.style.setProperty('--wave-animation-duration', '0.5s')\n    if (title) windowTitleB(title)\n    if (icon) windowIconB(icon)\n    if (typeof refresh === 'number' && refresh === 0) disconnect()\n    if (theme) themeB(theme)\n    if (themes) themesB(themes)\n    if (notification) showNotification(notification)\n    if (tracker) setupTracker(tracker)\n    if (layouts) layoutsB(layouts)\n    if (scripts) installScripts(scripts)\n    if (script) {\n      delete state.script\n      executeScript(script)\n    }\n    if (stylesheet) {\n      const styleEl = document.createElement('style')\n      const { content, media } = stylesheet\n      styleEl.innerText = content\n      if (media) styleEl.media = media\n      document.head.appendChild(styleEl)\n      delete state.stylesheet\n    }\n    if (stylesheets) {\n      stylesheets.forEach(({ path, media, cross_origin }) => {\n        const linkEl = document.createElement('link')\n        linkEl.rel = 'stylesheet'\n        linkEl.href = path\n        linkEl.as = 'style'\n        if (media) linkEl.media = media\n        if (cross_origin) linkEl.crossOrigin = cross_origin\n        document.head.appendChild(linkEl)\n      })\n      delete state.stylesheets\n    }\n  }\n\nexport const View = bond(() => ({ render: () => <></> }))\n\ncards.register('meta', View)", "output": "// Copyright 2020 H2O.ai, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport * as T from './core'\nimport { dialogB } from './dialog'\nimport { preload } from \"./meta\"\nimport * as N from './notification'\n\nconst\n  name = 'meta',\n  metaProps: T.Model<any> = {\n    name,\n    state: {},\n    changed: T.box(false)\n  }\n\ndescribe('Meta.tsx', () => {\n  beforeEach(() => jest.clearAllMocks())\n\n  it('Sets title - init', () => {\n    preload({ ...metaProps, state: { title: name } })\n    expect(window.document.title).toBe(name)\n  })\n\n  it('Shows notification - init', () => {\n    const showNotificationMock = jest.fn()\n    // @ts-ignore\n    N.showNotification = showNotificationMock\n\n    preload({ ...metaProps, state: { notification: name } })\n    expect(showNotificationMock).toHaveBeenCalled()\n    expect(showNotificationMock).toHaveBeenCalledWith(name)\n  })\n\n  it('Sets dialog - init', () => {\n    const dialog = {\n      name: 'dialog',\n      title: 'Dialog Title',\n      items: [],\n    }\n    expect(dialogB()).toBe(null)\n    preload({ ...metaProps, state: { dialog } })\n    expect(dialogB()).toMatchObject(dialog)\n  })\n\n})", "meta": {"repo": "h2oai/wave", "stars": 4114, "component": "ui/src/meta.tsx", "test": "ui/src/meta.test.tsx"}}
{"input": "import { Layout } from '@ui-kitten/components'\nimport React from 'react'\nimport { useTranslation } from 'react-i18next'\nimport { View, ScrollView } from 'react-native'\n\nimport { ButtonSetting } from '@berty/components/shared-components/SettingsButtons'\nimport { useStyles } from '@berty/contexts/styles'\nimport {\n\tuseThemeColor,\n\tuseGenerateFakeContacts,\n\tuseGenerateFakeMultiMembers,\n\tuseDeleteFakeData,\n\t// useGenerateFakeMessages,\n} from '@berty/hooks'\nimport { ScreenFC } from '@berty/navigation'\n\nconst BodyFakeData = () => {\n\tconst { t } = useTranslation()\n\tconst { padding, flex, margin } = useStyles()\n\tconst colors = useThemeColor()\n\n\tconst generateFakeContacts = useGenerateFakeContacts()\n\tconst generateFakeMM = useGenerateFakeMultiMembers()\n\tconst deleteFake = useDeleteFakeData()\n\t// const convGenMsg = useGenerateFakeMessages()\n\n\treturn (\n\t\t<View style={[padding.medium, flex.tiny, margin.bottom.small]}>\n\t\t\t<ButtonSetting\n\t\t\t\tname={t('settings.fake-data.contacts-button')}\n\t\t\t\ticon='book-outline'\n\t\t\t\ticonSize={30}\n\t\t\t\ticonColor={colors['alt-secondary-background-header']}\n\t\t\t\tactionIcon={null}\n\t\t\t\tonPress={() => generateFakeContacts(5)}\n\t\t\t/>\n\t\t\t<ButtonSetting\n\t\t\t\tname={t('settings.fake-data.multi-members-button')}\n\t\t\t\ticon='book-outline'\n\t\t\t\ticonSize={30}\n\t\t\t\ticonColor={colors['alt-secondary-background-header']}\n\t\t\t\tactionIcon={null}\n\t\t\t\tonPress={() => generateFakeMM(5)}\n\t\t\t/>\n\t\t\t<ButtonSetting\n\t\t\t\tname={t('settings.fake-data.messages-button')}\n\t\t\t\ticon='book-outline'\n\t\t\t\ticonSize={30}\n\t\t\t\ticonColor={colors['alt-secondary-background-header']}\n\t\t\t\tactionIcon={null}\n\t\t\t\t/*onPress={() => convGenMsg(3)}*/\n\t\t\t/>\n\t\t\t<ButtonSetting\n\t\t\t\tname={t('settings.fake-data.delete-button')}\n\t\t\t\ticon='book-outline'\n\t\t\t\ticonSize={30}\n\t\t\t\ticonColor={colors['alt-secondary-background-header']}\n\t\t\t\tactionIcon={null}\n\t\t\t\tonPress={() => deleteFake()}\n\t\t\t/>\n\t\t</View>\n\t)\n}\n\nexport const FakeData: ScreenFC<'Settings.FakeData'> = () => {\n\tconst colors = useThemeColor()\n\n\treturn (\n\t\t<Layout style={{ flex: 1, backgroundColor: colors['main-background'] }}>\n\t\t\t<ScrollView bounces={false}>\n\t\t\t\t<BodyFakeData />\n\t\t\t</ScrollView>\n\t\t</Layout>\n\t)\n}", "output": "import { renderScreen } from '@berty/utils/testing/renderScreen.test'\n\nimport { FakeData } from './FakeData'\n\ntest('Settings.FakeData renders correctly', () => {\n\tconst { toJSON } = renderScreen('Settings.FakeData', FakeData)\n\texpect(toJSON()).toMatchSnapshot()\n})", "meta": {"repo": "berty/berty", "stars": 8295, "component": "js/packages/screens/settings/FakeData/FakeData.tsx", "test": "js/packages/screens/settings/FakeData/FakeData.test.tsx"}}
{"input": "import { ArrowChangeDown } from 'components/Icons/ArrowChangeDown'\nimport { ArrowChangeUp } from 'components/Icons/ArrowChangeUp'\nimport styled from 'lib/styled-components'\nimport { colorsDark, colorsLight } from 'ui/src/theme'\n\nconst StyledUpArrow = styled(ArrowChangeUp)<{ $noColor?: boolean }>`\n  color: ${({ theme, $noColor }) =>\n    $noColor ? theme.neutral2 : theme.darkMode ? colorsDark.statusSuccess : colorsLight.statusSuccess};\n`\nconst StyledDownArrow = styled(ArrowChangeDown)<{ $noColor?: boolean }>`\n  color: ${({ theme, $noColor }) =>\n    $noColor ? theme.neutral2 : theme.darkMode ? colorsDark.statusCritical : colorsLight.statusCritical};\n`\n\nexport function calculateDelta(start: number, current: number): number | undefined {\n  const delta = (current / start - 1) * 100\n  return isValidDelta(delta) ? delta : undefined\n}\n\nfunction isValidDelta(delta: number | null | undefined): delta is number {\n  // Null-check not including zero\n  return delta !== null && delta !== undefined && delta !== Infinity && !isNaN(delta)\n}\n\nfunction isDeltaZero(delta: string): boolean {\n  return parseFloat(delta) === 0\n}\n\ninterface DeltaArrowProps {\n  delta?: number | null\n  formattedDelta: string\n  noColor?: boolean\n  size?: number\n}\n\nexport function DeltaArrow({ delta, formattedDelta, noColor = false, size = 16 }: DeltaArrowProps) {\n  if (!isValidDelta(delta)) {\n    return null\n  }\n\n  const isZero = isDeltaZero(formattedDelta)\n\n  return Math.sign(delta) < 0 && !isZero ? (\n    <StyledDownArrow width={size} height={size} key=\"arrow-down\" aria-label=\"down\" $noColor={noColor} />\n  ) : (\n    <StyledUpArrow width={size} height={size} key=\"arrow-up\" aria-label=\"up\" $noColor={noColor} />\n  )\n}\n\nexport const DeltaText = styled.span<{ delta?: number }>`\n  color: ${({ theme, delta }) =>\n    delta !== undefined\n      ? Math.sign(delta) < 0\n        ? theme.darkMode\n          ? colorsDark.statusCritical\n          : colorsLight.statusCritical\n        : theme.darkMode\n          ? colorsDark.statusSuccess\n          : colorsLight.statusSuccess\n      : theme.neutral1};\n`", "output": "import { DeltaArrow } from 'components/Tokens/TokenDetails/Delta'\nimport { render } from 'test-utils/render'\n\ndescribe('Delta', () => {\n  it('should render correctly', () => {\n    const { asFragment } = render(<DeltaArrow delta={0} formattedDelta=\"0.00\" />)\n    expect(asFragment()).toMatchSnapshot()\n  })\n\n  it('should render correctly when delta is positive', () => {\n    const { asFragment } = render(<DeltaArrow delta={1} formattedDelta=\"1.00\" />)\n    expect(asFragment()).toMatchSnapshot()\n  })\n\n  it('should render correctly when delta is negative', () => {\n    const { asFragment } = render(<DeltaArrow delta={-1} formattedDelta=\"-1.00\" />)\n    expect(asFragment()).toMatchSnapshot()\n  })\n\n  it('should render positive zero when delta is close to zero but positive', () => {\n    const { asFragment } = render(<DeltaArrow delta={0.000000000000000001} formattedDelta=\"0.00%\" />)\n    expect(asFragment()).toMatchSnapshot()\n  })\n\n  it('should render negative zero when delta is close to zero but negative', () => {\n    const { asFragment } = render(<DeltaArrow delta={-0.000000000000000001} formattedDelta=\"0.00%\" />)\n    expect(asFragment()).toMatchSnapshot()\n  })\n\n  it('should render positive zero when delta is parsed as positive zero', () => {\n    const { asFragment } = render(<DeltaArrow delta={0.000000000000000001} formattedDelta=\"0.00\" />)\n    expect(asFragment()).toMatchSnapshot()\n  })\n\n  it('should render positive zero when delta is 0', () => {\n    const { asFragment } = render(<DeltaArrow delta={0} formattedDelta=\"0.00\" />)\n    expect(asFragment()).toMatchSnapshot()\n  })\n})", "meta": {"repo": "Uniswap/interface", "stars": 5224, "component": "apps/web/src/components/Tokens/TokenDetails/Delta.tsx", "test": "apps/web/src/components/Tokens/TokenDetails/Delta.test.tsx"}}
{"input": "import isUndefined from 'lodash/isUndefined';\nimport { ChangeEvent, useCallback, useEffect, useState } from 'react';\n\nimport styles from './AutoresizeTextarea.module.css';\n\ninterface Props {\n  value?: string;\n  name: string;\n  disabled?: boolean;\n  required?: boolean;\n  invalidText?: string;\n  minRows?: number;\n  maxRows?: number;\n  onChange?: (e: ChangeEvent<HTMLTextAreaElement>) => void;\n}\n\nconst DEFAULT_MIN_ROWS = 3;\n\nconst AutoresizeTextarea = (props: Props) => {\n  const [rows, setRows] = useState<number>(6);\n  const [textValue, setTextValue] = useState<string>(props.value || '');\n\n  const calculateHeight = useCallback(\n    (value?: string) => {\n      const txtValue = value || props.value || '';\n      const textLength = txtValue.split('\\n').length;\n      const minRows = props.minRows || DEFAULT_MIN_ROWS;\n      const newRowsNumber = textLength < minRows ? minRows : textLength;\n      setRows(props.maxRows ? (newRowsNumber > props.maxRows ? props.maxRows : newRowsNumber) : newRowsNumber);\n    },\n    [props.maxRows, props.minRows, props.value]\n  );\n\n  useEffect(() => {\n    setTextValue(props.value || '');\n    calculateHeight();\n  }, [calculateHeight, props.value]);\n\n  return (\n    <>\n      <textarea\n        className={`form-control ${styles.textarea}`}\n        rows={rows}\n        id={props.name}\n        name={props.name}\n        value={textValue}\n        disabled={props.disabled}\n        required={props.required}\n        onChange={(e: ChangeEvent<HTMLTextAreaElement>) => {\n          calculateHeight(e.target.value);\n          setTextValue(e.target.value);\n          if (!isUndefined(props.onChange)) {\n            props.onChange(e);\n          }\n        }}\n        wrap=\"off\"\n        spellCheck=\"false\"\n      />\n      {!isUndefined(props.invalidText) && <div className=\"invalid-feedback mt-0\">{props.invalidText}</div>}\n    </>\n  );\n};\n\nexport default AutoresizeTextarea;", "output": "import { fireEvent, render, screen } from '@testing-library/react';\n\nimport AutoresizeTextarea from './AutoresizeTextarea';\n\ninterface Test {\n  value: string;\n  rows: number;\n}\n\nconst tests: Test[] = [\n  { value: 'Test', rows: 3 },\n  { value: 'Line 1\\nLine 2', rows: 3 },\n  { value: 'Line 1\\nLine 2\\nLine 3', rows: 3 },\n  { value: 'Line 1\\nLine 2\\nLine 3\\nLine 4', rows: 4 },\n  { value: 'Line 1\\nLine 2\\nLine 3\\nLine 4\\nLine 5', rows: 5 },\n  { value: 'Line 1\\nLine 2\\nLine 3\\nLine 4\\nLine 5\\nLine 6\\nLine 7\\nLine 8\\nLine 9\\nLine 10', rows: 10 },\n];\n\nconst mockOnChange = jest.fn();\n\nconst defaultProps = {\n  name: 'test',\n  onChange: mockOnChange,\n};\n\ndescribe('AutoresizeTextarea', () => {\n  afterEach(() => {\n    jest.resetAllMocks();\n  });\n\n  it('creates snapshot', () => {\n    const { asFragment } = render(<AutoresizeTextarea {...defaultProps} />);\n    expect(asFragment()).toMatchSnapshot();\n  });\n\n  for (let i = 0; i < tests.length; i++) {\n    it('renders component', () => {\n      render(<AutoresizeTextarea {...defaultProps} value={tests[i].value} />);\n      const textarea = screen.getByRole('textbox');\n      expect(textarea).toHaveProperty('rows', tests[i].rows);\n    });\n  }\n\n  it('calls onChange when textarea content is changed', () => {\n    render(<AutoresizeTextarea {...defaultProps} />);\n    fireEvent.change(screen.getByRole('textbox'), { target: { value: 'text' } });\n\n    expect(mockOnChange).toHaveBeenCalledTimes(1);\n  });\n});", "meta": {"repo": "artifacthub/hub", "stars": 1864, "component": "web/src/layout/common/AutoresizeTextarea.tsx", "test": "web/src/layout/common/AutoresizeTextarea.test.tsx"}}
{"input": "import Form from 'hew/Form';\nimport Glossary, { InfoRow } from 'hew/Glossary';\nimport React, { useCallback, useEffect, useMemo } from 'react';\n\nimport Link from 'components/Link';\nimport { Metadata } from 'types';\n\nimport css from './EditableMetadata.module.scss';\nimport EditableRow from './EditableRow';\n\nexport const ADD_ROW_TEXT = '+ Add Row';\n\ninterface Props {\n  editing?: boolean;\n  metadata?: Metadata;\n  updateMetadata?: (obj: Metadata) => void;\n}\n\nconst EditableMetadata: React.FC<Props> = ({ metadata = {}, editing, updateMetadata }: Props) => {\n  const [metadataRows, metadataList] = useMemo(() => {\n    const { rows, list } = Object.entries(metadata).reduce(\n      (acc, [key, value]) => {\n        const stringedValue = typeof value === 'object' ? JSON.stringify(value) : value;\n        acc.rows.push({ label: key, value: stringedValue });\n        acc.list.push({ key, value });\n        return acc;\n      },\n      { list: [] as { key: string; value: string | object }[], rows: [] as InfoRow[] },\n    );\n    if (list.length === 0) list.push({ key: '', value: '' });\n    return [rows, list];\n  }, [metadata]);\n\n  const onValuesChange = useCallback(\n    (_changedValues: { metadata: Metadata[] }, values: { metadata: Metadata[] }) => {\n      const mapAndUpdate = (metadata: Metadata[]) => {\n        // filtering with Boolean as, upon removing a row, it triggers the onValuesChange with the removed row as an undefined entry.\n        const newMetadata = metadata.filter(Boolean).reduce((acc, row) => {\n          if (row.value === undefined) {\n            row.value = '';\n          }\n          if (typeof row?.key === 'string') acc[row.key] = row.value;\n          return acc;\n        }, {} as Metadata);\n\n        updateMetadata?.(newMetadata);\n      };\n\n      mapAndUpdate(values.metadata);\n    },\n    [updateMetadata],\n  );\n\n  const [form] = Form.useForm();\n  useEffect(() => {\n    form.resetFields();\n  }, [form, editing]);\n\n  return (\n    <Form form={form} initialValues={{ metadata: metadataList }} onValuesChange={onValuesChange}>\n      {editing ? (\n        <>\n          <div className={css.titleRow}>\n            <span>Key</span>\n            <span>Value</span>\n          </div>\n          <Form.List name=\"metadata\">\n            {(fields, { add, remove }) => (\n              <>\n                {fields.map((field, idx) => (\n                  <EditableRow\n                    jsonValue={\n                      typeof metadataList[idx]?.value === 'object'\n                        ? JSON.stringify(metadataList[idx]?.value || '')\n                        : undefined\n                    }\n                    key={field.key}\n                    name={field.name}\n                    onDelete={() => remove(field.name)}\n                  />\n                ))}\n                <Link onClick={() => add({ key: '', value: '' })}>{ADD_ROW_TEXT}</Link>\n              </>\n            )}\n          </Form.List>\n        </>\n      ) : (\n        <Glossary content={metadataRows} />\n      )}\n    </Form>\n  );\n};\n\nexport default EditableMetadata;", "output": "import { render, screen, waitFor } from '@testing-library/react';\nimport userEvent, { PointerEventsCheckLevel } from '@testing-library/user-event';\nimport UIProvider, { DefaultTheme } from 'hew/Theme';\n\nimport { Metadata } from 'types';\n\nimport EditableMetadata, { ADD_ROW_TEXT } from './EditableMetadata';\nimport {\n  DELETE_ROW_LABEL,\n  METADATA_KEY_PLACEHOLDER,\n  METADATA_VALUE_PLACEHOLDER,\n} from './EditableRow';\n\nconst initMetadata = { hello: 'world', testing: 'metadata' };\n\nconst user = userEvent.setup({ pointerEventsCheck: PointerEventsCheckLevel.Never });\n\nconst setup = (metadata: Metadata = {}, editing = false) => {\n  const handleOnChange = vi.fn();\n  const view = render(\n    <UIProvider theme={DefaultTheme.Light}>\n      <EditableMetadata editing={editing} metadata={metadata} updateMetadata={handleOnChange} />\n    </UIProvider>,\n  );\n  return { handleOnChange, view };\n};\n\ndescribe('EditableMetadata', () => {\n  it('displays list of metadata', () => {\n    setup(initMetadata);\n\n    Object.entries(initMetadata).forEach(([key, value]) => {\n      expect(screen.getByText(key)).toBeInTheDocument();\n      expect(screen.getByText(value)).toBeInTheDocument();\n    });\n  });\n\n  it('handles metadata addition', async () => {\n    const [additionKey, additionValue] = ['animal', 'fox'];\n    const resultMetadata = {\n      ...initMetadata,\n      ...Object.fromEntries([[additionKey, additionValue]]),\n    };\n    const { handleOnChange } = setup(initMetadata, true);\n\n    const addRow = screen.getByText(ADD_ROW_TEXT);\n    await user.click(addRow);\n\n    const keyInputs = screen.getAllByPlaceholderText(METADATA_KEY_PLACEHOLDER);\n    const keyInput = keyInputs.last();\n    await user.click(keyInput);\n    await user.type(keyInput, additionKey);\n\n    const valueInputs = screen.getAllByPlaceholderText(METADATA_VALUE_PLACEHOLDER);\n    const valueInput = valueInputs.last();\n    await user.click(valueInput);\n    await user.type(valueInput, additionValue);\n\n    expect(handleOnChange).toHaveBeenLastCalledWith(resultMetadata);\n  });\n\n  it('handles metadata removal', async () => {\n    const metadataArray = Object.entries(initMetadata);\n    const removalIndex = Math.floor(Math.random() * metadataArray.length);\n    const resultMetadata = Object.fromEntries(\n      metadataArray.filter((_metadata, idx) => idx !== removalIndex),\n    );\n    const { handleOnChange, view } = setup(initMetadata, true);\n\n    const actionButton = view.getAllByRole('button', { name: 'action' })[removalIndex];\n    await user.click(actionButton);\n    user.click(await view.findByText(DELETE_ROW_LABEL, undefined, { container: actionButton }));\n\n    await waitFor(() => {\n      expect(handleOnChange).toHaveBeenCalledWith(resultMetadata);\n    });\n  });\n});", "meta": {"repo": "determined-ai/determined", "stars": 3152, "component": "webui/react/src/components/Metadata/EditableMetadata.tsx", "test": "webui/react/src/components/Metadata/EditableMetadata.test.tsx"}}
{"input": "/*\n * Copyright (C) 2020 Graylog, Inc.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the Server Side Public License, version 1,\n * as published by MongoDB, Inc.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * Server Side Public License for more details.\n *\n * You should have received a copy of the Server Side Public License\n * along with this program. If not, see\n * <http://www.mongodb.com/licensing/server-side-public-license>.\n */\n\nimport { useMemo } from 'react';\n\nimport type { Event } from 'components/events/events/types';\nimport type { EventDefinitionAggregation } from 'hooks/useEventDefinition';\nimport useEventDefinition from 'hooks/useEventDefinition';\nimport type { EventDefinition } from 'components/event-definitions/event-definitions-types';\nimport useEventById from 'hooks/useEventById';\n\nconst useAlertAndEventDefinitionData = (alertId: string, definitionId?: string) => {\n  const { data: eventData, isLoading: isLoadingEvent } = useEventById(alertId);\n  const { data, isLoading: isLoadingEventDefinition } = useEventDefinition(\n    definitionId ?? eventData?.event_definition_id,\n  );\n  const eventDefinition = data?.eventDefinition;\n  const aggregations = data?.aggregations;\n  const isLoading = (alertId && isLoadingEvent) || (definitionId && isLoadingEventDefinition);\n\n  return useMemo<{\n    alertId: string;\n    definitionId: string;\n    definitionTitle: string;\n    eventData: Event;\n    eventDefinition: EventDefinition;\n    aggregations: Array<EventDefinitionAggregation>;\n    isLoading: boolean;\n  }>(\n    () => ({\n      alertId,\n      definitionId: eventDefinition?.id,\n      definitionTitle: eventDefinition?.title,\n      eventData,\n      eventDefinition,\n      aggregations,\n      isLoading,\n    }),\n    [alertId, eventDefinition, eventData, aggregations, isLoading],\n  );\n};\n\nexport default useAlertAndEventDefinitionData;", "output": "/*\n * Copyright (C) 2020 Graylog, Inc.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the Server Side Public License, version 1,\n * as published by MongoDB, Inc.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * Server Side Public License for more details.\n *\n * You should have received a copy of the Server Side Public License\n * along with this program. If not, see\n * <http://www.mongodb.com/licensing/server-side-public-license>.\n */\nimport { renderHook } from 'wrappedTestingLibrary/hooks';\n\nimport {\n  mockedMappedAggregation,\n  mockEventData,\n  mockEventDefinitionTwoAggregations,\n} from 'helpers/mocking/EventAndEventDefinitions_mock';\nimport asMock from 'helpers/mocking/AsMock';\nimport useAlertAndEventDefinitionData from 'components/event-definitions/replay-search/hooks/useAlertAndEventDefinitionData';\nimport useEventById from 'hooks/useEventById';\nimport useEventDefinition from 'hooks/useEventDefinition';\n\njest.mock('hooks/useEventById');\njest.mock('hooks/useEventDefinition');\n\nconst mockedHookData = {\n  alertId: mockEventData.event.id,\n  definitionId: mockEventData.event.event_definition_id,\n  definitionTitle: mockEventDefinitionTwoAggregations.title,\n  eventData: mockEventData.event,\n  eventDefinition: mockEventDefinitionTwoAggregations,\n  aggregations: mockedMappedAggregation,\n};\n\nconst hookResultBase = {\n  refetch: () => {},\n  isLoading: false,\n  isFetched: true,\n} as const;\n\ndescribe('useAlertAndEventDefinitionData', () => {\n  beforeEach(() => {\n    asMock(useEventDefinition).mockReturnValue({\n      ...hookResultBase,\n      data: {\n        eventDefinition: mockEventDefinitionTwoAggregations,\n        aggregations: mockedMappedAggregation,\n      },\n    });\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  it('should return expected data for alert page', async () => {\n    const eventId = 'event-id-1';\n\n    asMock(useEventById).mockReturnValue({\n      ...hookResultBase,\n      data: { ...mockEventData.event, id: eventId, alert: true },\n    });\n\n    const { result } = renderHook(() => useAlertAndEventDefinitionData(eventId));\n\n    await expect(result.current).toEqual(mockedHookData);\n  });\n\n  it('should return expected data for event page', async () => {\n    const eventId = 'event-id-2';\n\n    asMock(useEventById).mockReturnValue({\n      ...hookResultBase,\n      data: { ...mockEventData.event, id: eventId, alert: false },\n    });\n\n    const { result } = renderHook(() => useAlertAndEventDefinitionData(eventId));\n\n    await expect(result.current).toEqual({\n      ...mockedHookData,\n      eventData: { ...mockEventData.event, id: eventId, alert: false },\n      alertId: eventId,\n    });\n  });\n\n  it('should return expected data for event definition', async () => {\n    asMock(useEventById).mockReturnValue({\n      ...hookResultBase,\n      data: undefined,\n    });\n\n    const { result } = renderHook(() =>\n      useAlertAndEventDefinitionData(undefined, mockEventDefinitionTwoAggregations.id),\n    );\n\n    await expect(result.current).toEqual({\n      ...mockedHookData,\n      eventData: undefined,\n      alertId: undefined,\n      isLoading: false,\n    });\n  });\n});", "meta": {"repo": "Graylog2/graylog2-server", "stars": 7710, "component": "graylog2-web-interface/src/components/event-definitions/replay-search/hooks/useAlertAndEventDefinitionData.tsx", "test": "graylog2-web-interface/src/components/event-definitions/replay-search/hooks/useAlertAndEventDefinitionData.test.tsx"}}
{"input": "'use client';\n\nimport * as React from 'react';\nimport { classNames } from '@vkontakte/vkjs';\nimport { useAdaptivity } from '../../hooks/useAdaptivity';\nimport { useExternRef } from '../../hooks/useExternRef';\nimport { usePlatform } from '../../hooks/usePlatform';\nimport { useResizeObserver } from '../../hooks/useResizeObserver';\nimport { callMultiple } from '../../lib/callMultiple';\nimport { useDOM } from '../../lib/dom';\nimport type { HasAlign, HasRef, HasRootRef } from '../../types';\nimport { FormField, type FormFieldProps } from '../FormField/FormField';\nimport { UnstyledTextField } from '../UnstyledTextField/UnstyledTextField';\nimport { useResizeTextarea } from './useResizeTextarea';\nimport styles from './Textarea.module.css';\n\nconst sizeYClassNames = {\n  none: styles.sizeYNone,\n  compact: styles.sizeYCompact,\n};\n\nexport interface TextareaProps\n  extends Omit<React.TextareaHTMLAttributes<HTMLTextAreaElement>, 'onResize'>,\n    HasRef<HTMLTextAreaElement>,\n    HasRootRef<HTMLElement>,\n    HasAlign,\n    FormFieldProps {\n  /**\n   * \u0421\u0432\u043e\u0439\u0441\u0442\u0432\u043e \u0443\u043f\u0440\u0430\u0432\u043b\u044f\u044e\u0449\u0435\u0435 \u0430\u0432\u0442\u043e\u043c\u0430\u0442\u0438\u0447\u0435\u0441\u043a\u0438\u043c \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u0435\u043c \u0432\u044b\u0441\u043e\u0442\u044b \u043a\u043e\u043c\u043f\u043e\u043d\u0435\u043d\u0442\u0430.\n   */\n  grow?: boolean;\n  /**\n   * \u041e\u0431\u0440\u0430\u0431\u043e\u0442\u0447\u0438\u043a, \u0441\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u044e\u0449\u0438\u0439 \u043f\u0440\u0438 \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u0438 \u0440\u0430\u0437\u043c\u0435\u0440\u0430 \u043a\u043e\u043c\u043f\u043e\u043d\u0435\u043d\u0442\u0430.\n   */\n  onResize?: (el: HTMLTextAreaElement) => void;\n  /**\n   * \u0417\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e.\n   */\n  defaultValue?: string;\n}\n\n/**\n * @see https://vkcom.github.io/VKUI/#/Textarea\n */\nexport const Textarea = ({\n  grow = true,\n  style,\n  onResize,\n  className,\n  getRootRef,\n  getRef,\n  rows = 2,\n  maxHeight,\n  status,\n  onChange,\n  align,\n  mode,\n  after,\n  before,\n  afterAlign,\n  beforeAlign,\n  value,\n  ...restProps\n}: TextareaProps): React.ReactNode => {\n  const { sizeY = 'none' } = useAdaptivity();\n  const platform = usePlatform();\n  const { window } = useDOM();\n\n  const [refResizeTextarea, resize] = useResizeTextarea(onResize, grow);\n  const elementRef = useExternRef(getRef, refResizeTextarea);\n\n  React.useEffect(resize, [resize, sizeY, platform, value]);\n  useResizeObserver(window, resize);\n\n  return (\n    <FormField\n      className={classNames(\n        styles.host,\n        sizeY !== 'regular' && sizeYClassNames[sizeY],\n        align === 'right' && styles.alignRight,\n        align === 'center' && styles.alignCenter,\n        className,\n      )}\n      style={style}\n      getRootRef={getRootRef}\n      disabled={restProps.disabled}\n      status={status}\n      mode={mode}\n      after={after}\n      before={before}\n      afterAlign={afterAlign}\n      beforeAlign={beforeAlign}\n      maxHeight={maxHeight}\n    >\n      <UnstyledTextField\n        {...restProps}\n        value={value}\n        as=\"textarea\"\n        rows={rows}\n        className={styles.el}\n        onChange={callMultiple(onChange, resize)}\n        getRootRef={elementRef}\n      />\n    </FormField>\n  );\n};", "output": "import { fireEvent, render, screen } from '@testing-library/react';\nimport { Platform } from '../../lib/platform';\nimport { baselineComponent, fakeTimers, userEvent } from '../../testing/utils';\nimport type { AlignType } from '../../types';\nimport { ConfigProvider } from '../ConfigProvider/ConfigProvider';\nimport { VisuallyHidden } from '../VisuallyHidden/VisuallyHidden';\nimport { Textarea } from './Textarea';\nimport styles from './Textarea.module.css';\n\nconst getInput = () => screen.getByRole('textbox');\n\ndescribe(Textarea, () => {\n  baselineComponent((props) => (\n    <>\n      <VisuallyHidden Component=\"label\" id=\"textarea\">\n        Textarea\n      </VisuallyHidden>\n      <Textarea aria-labelledby=\"textarea\" {...props} />\n    </>\n  ));\n\n  it.each<[AlignType, string]>([\n    ['right', styles.alignRight],\n    ['center', styles.alignCenter],\n  ])(`should have className when align %s`, (align, className) => {\n    const ref = {\n      current: null,\n    };\n    render(<Textarea getRootRef={ref} align={align} />);\n    expect(ref.current).toHaveClass(className);\n  });\n\n  describe('works uncontrolled', () => {\n    fakeTimers();\n\n    it('uses defaultValue', () => {\n      render(<Textarea defaultValue=\"def\" />);\n      expect(getInput()).toHaveValue('def');\n    });\n    it('manages value', async () => {\n      render(<Textarea />);\n      await userEvent.type(getInput(), 'user');\n      expect(getInput()).toHaveValue('user');\n    });\n    it('fires onChange', async () => {\n      let value = '';\n      render(<Textarea onChange={(e) => (value = e.target.value)} />);\n      await userEvent.type(getInput(), 'user');\n      expect(getInput()).toHaveValue('user');\n      expect(value).toBe('user');\n    });\n\n    it('form reset form', async () => {\n      render(\n        <form data-testid=\"form\">\n          <Textarea />\n        </form>,\n      );\n      await userEvent.type(getInput(), 'user');\n      expect(getInput()).toHaveValue('user');\n      screen.getByTestId<HTMLFormElement>('form').reset();\n      expect(getInput()).toHaveValue('');\n    });\n    it('form reset with defaultValue', async () => {\n      render(\n        <form data-testid=\"form\">\n          <Textarea defaultValue=\"def\" />\n        </form>,\n      );\n      expect(getInput()).toHaveValue('def');\n      await userEvent.type(getInput(), 'user');\n      expect(getInput()).toHaveValue('defuser');\n      screen.getByTestId<HTMLFormElement>('form').reset();\n      expect(getInput()).toHaveValue('def');\n    });\n  });\n\n  describe('works controlled', () => {\n    fakeTimers();\n\n    it('respects outer value', () => {\n      const { rerender } = render(<Textarea value=\"init\" />);\n      expect(getInput()).toHaveValue('init');\n      rerender(<Textarea value=\"update\" />);\n      expect(getInput()).toHaveValue('update');\n    });\n    it('value overrides defaultValue', () => {\n      jest.spyOn(global.console, 'error').mockImplementationOnce((message) => {\n        if (message.includes('with both value and defaultValue props.')) {\n          return;\n        }\n        global.console.error(message);\n      });\n      render(<Textarea defaultValue=\"def\" value=\"val\" />);\n      expect(getInput()).toHaveValue('val');\n    });\n    it('fires onChange', async () => {\n      let value = 'init';\n      render(<Textarea value={value} onChange={(e) => (value = e.target.value)} />);\n      await userEvent.type(getInput(), 'X');\n      expect(value).toBe('initX');\n    });\n    it('does not change without onChange', async () => {\n      render(<Textarea value=\"init\" />);\n      await userEvent.type(getInput(), 'user');\n      expect(getInput()).toHaveValue('init');\n    });\n  });\n\n  describe('calls onResize', () => {\n    fakeTimers();\n\n    const mockTextareaScrollHeight = () => {\n      const textArea = screen.getByTestId('textarea');\n      let height = 100;\n      jest.spyOn(textArea, 'scrollHeight', 'get').mockImplementation(() => {\n        const currHeight = height;\n        height += 10;\n        return currHeight;\n      });\n    };\n\n    it('when editing', async () => {\n      const onResize = jest.fn();\n      render(<Textarea data-testid=\"textarea\" value=\"\" onResize={onResize} />);\n      mockTextareaScrollHeight();\n      await userEvent.type(getInput(), '{enter}{enter}{enter}{enter}');\n      expect(onResize).toHaveBeenCalledTimes(5);\n    });\n    it('when changing controlled value', () => {\n      const onResize = jest.fn();\n      const { rerender } = render(<Textarea data-testid=\"textarea\" value=\"\" onResize={onResize} />);\n      mockTextareaScrollHeight();\n      rerender(<Textarea data-testid=\"textarea\" value=\"\\n\\n\\n\\n\" onResize={onResize} />);\n      expect(onResize).toHaveBeenCalledTimes(2);\n    });\n    it('when changing platform', async () => {\n      const onResize = jest.fn();\n\n      const { rerender } = render(\n        <ConfigProvider platform={Platform.VKCOM}>\n          <Textarea data-testid=\"textarea\" value=\"\" onResize={onResize} />\n        </ConfigProvider>,\n      );\n      mockTextareaScrollHeight();\n\n      rerender(\n        <ConfigProvider platform={Platform.ANDROID}>\n          <Textarea data-testid=\"textarea\" value=\"\" onResize={onResize} />\n        </ConfigProvider>,\n      );\n\n      expect(onResize).toHaveBeenCalledTimes(2);\n    });\n    it('when resize window', () => {\n      const onResize = jest.fn();\n      render(<Textarea data-testid=\"textarea\" value=\"\" onResize={onResize} />);\n      mockTextareaScrollHeight();\n      fireEvent(window, new Event('resize'));\n      expect(onResize).toHaveBeenCalledTimes(2);\n    });\n    it(\"won't resize if parent is invisible\", () => {\n      const onResize = jest.fn();\n      render(\n        <div style={{ display: 'none' }}>\n          <Textarea onResize={onResize} />\n        </div>,\n      ).rerender(\n        <div style={{ display: 'none' }}>\n          <Textarea value=\"\\n\\n\\n\\n\" onResize={onResize} />\n        </div>,\n      );\n      expect(onResize).not.toHaveBeenCalled();\n    });\n  });\n});", "meta": {"repo": "VKCOM/VKUI", "stars": 1078, "component": "packages/vkui/src/components/Textarea/Textarea.tsx", "test": "packages/vkui/src/components/Textarea/Textarea.test.tsx"}}
{"input": "/*\n * SPDX-License-Identifier: Apache-2.0\n *\n * The OpenSearch Contributors require contributions made to\n * this file be licensed under the Apache-2.0 license or a\n * compatible open source license.\n *\n * Any modifications Copyright OpenSearch Contributors. See\n * GitHub history for details.\n */\n\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport React, { FC } from 'react';\nimport PropTypes from 'prop-types';\nimport { EuiFlexGroup, EuiFlexItem, EuiSpacer, EuiTitle } from '@elastic/eui';\nimport { FormattedMessage } from '@osd/i18n/react';\n// @ts-expect-error untyped service\nimport { FeatureCatalogueEntry } from '../../../services';\nimport { createAppNavigationHandler } from '../../app_navigation_handler';\n\n// @ts-expect-error untyped component\nimport { Synopsis } from '../../synopsis';\n\ninterface Props {\n  addBasePath: (path: string) => string;\n  features: FeatureCatalogueEntry[];\n}\n\nexport const AddData: FC<Props> = ({ addBasePath, features }) => (\n  <section className=\"homDataAdd\" aria-labelledby=\"homDataAdd__title\">\n    <EuiFlexGroup alignItems=\"center\">\n      <EuiFlexItem grow={1}>\n        <EuiTitle size=\"s\">\n          <h2 id=\"homDataAdd__title\">\n            <FormattedMessage id=\"home.addData.sectionTitle\" defaultMessage=\"Ingest your data\" />\n          </h2>\n        </EuiTitle>\n      </EuiFlexItem>\n    </EuiFlexGroup>\n\n    <EuiSpacer size=\"m\" />\n\n    <EuiFlexGroup className=\"homDataAdd__content\">\n      {features.map((feature) => (\n        <EuiFlexItem key={feature.id}>\n          <Synopsis\n            id={feature.id}\n            onClick={createAppNavigationHandler(feature.path)}\n            description={feature.description}\n            iconType={feature.icon}\n            title={feature.title}\n            url={addBasePath(feature.path)}\n            wrapInPanel\n          />\n        </EuiFlexItem>\n      ))}\n    </EuiFlexGroup>\n  </section>\n);\n\nAddData.propTypes = {\n  addBasePath: PropTypes.func.isRequired,\n  // @ts-expect-error TS2322 TODO(ts-error): fixme\n  features: PropTypes.arrayOf(\n    PropTypes.shape({\n      id: PropTypes.string.isRequired,\n      title: PropTypes.string.isRequired,\n      description: PropTypes.string.isRequired,\n      icon: PropTypes.string.isRequired,\n      path: PropTypes.string.isRequired,\n      showOnHomePage: PropTypes.bool.isRequired,\n      category: PropTypes.string.isRequired,\n      order: PropTypes.number,\n    })\n  ),\n};", "output": "/*\n * SPDX-License-Identifier: Apache-2.0\n *\n * The OpenSearch Contributors require contributions made to\n * this file be licensed under the Apache-2.0 license or a\n * compatible open source license.\n *\n * Any modifications Copyright OpenSearch Contributors. See\n * GitHub history for details.\n */\n\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport React from 'react';\nimport { AddData } from './add_data';\nimport { shallowWithIntl } from 'test_utils/enzyme_helpers';\n\njest.mock('../../app_navigation_handler', () => {\n  return {\n    createAppNavigationHandler: jest.fn(() => () => {}),\n  };\n});\n\nbeforeEach(() => {\n  jest.clearAllMocks();\n});\n\nconst addBasePathMock = jest.fn((path: string) => (path ? path : 'path'));\n\nconst mockFeatures = [\n  {\n    category: 'data',\n    description: 'Get started with sample data, visualizations, and dashboards.',\n    showOnHomePage: true,\n    icon: 'indexOpen',\n    id: 'home_tutorial_directory',\n    order: 500,\n    path: '/app/home#/tutorial_directory',\n    title: 'Ingest data',\n  },\n  {\n    category: 'admin',\n    description: 'Add and manage your fleet of OpenSearch Agents and integrations.',\n    showOnHomePage: true,\n    icon: 'indexManagementApp',\n    id: 'ingestManager',\n    order: 510,\n    path: '/app/ingestManager',\n    title: 'Add OpenSearch Agent',\n  },\n  {\n    category: 'data',\n    description: 'Import your own CSV, NDJSON, or log file',\n    showOnHomePage: true,\n    icon: 'document',\n    id: 'ml_file_data_visualizer',\n    order: 520,\n    path: '/app/ml#/filedatavisualizer',\n    title: 'Upload a file',\n  },\n];\n\ndescribe('AddData', () => {\n  test('render', () => {\n    const component = shallowWithIntl(\n      <AddData addBasePath={addBasePathMock} features={mockFeatures} />\n    );\n    expect(component).toMatchSnapshot();\n  });\n});", "meta": {"repo": "opensearch-project/OpenSearch-Dashboards", "stars": 1844, "component": "src/plugins/home/public/application/components/legacy/add_data/add_data.tsx", "test": "src/plugins/home/public/application/components/legacy/add_data/add_data.test.tsx"}}
{"input": "import React, { useState, useRef, useEffect } from 'react';\nimport { ISelectProps, KEY, OptionProps } from '../types';\nimport styles from './SelectBeta.styles';\nimport SelectMenuList from './components/SelectMenuList';\nimport SelectedItemsList from './components/SelectedItemsList';\nimport { color } from '@web3uikit/styles';\nimport { useOutsideAlerter } from '../../../hooks/useOutsideAlerter';\n\nconst {\n    ButtonStyledSelect,\n    DivStyledDesc,\n    DivStyledSelectWrapper,\n    DivStyledWrapper,\n    LabelStyled,\n    TriangleDownIconStyled,\n    TriangleUpIconStyled,\n} = styles;\n\nconst SelectBeta: React.FunctionComponent<ISelectProps> = ({\n    customNoDataText = 'No Data',\n    customize,\n    customSelect,\n    defaultOptionIndex,\n    description,\n    disabled = false,\n    errorMessage,\n    height = '56px',\n    id,\n    isMulti = false,\n    isSearch = true,\n    label = 'Select',\n    max = Infinity,\n    menuHeight = '200px',\n    menuCustomize,\n    name = 'options',\n    onChange,\n    options = [],\n    placeholder,\n    prefixIcon,\n    ref,\n    style,\n    value = [],\n    width = '100%',\n    ...props\n}) => {\n    //unused variables that are not need to be passed to div\n    const {\n        onBlurTraditional,\n        onChangeTraditional,\n        prefixText,\n        refTraditional,\n        state,\n        traditionalHTML5,\n        validation,\n        tryBeta,\n        ...rest\n    } = props;\n    const triggerRef = useRef<HTMLButtonElement>(null);\n    const {\n        isInsideElementClick: isOpen,\n        outsideAlerterRef,\n        setIsInsideElementClick: setIsOpen,\n    } = useOutsideAlerter(false);\n\n    const elementId = (component: string) => {\n        if (component === undefined) return;\n        // Replace all space with '-' : to fix no scroll issue\n        const newName = name.replace(/ /g, '-');\n        return `w3uik-${newName}-${component}`;\n    };\n\n    const addItem = (option: string | undefined) => {\n        if (!option) return;\n        // multi selection\n        if (isMulti === true) {\n            const selected = [...value];\n            const index = selected.findIndex((item) => item === option);\n            if (index !== -1) {\n                selected.splice(index, 1); // if existing, remove\n            } else if (selected.length < max) {\n                selected.push(option); // if new, add unless we\u2019re at max\n            }\n\n            onChange?.(selected);\n            return;\n        }\n\n        // single selection\n        onChange?.(options.find((item) => item.id === option) as OptionProps);\n        setIsOpen(false);\n    };\n\n    // to set default value from options at first render\n    useEffect(() => {\n        if (\n            defaultOptionIndex !== undefined &&\n            defaultOptionIndex !== null &&\n            options &&\n            defaultOptionIndex >= 0 &&\n            defaultOptionIndex < options?.length\n        ) {\n            addItem(options[defaultOptionIndex]?.id as string);\n        }\n    }, []);\n\n    return (\n        <DivStyledWrapper\n            aria-expanded={isOpen === true}\n            aria-label=\"select\"\n            className=\"w3uik-select-component\"\n            customize={customize}\n            data-testid=\"test-select\"\n            id={id}\n            ref={ref}\n            role=\"listbox\"\n            style={{ ...style, width }}\n            {...rest}\n        >\n            <DivStyledSelectWrapper\n                ref={!isMulti ? outsideAlerterRef : undefined}\n                className=\"w3uik-container\"\n                height={height}\n                customize={customize}\n                menuCustomize={menuCustomize}\n            >\n                <ButtonStyledSelect\n                    aria-controls={elementId('menu')}\n                    aria-expanded={isOpen === true}\n                    aria-haspopup=\"listbox\"\n                    aria-selected={value.length > 0}\n                    customize={customize}\n                    data-testid=\"test-select-button\"\n                    disabled={disabled}\n                    onClick={() => {\n                        if (!disabled) setIsOpen((prev) => !prev);\n                    }}\n                    onKeyDown={(e) => {\n                        if (e.key === KEY.DOWN) {\n                            setIsOpen(true);\n                        }\n                    }}\n                    ref={triggerRef}\n                    type=\"button\"\n                >\n                    {!customSelect && (\n                        <>\n                            {label && (\n                                <LabelStyled\n                                    aria-disabled={disabled}\n                                    customize={customize}\n                                    data-testid=\"test-select-label\"\n                                    htmlFor={name}\n                                >\n                                    {label}\n                                </LabelStyled>\n                            )}\n                            {isOpen ? (\n                                <TriangleUpIconStyled\n                                    data-testid=\"test-select-icon\"\n                                    fontSize=\"20px\"\n                                    fill={customize?.color ?? color.navy40}\n                                    title=\"close menu\"\n                                />\n                            ) : (\n                                <TriangleDownIconStyled\n                                    data-testid=\"test-select-icon\"\n                                    fontSize=\"20px\"\n                                    fill={customize?.color ?? color.navy40}\n                                    title=\"open menu\"\n                                />\n                            )}\n                        </>\n                    )}\n                </ButtonStyledSelect>\n                <SelectedItemsList\n                    addItem={addItem}\n                    customSelect={customSelect}\n                    disabled={disabled}\n                    elementId={elementId}\n                    isMulti={isMulti}\n                    isOpen={isOpen}\n                    isSearch={isSearch}\n                    max={max}\n                    name={name}\n                    options={options}\n                    placeholder={placeholder}\n                    prefixIcon={prefixIcon}\n                    setIsOpen={setIsOpen}\n                    value={value}\n                />\n                {(description || errorMessage) && (\n                    <DivStyledDesc aria-invalid={state === 'error'}>\n                        {state === 'error'\n                            ? errorMessage\n                            : description && description}\n                    </DivStyledDesc>\n                )}\n            </DivStyledSelectWrapper>\n            {!disabled && (\n                <>\n                    <SelectMenuList\n                        addItem={addItem}\n                        customize={customize}\n                        customNoDataText={customNoDataText}\n                        disabled={disabled}\n                        elementId={elementId}\n                        isMulti={isMulti}\n                        isOpen={isOpen}\n                        isSearch={isSearch}\n                        max={max}\n                        menuCustomize={menuCustomize}\n                        menuHeight={menuHeight}\n                        name={name}\n                        ref={outsideAlerterRef}\n                        options={options}\n                        placeholder={placeholder}\n                        setIsOpen={setIsOpen}\n                        value={value}\n                    />\n                </>\n            )}\n            <input\n                name={name}\n                type=\"hidden\"\n                value={isMulti ? (value as string[]).join(',') : value}\n            />\n        </DivStyledWrapper>\n    );\n};\n\nexport default SelectBeta;", "output": "import React from 'react';\nimport { cleanup, fireEvent, render, screen } from '@testing-library/react';\nimport { composeStories } from '@storybook/testing-react';\nimport * as stories from '../Select.stories';\nimport { vi } from 'vitest';\n\nconst { BetaSelect, BetaSelectDisabled, BetaSelectNoSearch } = composeStories(\n    stories,\n);\nlet container: HTMLDivElement;\nconst testClickEvent = vi.fn();\n\nconst testLabelId = 'test-select-label';\nconst testWrapperId = 'test-select';\nconst testSelectButton = 'test-select-button';\nconst testSelectOptions = 'test-select-options';\nconst testSelectDropdownIcon = 'test-select-icon';\nconst testUpIcon = 'close menu';\nconst testDownIcon = 'open menu';\nconst testSearchInput = 'test-select-search-input';\n\nconst testSelectClick = (\n    disabled: boolean,\n    id: string,\n    element: HTMLButtonElement,\n    isOpen = true,\n) => {\n    const startIcon = isOpen ? testDownIcon : testUpIcon;\n    const endIcon = isOpen ? testUpIcon : testDownIcon;\n    expect(screen.getByTestId(testSelectDropdownIcon).textContent).toBe(\n        startIcon,\n    );\n    fireEvent.click(element);\n    expect(screen.getByTestId(testSelectDropdownIcon).textContent).toBe(\n        disabled ? startIcon : endIcon,\n    );\n    const dropdownList = container.querySelector(\n        `[data-testid=\"test-select-options\"]`,\n    );\n    if (!disabled) {\n        expect(dropdownList).not.toBeNull();\n    } else {\n        expect(dropdownList).toBeNull();\n    }\n};\n\ndescribe('Renders - Select Beta', () => {\n    const labelText = BetaSelect?.args?.label;\n\n    beforeEach(() => {\n        container = document.createElement('div');\n\n        render(<BetaSelect onChange={testClickEvent} />, {\n            container: document.body.appendChild(container),\n        });\n    });\n    afterEach(() => {\n        cleanup();\n    });\n\n    it('renders the component', () => {\n        const element = container.querySelector(\n            `[data-testid=\"${testWrapperId}\"]`,\n        );\n        expect(element).not.toBeNull();\n    });\n\n    it('renders label correctly', () => {\n        const element = container.querySelector(\n            `[data-testid=\"${testLabelId}\"]`,\n        );\n        expect(element).not.toBeNull();\n        expect(element?.textContent).toBe(labelText);\n    });\n\n    it('renders dropdown list', () => {\n        const element = container.querySelector(\n            `[data-testid=\"${testSelectButton}\"]`,\n        );\n        testSelectClick(false, testSelectButton, element as HTMLButtonElement);\n    });\n\n    it('renders search box', () => {\n        const element = container.querySelector(\n            `[data-testid=\"${testSelectButton}\"]`,\n        );\n        testSelectClick(false, testSelectButton, element as HTMLButtonElement);\n        const searchInput = container.querySelector(\n            `[data-testid=\"${testSearchInput}\"]`,\n        );\n        expect(searchInput).not.toBeNull();\n    });\n});\n\ndescribe('Renders - Select Beta Disabled', () => {\n    const labelText = BetaSelectDisabled?.args?.label;\n\n    beforeEach(() => {\n        container = document.createElement('div');\n\n        render(<BetaSelectDisabled onChange={testClickEvent} />, {\n            container: document.body.appendChild(container),\n        });\n    });\n    afterEach(() => {\n        cleanup();\n    });\n\n    it('renders the component', () => {\n        const element = container.querySelector(\n            `[data-testid=\"${testWrapperId}\"]`,\n        );\n        expect(element).not.toBeNull();\n    });\n\n    it('renders label correctly', () => {\n        const element = container.querySelector(\n            `[data-testid=\"${testLabelId}\"]`,\n        );\n        expect(element).not.toBeNull();\n        expect(element?.textContent).toBe(labelText);\n    });\n\n    it('renders no dropdown list', () => {\n        const element = container.querySelector(\n            `[data-testid=\"${testSelectButton}\"]`,\n        );\n        testSelectClick(true, testSelectButton, element as HTMLButtonElement);\n    });\n\n    it('renders search box', () => {\n        const element = container.querySelector(\n            `[data-testid=\"${testSelectButton}\"]`,\n        );\n        testSelectClick(true, testSelectButton, element as HTMLButtonElement);\n        const searchInput = container.querySelector(\n            `[data-testid=\"${testSearchInput}\"]`,\n        );\n        expect(searchInput).toBeNull();\n    });\n});\n\ndescribe('Renders - Select Beta No Search', () => {\n    const labelText = BetaSelectNoSearch?.args?.label;\n\n    beforeEach(() => {\n        container = document.createElement('div');\n\n        render(<BetaSelectNoSearch onChange={testClickEvent} />, {\n            container: document.body.appendChild(container),\n        });\n    });\n\n    afterEach(() => {\n        cleanup();\n    });\n\n    it('renders the component', () => {\n        const element = container.querySelector(\n            `[data-testid=\"${testWrapperId}\"]`,\n        );\n        expect(element).not.toBeNull();\n    });\n\n    it('renders label correctly', () => {\n        const element = container.querySelector(\n            `[data-testid=\"${testLabelId}\"]`,\n        );\n        expect(element).not.toBeNull();\n        expect(element?.textContent).toBe(labelText);\n    });\n\n    it('renders dropdown list', () => {\n        const element = container.querySelector(\n            `[data-testid=\"${testSelectButton}\"]`,\n        );\n        testSelectClick(false, testSelectButton, element as HTMLButtonElement);\n    });\n\n    it('renders search box', () => {\n        const element = container.querySelector(\n            `[data-testid=\"${testSelectButton}\"]`,\n        );\n        testSelectClick(false, testSelectButton, element as HTMLButtonElement);\n        const searchInput = container.querySelector(\n            `[data-testid=\"${testSearchInput}\"]`,\n        );\n        // search is hidden test\n        expect(searchInput).toHaveAttribute('aria-hidden', 'true');\n    });\n});", "meta": {"repo": "web3ui/web3uikit", "stars": 1757, "component": "packages/core/src/lib/Select/SelectBeta/SelectBeta.tsx", "test": "packages/core/src/lib/Select/SelectBeta/SelectBeta.test.tsx"}}
{"input": "// Copyright 2020 H2O.ai, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Pivot, PivotItem } from '@fluentui/react'\nimport { B, Model, S, box } from './core'\nimport React from 'react'\nimport { stylesheet } from 'typestyle'\nimport { CardEffect, cards } from './layout'\nimport { Tab } from './tabs'\nimport { bond, wave } from './ui'\n\n/** Create a card containing tabs for navigation. */\ninterface State {\n  /** The tabs to display in this card */\n  items: Tab[]\n  /** The name of the tab to select. */\n  value?: S\n  /** True if tabs should be rendered as links instead of buttons. */\n  link?: B\n  /** An optional name for the card. If provided, the selected tab can be accessed using the name of the card. */\n  name?: S\n}\n\nconst\n  css = stylesheet({\n    card: {\n      display: 'flex',\n      flexDirection: 'column',\n      justifyContent: 'center',\n      minHeight: 46 // HACK: Prevent overflow - https://github.com/h2oai/wave/issues/904.\n    },\n  })\n\nexport const\n  View = bond(({ name, state, changed }: Model<State>) => {\n    const\n      valueB = box<S | undefined>(state.value || state.items[0]?.name),\n      onLinkClick = (item?: PivotItem) => {\n        const name = item?.props.itemKey\n        if (!name || valueB() === name) return\n        state.value = name\n        valueB(name)\n\n        if (name.startsWith('#')) {\n          window.location.hash = name.substring(1)\n          return\n        }\n        if (state.name) wave.args[state.name] = name\n        else wave.args[name] = true\n        wave.push()\n      },\n      render = () => {\n        const\n          linkFormat = state.link ? 'links' : 'tabs',\n          items = state.items.map(({ name, label, icon }) => (\n            <PivotItem key={name} itemKey={name} headerText={label} itemIcon={icon} />\n          ))\n        return (\n          <div data-test={name} className={css.card}>\n            <Pivot linkFormat={linkFormat} onLinkClick={onLinkClick} selectedKey={valueB()}>{items}</Pivot>\n          </div>\n        )\n      },\n      update = (prevProps: Model<State>) => {\n        if (prevProps.state.value !== valueB()) valueB(prevProps.state.value)\n      }\n\n    return { render, changed, update, valueB }\n  })\n\ncards.register('tab', View, { effect: CardEffect.Transparent })", "output": "// Copyright 2020 H2O.ai, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { fireEvent, render } from '@testing-library/react'\nimport * as T from './core'\nimport React from 'react'\nimport { View } from './tab'\nimport { wave } from './ui'\n\nconst\n  name = 'tab',\n  hashName = `#${name}`,\n  items = [{ name: 'tab1' }, { name: 'tab2' }],\n  getProps = (): T.Model<any> => ({\n    name,\n    state: { items },\n    changed: T.box(false)\n  }),\n  pushMock = jest.fn()\n\ndescribe('Tab.tsx', () => {\n  beforeAll(() => {\n    wave.push = pushMock\n  })\n  beforeEach(() => {\n    window.location.hash = ''\n    wave.args = [] as any\n    wave.args[name] = null\n    jest.clearAllMocks()\n  })\n\n  it('Renders data-test attr', () => {\n    const { queryByTestId } = render(<View {...getProps()} />)\n    expect(queryByTestId(name)).toBeInTheDocument()\n  })\n\n  it('Sets args and calls push on click - name is not defined', () => {\n    const { getAllByRole } = render(<View {...getProps()} />)\n    fireEvent.click(getAllByRole('tab')[1])\n\n    expect(wave.args['tab2']).toBe(true)\n    expect(pushMock).toHaveBeenCalledTimes(1)\n  })\n\n  it('Sets args and calls push on click - name is defined', () => {\n    const { getAllByRole } = render(<View {...{ ...getProps(), state: { items, name } }} />)\n    fireEvent.click(getAllByRole('tab')[1])\n\n    expect(wave.args[name]).toBe('tab2')\n    expect(wave.args['tab1']).toBeUndefined()\n    expect(pushMock).toHaveBeenCalledTimes(1)\n  })\n\n  it('Does not call push on click selecting already selected', () => {\n    const { getAllByRole } = render(<View {...getProps()} />)\n    fireEvent.click(getAllByRole('tab')[0])\n\n    expect(pushMock).toHaveBeenCalledTimes(0)\n  })\n\n  it('Does not set args and calls push on click - hash name', () => {\n    const { getByRole } = render(<View {...{ ...getProps(), state: { items: [{ name: hashName }] } }} />)\n    fireEvent.click(getByRole('tab'))\n\n    expect(wave.args[name]).toBeNull()\n    expect(pushMock).toHaveBeenCalledTimes(0)\n  })\n\n  it('Does not set args when value is updated - hash name', () => {\n    const items = [{ name: '#tab1' }, { name: '#tab2' }]\n    const props = { ...getProps(), state: { items, value: '#tab1' } }\n    const { rerender } = render(<View {...props} />)\n    expect(wave.args[name]).toBeNull()\n\n    props.state.value = '#tab2'\n    rerender(<View {...props} />)\n\n    expect(wave.args[name]).toBeNull()\n    expect(pushMock).toHaveBeenCalledTimes(0)\n  })\n\n  it('Selects tab when value is updated', () => {\n    const items = [{ name: 'tab1' }, { name: 'tab2' }]\n    const props = { ...getProps(), state: { items, value: 'tab1' } }\n    const { rerender, getAllByRole } = render(<View {...props} />)\n    expect(getAllByRole('tab')[0]).toHaveClass('is-selected')\n    expect(getAllByRole('tab')[1]).not.toHaveClass('is-selected')\n\n    props.state.value = 'tab2'\n    rerender(<View {...props} />)\n    expect(getAllByRole('tab')[0]).not.toHaveClass('is-selected')\n    expect(getAllByRole('tab')[1]).toHaveClass('is-selected')\n    expect(pushMock).toHaveBeenCalledTimes(0)\n  })\n\n  it('Selects tab when value is updated twice to the same value', () => {\n    const items = [{ name: 'tab1' }, { name: 'tab2' }]\n    const props = { ...getProps(), state: { items, value: 'tab1' } }\n    const { rerender, getAllByRole } = render(<View {...props} />)\n    expect(getAllByRole('tab')[0]).toHaveClass('is-selected')\n    expect(getAllByRole('tab')[1]).not.toHaveClass('is-selected')\n\n    props.state.value = 'tab2'\n    rerender(<View {...props} />)\n    expect(getAllByRole('tab')[0]).not.toHaveClass('is-selected')\n    expect(getAllByRole('tab')[1]).toHaveClass('is-selected')\n    expect(pushMock).toHaveBeenCalledTimes(0)\n\n    fireEvent.click(getAllByRole('tab')[0])\n    expect(getAllByRole('tab')[0]).toHaveClass('is-selected')\n    expect(getAllByRole('tab')[1]).not.toHaveClass('is-selected')\n    expect(pushMock).toHaveBeenCalledTimes(1)\n    pushMock.mockReset()\n\n    props.state.value = 'tab2'\n    rerender(<View {...props} />)\n    expect(getAllByRole('tab')[0]).not.toHaveClass('is-selected')\n    expect(getAllByRole('tab')[1]).toHaveClass('is-selected')\n    expect(pushMock).toHaveBeenCalledTimes(0)\n  })\n\n  it('Selects tab when value is updated - hash name', () => {\n    const items = [{ name: '#tab1' }, { name: '#tab2' }]\n    const props = { ...getProps(), state: { items, value: '#tab1' } }\n    const { rerender, getAllByRole } = render(<View {...props} />)\n    expect(getAllByRole('tab')[0]).toHaveClass('is-selected')\n    expect(getAllByRole('tab')[1]).not.toHaveClass('is-selected')\n\n    props.state.value = '#tab2'\n    rerender(<View {...props} />)\n    expect(getAllByRole('tab')[0]).not.toHaveClass('is-selected')\n    expect(getAllByRole('tab')[1]).toHaveClass('is-selected')\n    expect(pushMock).toHaveBeenCalledTimes(0)\n  })\n\n  it('Selects tab when value is updated twice to the same value - hash name', () => {\n    const items = [{ name: '#tab1' }, { name: '#tab2' }]\n    const props = { ...getProps(), state: { items, value: '#tab1' } }\n    const { rerender, getAllByRole } = render(<View {...props} />)\n    expect(getAllByRole('tab')[0]).toHaveClass('is-selected')\n    expect(getAllByRole('tab')[1]).not.toHaveClass('is-selected')\n\n    props.state.value = '#tab2'\n    rerender(<View {...props} />)\n    expect(getAllByRole('tab')[0]).not.toHaveClass('is-selected')\n    expect(getAllByRole('tab')[1]).toHaveClass('is-selected')\n    expect(pushMock).toHaveBeenCalledTimes(0)\n\n    fireEvent.click(getAllByRole('tab')[0])\n    expect(getAllByRole('tab')[0]).toHaveClass('is-selected')\n    expect(getAllByRole('tab')[1]).not.toHaveClass('is-selected')\n    expect(pushMock).toHaveBeenCalledTimes(0)\n\n    props.state.value = '#tab2'\n    rerender(<View {...props} />)\n    expect(getAllByRole('tab')[0]).not.toHaveClass('is-selected')\n    expect(getAllByRole('tab')[1]).toHaveClass('is-selected')\n    expect(pushMock).toHaveBeenCalledTimes(0)\n  })\n\n  it('Sets url hash - hash name', () => {\n    const { getAllByRole } = render(<View {...{ ...getProps(), state: { items: [{ name: '#hash1' }, { name: hashName }] } }} />)\n    fireEvent.click(getAllByRole('tab')[1])\n\n    expect(window.location.hash).toBe(hashName)\n  })\n\n  it('Sets default tab', () => {\n    const items = [{ name: 'tab1' }, { name: 'tab2' }]\n    const { getAllByRole } = render(<View {...{ ...getProps(), state: { items, value: 'tab2' } }} />)\n\n    expect(getAllByRole('tab')[1]).toHaveClass('is-selected')\n  })\n\n  it('Sets default tab - invalid value', () => {\n    const items = [{ name: 'tab1' }, { name: 'tab2' }]\n    const { getAllByRole } = render(<View {...{ ...getProps(), state: { items, value: 'tab3' } }} />)\n\n    expect(getAllByRole('tab')[0]).toHaveClass('is-selected')\n  })\n\n})", "meta": {"repo": "h2oai/wave", "stars": 4114, "component": "ui/src/tab.tsx", "test": "ui/src/tab.test.tsx"}}
{"input": "/*\nCopyright (c) Uber Technologies, Inc.\n\nThis source code is licensed under the MIT license found in the\nLICENSE file in the root directory of this source tree.\n*/\nimport * as React from 'react';\nimport { getOverrides } from '../helpers/overrides';\nimport { Tab as StyledTab } from './styled-components';\nimport { isFocusVisible, forkFocus, forkBlur } from '../utils/focusVisible';\n\nimport type { TabProps, SharedStylePropsArg } from './types';\n\nimport type { SyntheticEvent } from 'react';\n\nclass TabComponent extends React.Component<\n  TabProps,\n  {\n    isFocusVisible: boolean;\n  }\n> {\n  static defaultProps = {\n    disabled: false,\n    expanded: false,\n    onSelect: () => {},\n    onClick: () => {},\n    onKeyDown: () => {},\n    title: '',\n  };\n\n  state = { isFocusVisible: false };\n\n  handleFocus = (event: SyntheticEvent) => {\n    if (isFocusVisible(event)) {\n      this.setState({ isFocusVisible: true });\n    }\n  };\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  handleBlur = (event: SyntheticEvent) => {\n    if (this.state.isFocusVisible !== false) {\n      this.setState({ isFocusVisible: false });\n    }\n  };\n\n  onClick = (e: Event) => {\n    const { disabled, onSelect, onClick } = this.props;\n    if (disabled) {\n      return;\n    }\n    typeof onClick === 'function' && onClick(e);\n    typeof onSelect === 'function' && onSelect();\n    return;\n  };\n\n  onKeyDown = (e: KeyboardEvent) => {\n    const { disabled, onSelect, onKeyDown } = this.props;\n    if (disabled) {\n      return;\n    }\n    typeof onKeyDown === 'function' && onKeyDown(e);\n    // toggle on Enter or Space button pressed\n    if (e.key === 'Enter' || e.which === 32) {\n      typeof onSelect === 'function' && onSelect();\n      e.which === 32 && e.preventDefault(); // prevent jumping scroll when using Space\n    }\n    return;\n  };\n\n  getSharedProps(): SharedStylePropsArg {\n    const { disabled, active, $orientation } = this.props;\n    return {\n      $disabled: disabled,\n      $active: active,\n      $orientation: $orientation,\n    };\n  }\n\n  render() {\n    const { active, disabled, id, overrides = {}, children } = this.props;\n    const sharedProps = this.getSharedProps();\n    const { Tab: TabOverride } = overrides;\n    const [Tab, tabProps] = getOverrides(TabOverride, StyledTab);\n\n    return (\n      <Tab\n        $isFocusVisible={this.state.isFocusVisible}\n        tabIndex={disabled ? -1 : 0}\n        role=\"tab\"\n        id={id}\n        aria-selected={active}\n        aria-disabled={disabled || null}\n        {...sharedProps}\n        {...tabProps}\n        onFocus={forkFocus(tabProps, this.handleFocus)}\n        onBlur={forkBlur(tabProps, this.handleBlur)}\n        onClick={this.onClick}\n        onKeyDown={this.onKeyDown}\n      >\n        {children}\n      </Tab>\n    );\n  }\n}\n\nexport default TabComponent;", "output": "/*\nCopyright (c) Uber Technologies, Inc.\n\nThis source code is licensed under the MIT license found in the\nLICENSE file in the root directory of this source tree.\n*/\nimport * as React from 'react';\nimport { render, fireEvent, getByRole, getByTestId } from '@testing-library/react';\n\nimport { Tab } from '..';\n\ndescribe('Tab', () => {\n  it('basic rendering', () => {\n    const { container } = render(<Tab active={true}>title</Tab>);\n    const tab = getByRole(container, 'tab');\n    expect(tab.getAttribute('aria-selected')).toBe('true');\n  });\n\n  it('component overrides', () => {\n    const overrides = {\n      // eslint-disable-next-line react/display-name\n      // @ts-ignore\n      Tab: ({ children }) => <span data-testid=\"mock\">{children}</span>,\n    };\n    const { container } = render(<Tab overrides={overrides}>Title</Tab>);\n    getByTestId(container, 'mock');\n  });\n\n  it('onSelect and onClick are called on a click event', () => {\n    const props = {\n      onSelect: jest.fn(),\n      onClick: jest.fn(),\n    };\n    const { container } = render(<Tab {...props}>Title</Tab>);\n    const tab = getByRole(container, 'tab');\n    fireEvent.click(tab);\n    expect(props.onSelect).toHaveBeenCalledTimes(1);\n    expect(props.onClick).toHaveBeenCalledTimes(1);\n  });\n\n  it('onSelect and onKeydown are called on a Enter keydown event', () => {\n    const props = {\n      onSelect: jest.fn(),\n      onKeyDown: jest.fn(),\n    };\n    const { container } = render(<Tab {...props}>Title</Tab>);\n    const tab = getByRole(container, 'tab');\n    fireEvent.keyDown(tab, { key: 'Enter' });\n    expect(props.onSelect).toHaveBeenCalledTimes(1);\n    expect(props.onKeyDown).toHaveBeenCalledTimes(1);\n  });\n\n  it('onClick is not called when the tab is disabled', () => {\n    const props = {\n      onClick: jest.fn(),\n      disabled: true,\n    };\n    const { container } = render(<Tab {...props}>Title</Tab>);\n    const tab = getByRole(container, 'tab');\n    fireEvent.click(tab);\n    expect(props.onClick).not.toHaveBeenCalled();\n  });\n\n  it('onSelect nor onKeydown is not called on key presses when the tab is disabled', () => {\n    const props = {\n      onSelect: jest.fn(),\n      onKeyDown: jest.fn(),\n      disabled: true,\n    };\n    const { container } = render(<Tab {...props}>Title</Tab>);\n    const tab = getByRole(container, 'tab');\n    fireEvent.keyDown(tab, { key: 'Enter' });\n    fireEvent.keyDown(tab, { which: 32 });\n    expect(props.onSelect).not.toHaveBeenCalled();\n    expect(props.onKeyDown).not.toHaveBeenCalled();\n  });\n});", "meta": {"repo": "uber/baseweb", "stars": 8836, "component": "src/tabs/tab.tsx", "test": "src/tabs/__tests__/tab.test.tsx"}}
{"input": "/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0; you may not use this file except in compliance with the Elastic License\n * 2.0.\n */\n\nimport {\n  EuiButtonEmpty,\n  EuiFlexGroup,\n  EuiFlexItem,\n  EuiHorizontalRule,\n  EuiSpacer,\n  EuiText,\n  EuiTitle,\n} from '@elastic/eui';\nimport { FormattedMessage } from '@kbn/i18n-react';\nimport React, { useMemo, type FC } from 'react';\nimport { useIndicatorsFlyoutContext } from '../../hooks/use_flyout_context';\nimport { EMPTY_VALUE } from '../../../../constants/common';\nimport type { Indicator } from '../../../../../../common/threat_intelligence/types/indicator';\nimport { RawIndicatorFieldId } from '../../../../../../common/threat_intelligence/types/indicator';\nimport { unwrapValue } from '../../utils/unwrap_value';\nimport { IndicatorEmptyPrompt } from './empty_prompt';\nimport { IndicatorBlock } from './block';\nimport { HighlightedValuesTable } from './highlighted_values_table';\nimport {\n  INDICATORS_FLYOUT_OVERVIEW_HIGH_LEVEL_BLOCKS,\n  INDICATORS_FLYOUT_OVERVIEW_TABLE,\n  INDICATORS_FLYOUT_OVERVIEW_TITLE,\n} from './test_ids';\n\nconst highLevelFields = [\n  RawIndicatorFieldId.Feed,\n  RawIndicatorFieldId.Type,\n  RawIndicatorFieldId.MarkingTLP,\n  RawIndicatorFieldId.Confidence,\n];\n\nexport interface IndicatorsFlyoutOverviewProps {\n  indicator: Indicator;\n  onViewAllFieldsInTable: VoidFunction;\n}\n\nexport const IndicatorsFlyoutOverview: FC<IndicatorsFlyoutOverviewProps> = ({\n  indicator,\n  onViewAllFieldsInTable,\n}) => {\n  const { indicatorName } = useIndicatorsFlyoutContext();\n\n  const indicatorType = unwrapValue(indicator, RawIndicatorFieldId.Type);\n\n  const highLevelBlocks = useMemo(\n    () => (\n      <EuiFlexGroup data-test-subj={INDICATORS_FLYOUT_OVERVIEW_HIGH_LEVEL_BLOCKS}>\n        {highLevelFields.map((field) => (\n          <EuiFlexItem key={field}>\n            <IndicatorBlock\n              indicator={indicator}\n              field={field}\n              data-test-subj={INDICATORS_FLYOUT_OVERVIEW_HIGH_LEVEL_BLOCKS}\n            />\n          </EuiFlexItem>\n        ))}\n      </EuiFlexGroup>\n    ),\n    [indicator]\n  );\n\n  const indicatorDescription = useMemo(() => {\n    const unwrappedDescription = unwrapValue(indicator, RawIndicatorFieldId.Description);\n\n    return unwrappedDescription ? <EuiText>{unwrappedDescription}</EuiText> : null;\n  }, [indicator]);\n\n  const title =\n    indicatorName != null\n      ? indicatorName\n      : unwrapValue(indicator, RawIndicatorFieldId.Name) || EMPTY_VALUE;\n\n  if (!indicatorType) {\n    return <IndicatorEmptyPrompt />;\n  }\n\n  return (\n    <>\n      <EuiTitle>\n        <h2 data-test-subj={INDICATORS_FLYOUT_OVERVIEW_TITLE}>{title}</h2>\n      </EuiTitle>\n\n      {indicatorDescription}\n\n      <EuiSpacer />\n\n      {highLevelBlocks}\n\n      <EuiHorizontalRule />\n\n      <EuiFlexGroup>\n        <EuiFlexItem>\n          <EuiTitle size=\"xxs\">\n            <h5>\n              <FormattedMessage\n                id=\"xpack.securitySolution.threatIntelligence.indicator.flyoutOverviewTable.highlightedFields\"\n                defaultMessage=\"Highlighted fields\"\n              />\n            </h5>\n          </EuiTitle>\n        </EuiFlexItem>\n        <EuiFlexItem grow={false}>\n          <EuiButtonEmpty onClick={onViewAllFieldsInTable}>\n            <FormattedMessage\n              id=\"xpack.securitySolution.threatIntelligence.indicator.flyoutOverviewTable.viewAllFieldsInTable\"\n              defaultMessage=\"View all fields in table\"\n            />\n          </EuiButtonEmpty>\n        </EuiFlexItem>\n      </EuiFlexGroup>\n\n      <HighlightedValuesTable\n        indicator={indicator}\n        data-test-subj={INDICATORS_FLYOUT_OVERVIEW_TABLE}\n      />\n    </>\n  );\n};", "output": "/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0; you may not use this file except in compliance with the Elastic License\n * 2.0.\n */\n\nimport { TestProvidersComponent } from '../../../../mocks/test_providers';\nimport { render, screen } from '@testing-library/react';\nimport React from 'react';\nimport type { Indicator } from '../../../../../../common/threat_intelligence/types/indicator';\nimport { generateMockIndicator } from '../../../../../../common/threat_intelligence/types/indicator';\nimport { IndicatorsFlyoutOverview } from './overview_tab';\nimport { EMPTY_PROMPT_TEST_ID } from './empty_prompt';\nimport { IndicatorsFlyoutContext } from '../../hooks/use_flyout_context';\nimport {\n  INDICATORS_FLYOUT_OVERVIEW_HIGH_LEVEL_BLOCKS,\n  INDICATORS_FLYOUT_OVERVIEW_TABLE,\n  INDICATORS_FLYOUT_OVERVIEW_TITLE,\n} from './test_ids';\n\ndescribe('<IndicatorsFlyoutOverview />', () => {\n  describe('invalid indicator', () => {\n    it('should render error message on invalid indicator', () => {\n      const context = {\n        kqlBarIntegration: false,\n      };\n\n      render(\n        <TestProvidersComponent>\n          <IndicatorsFlyoutContext.Provider value={context}>\n            <IndicatorsFlyoutOverview\n              onViewAllFieldsInTable={() => {}}\n              indicator={{ fields: {} } as unknown as Indicator}\n            />\n          </IndicatorsFlyoutContext.Provider>\n        </TestProvidersComponent>\n      );\n\n      expect(screen.getByTestId(EMPTY_PROMPT_TEST_ID)).toBeInTheDocument();\n    });\n  });\n\n  it('should render the highlighted blocks and table when valid indicator is passed', () => {\n    const context = {\n      kqlBarIntegration: false,\n    };\n\n    render(\n      <TestProvidersComponent>\n        <IndicatorsFlyoutContext.Provider value={context}>\n          <IndicatorsFlyoutOverview\n            onViewAllFieldsInTable={() => {}}\n            indicator={generateMockIndicator()}\n          />\n        </IndicatorsFlyoutContext.Provider>\n      </TestProvidersComponent>\n    );\n\n    expect(screen.queryByTestId(INDICATORS_FLYOUT_OVERVIEW_TABLE)).toBeInTheDocument();\n    expect(screen.queryByTestId(INDICATORS_FLYOUT_OVERVIEW_HIGH_LEVEL_BLOCKS)).toBeInTheDocument();\n  });\n\n  it('should render the indicator name value in the title', () => {\n    const context = {\n      kqlBarIntegration: false,\n    };\n    const indicator: Indicator = generateMockIndicator();\n    const indicatorName: string = (indicator.fields['threat.indicator.name'] as string[])[0];\n\n    render(\n      <TestProvidersComponent>\n        <IndicatorsFlyoutContext.Provider value={context}>\n          <IndicatorsFlyoutOverview onViewAllFieldsInTable={() => {}} indicator={indicator} />\n        </IndicatorsFlyoutContext.Provider>\n      </TestProvidersComponent>\n    );\n\n    expect(screen.queryByTestId(INDICATORS_FLYOUT_OVERVIEW_TITLE)?.innerHTML).toContain(\n      indicatorName\n    );\n  });\n\n  it('should render the indicator name passed via context in the title', () => {\n    const context = {\n      kqlBarIntegration: false,\n      indicatorName: '123',\n    };\n\n    render(\n      <TestProvidersComponent>\n        <IndicatorsFlyoutContext.Provider value={context}>\n          <IndicatorsFlyoutOverview\n            onViewAllFieldsInTable={() => {}}\n            indicator={generateMockIndicator()}\n          />\n        </IndicatorsFlyoutContext.Provider>\n      </TestProvidersComponent>\n    );\n\n    expect(screen.queryByTestId(INDICATORS_FLYOUT_OVERVIEW_TITLE)?.innerHTML).toContain(\n      context.indicatorName\n    );\n  });\n});", "meta": {"repo": "elastic/kibana", "stars": 20552, "component": "x-pack/solutions/security/plugins/security_solution/public/threat_intelligence/modules/indicators/components/flyout/overview_tab.tsx", "test": "x-pack/solutions/security/plugins/security_solution/public/threat_intelligence/modules/indicators/components/flyout/overview_tab.test.tsx"}}
{"input": "/*\n * SPDX-License-Identifier: Apache-2.0\n *\n * The OpenSearch Contributors require contributions made to\n * this file be licensed under the Apache-2.0 license or a\n * compatible open source license.\n *\n * Any modifications Copyright OpenSearch Contributors. See\n * GitHub history for details.\n */\n\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport React, { PureComponent } from 'react';\nimport { injectI18n, FormattedMessage, InjectedIntlProps } from '@osd/i18n/react';\n\nimport {\n  EuiSmallButton,\n  EuiFlexGroup,\n  EuiFlexItem,\n  EuiCompressedFormRow,\n  EuiPanel,\n  EuiCompressedSelect,\n} from '@elastic/eui';\n\nimport { VisOptionsProps } from 'src/plugins/vis_default_editor/public';\nimport { IIndexPattern } from 'src/plugins/data/public';\nimport { ControlEditor } from './control_editor';\nimport {\n  addControl,\n  moveControl,\n  newControl,\n  removeControl,\n  setControl,\n  ControlParams,\n  CONTROL_TYPES,\n  ControlParamsOptions,\n} from '../../editor_utils';\nimport { getLineageMap, getParentCandidates } from '../../lineage';\nimport { InputControlVisDependencies } from '../../plugin';\n\ninterface ControlsTabUiState {\n  type: CONTROL_TYPES;\n}\n\ninterface ControlsTabUiParams {\n  controls: ControlParams[];\n}\ntype ControlsTabUiInjectedProps = InjectedIntlProps &\n  Pick<VisOptionsProps<ControlsTabUiParams>, 'vis' | 'stateParams' | 'setValue'> & {\n    deps: InputControlVisDependencies;\n  };\n\nexport type ControlsTabUiProps = ControlsTabUiInjectedProps;\n\nclass ControlsTabUi extends PureComponent<ControlsTabUiProps, ControlsTabUiState> {\n  state = {\n    type: CONTROL_TYPES.LIST,\n  };\n\n  getIndexPattern = async (indexPatternId: string): Promise<IIndexPattern> => {\n    const [, startDeps] = await this.props.deps.core.getStartServices();\n    return await startDeps.data.indexPatterns.get(indexPatternId);\n  };\n\n  onChange = (value: ControlParams[]) => this.props.setValue('controls', value);\n\n  handleLabelChange = (controlIndex: number, label: string) => {\n    const updatedControl = {\n      ...this.props.stateParams.controls[controlIndex],\n      label,\n    };\n    this.onChange(setControl(this.props.stateParams.controls, controlIndex, updatedControl));\n  };\n\n  handleIndexPatternChange = (controlIndex: number, indexPattern: string) => {\n    const updatedControl = {\n      ...this.props.stateParams.controls[controlIndex],\n      indexPattern,\n      fieldName: '',\n    };\n    this.onChange(setControl(this.props.stateParams.controls, controlIndex, updatedControl));\n  };\n\n  handleFieldNameChange = (controlIndex: number, fieldName: string) => {\n    const updatedControl = {\n      ...this.props.stateParams.controls[controlIndex],\n      fieldName,\n    };\n    this.onChange(setControl(this.props.stateParams.controls, controlIndex, updatedControl));\n  };\n\n  handleOptionsChange = <T extends keyof ControlParamsOptions>(\n    controlIndex: number,\n    optionName: T,\n    value: ControlParamsOptions[T]\n  ) => {\n    const control = this.props.stateParams.controls[controlIndex];\n    const updatedControl = {\n      ...control,\n      options: {\n        ...control.options,\n        [optionName]: value,\n      },\n    };\n    this.onChange(setControl(this.props.stateParams.controls, controlIndex, updatedControl));\n  };\n\n  handleRemoveControl = (controlIndex: number) => {\n    this.onChange(removeControl(this.props.stateParams.controls, controlIndex));\n  };\n\n  moveControl = (controlIndex: number, direction: number) => {\n    this.onChange(moveControl(this.props.stateParams.controls, controlIndex, direction));\n  };\n\n  handleAddControl = () => {\n    this.onChange(addControl(this.props.stateParams.controls, newControl(this.state.type)));\n  };\n\n  handleParentChange = (controlIndex: number, parent: string) => {\n    const updatedControl = {\n      ...this.props.stateParams.controls[controlIndex],\n      parent,\n    };\n    this.onChange(setControl(this.props.stateParams.controls, controlIndex, updatedControl));\n  };\n\n  renderControls() {\n    const lineageMap = getLineageMap(this.props.stateParams.controls);\n    return this.props.stateParams.controls.map((controlParams, controlIndex) => {\n      const parentCandidates = getParentCandidates(\n        this.props.stateParams.controls,\n        controlParams.id,\n        lineageMap\n      );\n      return (\n        <ControlEditor\n          key={controlParams.id}\n          controlIndex={controlIndex}\n          controlParams={controlParams}\n          handleLabelChange={this.handleLabelChange}\n          moveControl={this.moveControl}\n          handleRemoveControl={this.handleRemoveControl}\n          handleIndexPatternChange={this.handleIndexPatternChange}\n          handleFieldNameChange={this.handleFieldNameChange}\n          getIndexPattern={this.getIndexPattern}\n          handleOptionsChange={this.handleOptionsChange}\n          parentCandidates={parentCandidates}\n          handleParentChange={this.handleParentChange}\n          deps={this.props.deps}\n        />\n      );\n    });\n  }\n\n  render() {\n    const { intl } = this.props;\n\n    return (\n      <div>\n        {this.renderControls()}\n\n        <EuiPanel grow={false}>\n          <EuiFlexGroup>\n            <EuiFlexItem>\n              <EuiCompressedFormRow id=\"selectControlType\">\n                <EuiCompressedSelect\n                  data-test-subj=\"selectControlType\"\n                  options={[\n                    {\n                      value: CONTROL_TYPES.RANGE,\n                      text: intl.formatMessage({\n                        id: 'inputControl.editor.controlsTab.select.rangeDropDownOptionLabel',\n                        defaultMessage: 'Range slider',\n                      }),\n                    },\n                    {\n                      value: CONTROL_TYPES.LIST,\n                      text: intl.formatMessage({\n                        id: 'inputControl.editor.controlsTab.select.listDropDownOptionLabel',\n                        defaultMessage: 'Options list',\n                      }),\n                    },\n                  ]}\n                  value={this.state.type}\n                  onChange={(event) => this.setState({ type: event.target.value as CONTROL_TYPES })}\n                  aria-label={intl.formatMessage({\n                    id: 'inputControl.editor.controlsTab.select.controlTypeAriaLabel',\n                    defaultMessage: 'Select control type',\n                  })}\n                />\n              </EuiCompressedFormRow>\n            </EuiFlexItem>\n            <EuiFlexItem grow={false}>\n              <EuiCompressedFormRow id=\"addControl\">\n                <EuiSmallButton\n                  onClick={this.handleAddControl}\n                  iconType=\"plusInCircle\"\n                  data-test-subj=\"inputControlEditorAddBtn\"\n                  aria-label={intl.formatMessage({\n                    id: 'inputControl.editor.controlsTab.select.addControlAriaLabel',\n                    defaultMessage: 'Add control',\n                  })}\n                >\n                  <FormattedMessage\n                    id=\"inputControl.editor.controlsTab.addButtonLabel\"\n                    defaultMessage=\"Add\"\n                  />\n                </EuiSmallButton>\n              </EuiCompressedFormRow>\n            </EuiFlexItem>\n          </EuiFlexGroup>\n        </EuiPanel>\n      </div>\n    );\n  }\n}\n\nexport const ControlsTab = injectI18n(ControlsTabUi);\n\nexport const getControlsTab = (deps: InputControlVisDependencies) => (\n  props: Omit<ControlsTabUiProps, 'core'>\n) => <ControlsTab {...props} deps={deps} />;", "output": "/*\n * SPDX-License-Identifier: Apache-2.0\n *\n * The OpenSearch Contributors require contributions made to\n * this file be licensed under the Apache-2.0 license or a\n * compatible open source license.\n *\n * Any modifications Copyright OpenSearch Contributors. See\n * GitHub history for details.\n */\n\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport React from 'react';\nimport { shallowWithIntl, mountWithIntl } from 'test_utils/enzyme_helpers';\nimport { findTestSubject } from 'test_utils/helpers';\nimport { getDepsMock, getIndexPatternMock } from '../../test_utils';\nimport { ControlsTab, ControlsTabUiProps } from './controls_tab';\nimport { Vis } from '../../../../visualizations/public';\n\nconst indexPatternsMock = {\n  get: getIndexPatternMock,\n};\nlet props: ControlsTabUiProps;\n\nbeforeEach(() => {\n  props = {\n    deps: getDepsMock(),\n    vis: ({\n      API: {\n        indexPatterns: indexPatternsMock,\n      },\n      type: {\n        name: 'test',\n        title: 'test',\n        visualization: null,\n        requestHandler: 'test',\n        responseHandler: 'test',\n        stage: 'beta',\n        requiresSearch: false,\n        hidden: false,\n      },\n    } as unknown) as Vis,\n    stateParams: {\n      controls: [\n        {\n          id: '1',\n          indexPattern: 'indexPattern1',\n          fieldName: 'keywordField',\n          label: 'custom label',\n          type: 'list',\n          options: {\n            type: 'terms',\n            multiselect: true,\n            size: 5,\n            order: 'desc',\n          },\n          parent: 'parent',\n        },\n        {\n          id: '2',\n          indexPattern: 'indexPattern1',\n          fieldName: 'numberField',\n          label: '',\n          type: 'range',\n          options: {\n            step: 1,\n          },\n          parent: 'parent',\n        },\n      ],\n    },\n    setValue: jest.fn(),\n    intl: null as any,\n  };\n});\n\ntest('renders ControlsTab', () => {\n  const component = shallowWithIntl(<ControlsTab.WrappedComponent {...props} />);\n\n  expect(component).toMatchSnapshot();\n});\n\ndescribe('behavior', () => {\n  test('add control button', () => {\n    const component = mountWithIntl(<ControlsTab.WrappedComponent {...props} />);\n\n    findTestSubject(component, 'inputControlEditorAddBtn').simulate('click');\n\n    // // Use custom match function since control.id is dynamically generated and never the same.\n    expect(props.setValue).toHaveBeenCalledWith(\n      'controls',\n      expect.arrayContaining(props.stateParams.controls)\n    );\n    expect((props.setValue as jest.Mock).mock.calls[0][1].length).toEqual(3);\n  });\n\n  test('remove control button', () => {\n    const component = mountWithIntl(<ControlsTab.WrappedComponent {...props} />);\n    findTestSubject(component, 'inputControlEditorRemoveControl0').simulate('click');\n    const expectedParams = [\n      'controls',\n      [\n        {\n          id: '2',\n          indexPattern: 'indexPattern1',\n          fieldName: 'numberField',\n          label: '',\n          type: 'range',\n          parent: 'parent',\n          options: {\n            step: 1,\n          },\n        },\n      ],\n    ];\n\n    expect(props.setValue).toHaveBeenCalledWith(...expectedParams);\n  });\n\n  test('move down control button', () => {\n    const component = mountWithIntl(<ControlsTab.WrappedComponent {...props} />);\n    findTestSubject(component, 'inputControlEditorMoveDownControl0').simulate('click');\n    const expectedParams = [\n      'controls',\n      [\n        {\n          id: '2',\n          indexPattern: 'indexPattern1',\n          fieldName: 'numberField',\n          label: '',\n          type: 'range',\n          parent: 'parent',\n          options: {\n            step: 1,\n          },\n        },\n        {\n          id: '1',\n          indexPattern: 'indexPattern1',\n          fieldName: 'keywordField',\n          label: 'custom label',\n          type: 'list',\n          parent: 'parent',\n          options: {\n            type: 'terms',\n            multiselect: true,\n            size: 5,\n            order: 'desc',\n          },\n        },\n      ],\n    ];\n\n    expect(props.setValue).toHaveBeenCalledWith(...expectedParams);\n  });\n\n  test('move up control button', () => {\n    const component = mountWithIntl(<ControlsTab.WrappedComponent {...props} />);\n    findTestSubject(component, 'inputControlEditorMoveUpControl1').simulate('click');\n    const expectedParams = [\n      'controls',\n      [\n        {\n          id: '2',\n          indexPattern: 'indexPattern1',\n          fieldName: 'numberField',\n          label: '',\n          type: 'range',\n          parent: 'parent',\n          options: {\n            step: 1,\n          },\n        },\n        {\n          id: '1',\n          indexPattern: 'indexPattern1',\n          fieldName: 'keywordField',\n          label: 'custom label',\n          type: 'list',\n          parent: 'parent',\n          options: {\n            type: 'terms',\n            multiselect: true,\n            size: 5,\n            order: 'desc',\n          },\n        },\n      ],\n    ];\n\n    expect(props.setValue).toHaveBeenCalledWith(...expectedParams);\n  });\n});", "meta": {"repo": "opensearch-project/OpenSearch-Dashboards", "stars": 1844, "component": "src/plugins/input_control_vis/public/components/editor/controls_tab.tsx", "test": "src/plugins/input_control_vis/public/components/editor/controls_tab.test.tsx"}}
{"input": "/*\n * Copyright 2021 The Kubeflow Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport React from 'react';\nimport { useQuery } from 'react-query';\nimport { Link } from 'react-router-dom';\nimport { ErrorBoundary } from 'src/atoms/ErrorBoundary';\nimport { commonCss, padding } from 'src/Css';\nimport { KeyValue } from 'src/lib/StaticGraphParser';\nimport { getMetadataValue } from 'src/mlmd/library';\nimport {\n  filterEventWithInputArtifact,\n  filterEventWithOutputArtifact,\n  getArtifactName,\n  getArtifactTypeName,\n  getArtifactTypes,\n  getLinkedArtifactsByExecution,\n  getStoreSessionInfoFromArtifact,\n  LinkedArtifact,\n} from 'src/mlmd/MlmdUtils';\nimport { ArtifactType, Execution } from 'src/third_party/mlmd';\nimport ArtifactPreview from '../ArtifactPreview';\nimport Banner from '../Banner';\nimport DetailsTable from '../DetailsTable';\nimport { RoutePageFactory } from '../Router';\nimport { ExecutionTitle } from './ExecutionTitle';\n\nexport type ParamList = Array<KeyValue<string>>;\nexport type URIToSessionInfo = Map<string, string | undefined>;\nexport interface ArtifactParamsWithSessionInfo {\n  params: ParamList;\n  sessionMap: URIToSessionInfo;\n}\n\nexport interface ArtifactLocation {\n  uri: string;\n  store_session_info: string | undefined;\n}\n\nexport interface IOTabProps {\n  execution: Execution;\n  namespace: string | undefined;\n}\n\nexport function InputOutputTab({ execution, namespace }: IOTabProps) {\n  const executionId = execution.getId();\n\n  // TODO(jlyaoyuli): Showing input/output parameter for unexecuted node (retrieves from PipelineSpec).\n  // TODO(jlyaoyuli): Display other information (container, args, image, command)\n\n  // Retrieves input and output artifacts from Metadata store.\n  const { isSuccess, error, data: linkedArtifacts } = useQuery<LinkedArtifact[], Error>(\n    ['execution_artifact', { id: executionId, state: execution.getLastKnownState() }],\n    () => getLinkedArtifactsByExecution(execution),\n    { staleTime: Infinity },\n  );\n\n  const { data: artifactTypes } = useQuery<ArtifactType[], Error>(\n    ['artifact_types', { linkedArtifact: linkedArtifacts }],\n    () => getArtifactTypes(),\n    {},\n  );\n\n  const artifactTypeNames =\n    linkedArtifacts && artifactTypes ? getArtifactTypeName(artifactTypes, linkedArtifacts) : [];\n\n  // Restructs artifacts and parameters for visualization.\n  const inputParams = extractInputFromExecution(execution);\n  const outputParams = extractOutputFromExecution(execution);\n  let inputArtifactsWithSessionInfo: ArtifactParamsWithSessionInfo | undefined;\n  let outputArtifactsWithSessionInfo: ArtifactParamsWithSessionInfo | undefined;\n  if (isSuccess && linkedArtifacts) {\n    inputArtifactsWithSessionInfo = getArtifactParamList(\n      filterEventWithInputArtifact(linkedArtifacts),\n      artifactTypeNames,\n    );\n    outputArtifactsWithSessionInfo = getArtifactParamList(\n      filterEventWithOutputArtifact(linkedArtifacts),\n      artifactTypeNames,\n    );\n  }\n\n  let inputArtifacts: ParamList = [];\n  let outputArtifacts: ParamList = [];\n\n  if (inputArtifactsWithSessionInfo) {\n    inputArtifacts = inputArtifactsWithSessionInfo.params;\n  }\n\n  if (outputArtifactsWithSessionInfo) {\n    outputArtifacts = outputArtifactsWithSessionInfo.params;\n  }\n\n  let isIoEmpty = false;\n  if (\n    inputParams.length === 0 &&\n    outputParams.length === 0 &&\n    inputArtifacts.length === 0 &&\n    outputArtifacts.length === 0\n  ) {\n    isIoEmpty = true;\n  }\n\n  return (\n    <ErrorBoundary>\n      <div className={commonCss.page}>\n        <div className={padding(20)}>\n          <ExecutionTitle execution={execution} />\n\n          {error && (\n            <Banner\n              message='Error in retrieving Artifacts.'\n              mode='error'\n              additionalInfo={error.message}\n            />\n          )}\n\n          {isSuccess && isIoEmpty && (\n            <Banner message='There is no input/output parameter or artifact.' mode='info' />\n          )}\n\n          {inputParams.length > 0 && (\n            <div>\n              <DetailsTable\n                key={`input-parameters-${executionId}`}\n                title='Input Parameters'\n                fields={inputParams}\n              />\n            </div>\n          )}\n\n          {inputArtifacts.length > 0 && (\n            <div>\n              <DetailsTable<string>\n                key={`input-artifacts-${executionId}`}\n                title='Input Artifacts'\n                fields={inputArtifacts}\n                valueComponent={ArtifactPreview}\n                valueComponentProps={{\n                  namespace: namespace,\n                  sessionMap: inputArtifactsWithSessionInfo?.sessionMap,\n                }}\n              />\n            </div>\n          )}\n\n          {outputParams.length > 0 && (\n            <div>\n              <DetailsTable\n                key={`output-parameters-${executionId}`}\n                title='Output Parameters'\n                fields={outputParams}\n              />\n            </div>\n          )}\n\n          {outputArtifacts.length > 0 && (\n            <div>\n              <DetailsTable<string>\n                key={`output-artifacts-${executionId}`}\n                title='Output Artifacts'\n                fields={outputArtifacts}\n                valueComponent={ArtifactPreview}\n                valueComponentProps={{\n                  namespace: namespace,\n                  sessionMap: outputArtifactsWithSessionInfo?.sessionMap,\n                }}\n              />\n            </div>\n          )}\n        </div>\n      </div>\n    </ErrorBoundary>\n  );\n}\n\nexport default InputOutputTab;\n\nfunction extractInputFromExecution(execution: Execution): KeyValue<string>[] {\n  return extractParamFromExecution(execution, 'inputs');\n}\n\nfunction extractOutputFromExecution(execution: Execution): KeyValue<string>[] {\n  return extractParamFromExecution(execution, 'outputs');\n}\n\nfunction extractParamFromExecution(execution: Execution, name: string): KeyValue<string>[] {\n  const result: KeyValue<string>[] = [];\n  execution.getCustomPropertiesMap().forEach((value, key) => {\n    if (key === name) {\n      const param = getMetadataValue(value);\n      if (typeof param == 'object') {\n        Object.entries(param.toJavaScript()).forEach(parameter => {\n          result.push([parameter[0], JSON.stringify(parameter[1])]);\n        });\n      }\n    }\n  });\n  return result;\n}\n\nexport function getArtifactParamList(\n  inputArtifacts: LinkedArtifact[],\n  artifactTypeNames: string[],\n): ArtifactParamsWithSessionInfo {\n  let sessMap: URIToSessionInfo = new Map<string, string | undefined>();\n\n  let params = Object.values(inputArtifacts).map((linkedArtifact, index) => {\n    let key = getArtifactName(linkedArtifact);\n    if (\n      key &&\n      (artifactTypeNames[index] === 'system.Metrics' ||\n        artifactTypeNames[index] === 'system.ClassificationMetrics')\n    ) {\n      key += ' (This is an empty file by default)';\n    }\n    const artifactId = linkedArtifact.artifact.getId();\n    const artifactElement = RoutePageFactory.artifactDetails(artifactId) ? (\n      <Link className={commonCss.link} to={RoutePageFactory.artifactDetails(artifactId)}>\n        {key}\n      </Link>\n    ) : (\n      key\n    );\n\n    const uri = linkedArtifact.artifact.getUri();\n    const sessInfo = getStoreSessionInfoFromArtifact(linkedArtifact);\n    sessMap.set(uri, sessInfo);\n\n    return [artifactElement, uri];\n  });\n\n  return { params: params, sessionMap: sessMap };\n}", "output": "/*\n * Copyright 2021 The Kubeflow Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { render, screen, waitFor } from '@testing-library/react';\nimport { Struct } from 'google-protobuf/google/protobuf/struct_pb';\nimport React from 'react';\nimport { Apis } from 'src/lib/Apis';\nimport { Api } from 'src/mlmd/library';\nimport { testBestPractices } from 'src/TestUtils';\nimport { CommonTestWrapper } from 'src/TestWrapper';\nimport {\n  Artifact,\n  Event,\n  Execution,\n  GetArtifactsByIDResponse,\n  GetEventsByExecutionIDsResponse,\n  Value,\n} from 'src/third_party/mlmd';\nimport InputOutputTab from './InputOutputTab';\n\nconst executionName = 'fake-execution';\nconst artifactId = 100;\nconst artifactUri = 'gs://bucket/test';\nconst artifactUriView = 'gs://bucket/test';\nconst inputArtifactName = 'input_artifact';\nconst outputArtifactName = 'output_artifact';\nconst namespace = 'namespace';\n\ntestBestPractices();\ndescribe('InoutOutputTab', () => {\n  it('shows execution title', () => {\n    jest\n      .spyOn(Api.getInstance().metadataStoreService, 'getEventsByExecutionIDs')\n      .mockResolvedValue(new GetEventsByExecutionIDsResponse());\n    jest\n      .spyOn(Api.getInstance().metadataStoreService, 'getArtifactsByID')\n      .mockReturnValue(new GetArtifactsByIDResponse());\n\n    render(\n      <CommonTestWrapper>\n        <InputOutputTab execution={buildBasicExecution()} namespace={namespace}></InputOutputTab>\n      </CommonTestWrapper>,\n    );\n    screen.getByText(executionName, { selector: 'a', exact: false });\n  });\n\n  it(\"doesn't show Input/Output artifacts and parameters if no exists\", async () => {\n    jest\n      .spyOn(Api.getInstance().metadataStoreService, 'getEventsByExecutionIDs')\n      .mockResolvedValue(new GetEventsByExecutionIDsResponse());\n    jest\n      .spyOn(Api.getInstance().metadataStoreService, 'getArtifactsByID')\n      .mockReturnValue(new GetArtifactsByIDResponse());\n\n    render(\n      <CommonTestWrapper>\n        <InputOutputTab execution={buildBasicExecution()} namespace={namespace}></InputOutputTab>\n      </CommonTestWrapper>,\n    );\n    await waitFor(() => screen.queryAllByText('Input Parameters').length == 0);\n    await waitFor(() => screen.queryAllByText('Input Artifacts').length == 0);\n    await waitFor(() => screen.queryAllByText('Output Parameters').length == 0);\n    await waitFor(() => screen.queryAllByText('Output Artifacts').length == 0);\n    await waitFor(() => screen.getByText('There is no input/output parameter or artifact.'));\n  });\n\n  it('shows Input parameters with various types', async () => {\n    jest\n      .spyOn(Api.getInstance().metadataStoreService, 'getEventsByExecutionIDs')\n      .mockResolvedValue(new GetEventsByExecutionIDsResponse());\n    jest\n      .spyOn(Api.getInstance().metadataStoreService, 'getArtifactsByID')\n      .mockReturnValue(new GetArtifactsByIDResponse());\n\n    const execution = buildBasicExecution();\n    execution\n      .getCustomPropertiesMap()\n      .set('thisKeyIsNotInput', new Value().setStringValue(\"value shouldn't show\"));\n    execution.getCustomPropertiesMap().set(\n      'inputs',\n      new Value().setStructValue(\n        Struct.fromJavaScript({\n          'stringKey: example string': 0,\n          'intKey: 123': 1,\n          'doubleKey: 1.23': 2,\n          'listKey: [1,2,3]': 3,\n          'structKey: {a:1, b:2}': 4,\n        }),\n      ),\n    );\n\n    render(\n      <CommonTestWrapper>\n        <InputOutputTab execution={execution} namespace={namespace}></InputOutputTab>\n      </CommonTestWrapper>,\n    );\n\n    screen.getByText('stringKey: example string');\n    screen.getByText('intKey: 123');\n    screen.getByText('doubleKey: 1.23');\n    screen.getByText('listKey: [1,2,3]');\n    screen.getByText('structKey: {a:1, b:2}');\n    expect(screen.queryByText('thisKeyIsNotInput')).toBeNull();\n  });\n\n  it('shows Output parameters with various types', async () => {\n    jest\n      .spyOn(Api.getInstance().metadataStoreService, 'getEventsByExecutionIDs')\n      .mockResolvedValue(new GetEventsByExecutionIDsResponse());\n    jest\n      .spyOn(Api.getInstance().metadataStoreService, 'getArtifactsByID')\n      .mockReturnValue(new GetArtifactsByIDResponse());\n\n    const execution = buildBasicExecution();\n    execution\n      .getCustomPropertiesMap()\n      .set('thisKeyIsNotOutput', new Value().setStringValue(\"value shouldn't show\"));\n    execution.getCustomPropertiesMap().set(\n      'outputs',\n      new Value().setStructValue(\n        Struct.fromJavaScript({\n          'stringKey: example string': 0,\n          'intKey: 123': 1,\n          'doubleKey: 1.23': 2,\n          'listKey: [1,2,3]': 3,\n          'structKey: {a:1, b:2}': 4,\n        }),\n      ),\n    );\n\n    render(\n      <CommonTestWrapper>\n        <InputOutputTab execution={execution} namespace={namespace}></InputOutputTab>\n      </CommonTestWrapper>,\n    );\n\n    screen.getByText('stringKey: example string');\n    screen.getByText('intKey: 123');\n    screen.getByText('doubleKey: 1.23');\n    screen.getByText('listKey: [1,2,3]');\n    screen.getByText('structKey: {a:1, b:2}');\n    expect(screen.queryByText('thisKeyIsNotOutput')).toBeNull();\n  });\n\n  it('shows Input artifacts', async () => {\n    jest.spyOn(Apis, 'readFile').mockResolvedValue('artifact preview');\n    const getEventResponse = new GetEventsByExecutionIDsResponse();\n    getEventResponse.getEventsList().push(buildInputEvent());\n    jest\n      .spyOn(Api.getInstance().metadataStoreService, 'getEventsByExecutionIDs')\n      .mockResolvedValueOnce(getEventResponse);\n    const getArtifactsResponse = new GetArtifactsByIDResponse();\n    getArtifactsResponse.getArtifactsList().push(buildArtifact());\n    jest\n      .spyOn(Api.getInstance().metadataStoreService, 'getArtifactsByID')\n      .mockReturnValueOnce(getArtifactsResponse);\n\n    render(\n      <CommonTestWrapper>\n        <InputOutputTab execution={buildBasicExecution()} namespace={namespace}></InputOutputTab>\n      </CommonTestWrapper>,\n    );\n\n    await waitFor(() => screen.getByText(artifactUriView));\n    await waitFor(() => screen.getByText(inputArtifactName));\n  });\n\n  it('shows Output artifacts', async () => {\n    jest.spyOn(Apis, 'readFile').mockResolvedValue('artifact preview');\n    const getEventResponse = new GetEventsByExecutionIDsResponse();\n    getEventResponse.getEventsList().push(buildOutputEvent());\n    jest\n      .spyOn(Api.getInstance().metadataStoreService, 'getEventsByExecutionIDs')\n      .mockResolvedValueOnce(getEventResponse);\n    const getArtifactsResponse = new GetArtifactsByIDResponse();\n    getArtifactsResponse.getArtifactsList().push(buildArtifact());\n    jest\n      .spyOn(Api.getInstance().metadataStoreService, 'getArtifactsByID')\n      .mockReturnValueOnce(getArtifactsResponse);\n\n    render(\n      <CommonTestWrapper>\n        <InputOutputTab execution={buildBasicExecution()} namespace={namespace}></InputOutputTab>\n      </CommonTestWrapper>,\n    );\n\n    await waitFor(() => screen.getByText(artifactUriView));\n    await waitFor(() => screen.getByText(outputArtifactName));\n  });\n});\n\nfunction buildBasicExecution() {\n  const execution = new Execution();\n  const executionId = 123;\n\n  execution.setId(executionId);\n  execution.getCustomPropertiesMap().set('task_name', new Value().setStringValue(executionName));\n\n  return execution;\n}\n\nfunction buildArtifact() {\n  const artifact = new Artifact();\n  artifact.getCustomPropertiesMap();\n  artifact.setUri(artifactUri);\n  artifact.setId(artifactId);\n  return artifact;\n}\n\nfunction buildInputEvent() {\n  const event = new Event();\n  const path = new Event.Path();\n  path.getStepsList().push(new Event.Path.Step().setKey(inputArtifactName));\n  event\n    .setType(Event.Type.INPUT)\n    .setArtifactId(artifactId)\n    .setPath(path);\n  return event;\n}\n\nfunction buildOutputEvent() {\n  const event = new Event();\n  const path = new Event.Path();\n  path.getStepsList().push(new Event.Path.Step().setKey(outputArtifactName));\n  event\n    .setType(Event.Type.OUTPUT)\n    .setArtifactId(artifactId)\n    .setPath(path);\n  return event;\n}", "meta": {"repo": "kubeflow/pipelines", "stars": 3868, "component": "frontend/src/components/tabs/InputOutputTab.tsx", "test": "frontend/src/components/tabs/InputOutputTab.test.tsx"}}
{"input": "import {Component, ComponentClass, ComponentType} from 'react';\n\nimport getUID from '../global/get-uid';\n\nimport Shortcuts from './shortcuts';\nimport {ShortcutsMap, ShortcutsScopeOptions} from './core';\n\nexport interface ShortcutsHOCOptions extends ShortcutsScopeOptions {\n  disabled?: boolean | null | undefined;\n}\n\nexport interface ShortcutsHOCProps {\n  rgShortcutsOptions: ShortcutsHOCOptions;\n  rgShortcutsMap: ShortcutsMap;\n}\n\nexport default function shortcutsHOC<P extends {}>(\n  ComposedComponent: ComponentType<P> | string,\n): ComponentClass<P & ShortcutsHOCProps> {\n  return class WithShortcuts extends Component<P & ShortcutsHOCProps> {\n    _shortcutsScopeUid = getUID('rg-shortcuts-');\n\n    render() {\n      const {rgShortcutsOptions, rgShortcutsMap, ...props} = this.props;\n\n      return (\n        <Shortcuts\n          scope={this._shortcutsScopeUid}\n          map={rgShortcutsMap}\n          options={rgShortcutsOptions}\n          disabled={rgShortcutsOptions.disabled}\n        >\n          <ComposedComponent {...(props as unknown as P)} />\n        </Shortcuts>\n      );\n    }\n  };\n}", "output": "import {render} from '@testing-library/react';\n\nimport simulateCombo from '../../test-helpers/simulate-combo';\n\nimport {ShortcutsMap} from './core';\n\nimport shortcutsHOC, {ShortcutsHOCOptions} from './shortcuts-hoc';\n\ninterface FactoryProps {\n  options: ShortcutsHOCOptions;\n  map: ShortcutsMap;\n}\n\ndescribe('ShortcutsHOC', () => {\n  describe('default', () => {\n    const InputWithShortcuts = shortcutsHOC('input');\n\n    const createShortcutsMap = (): FactoryProps => ({\n      options: {},\n      map: {enter: vi.fn()},\n    });\n\n    const renderInputWithShortcuts = (shortcuts: FactoryProps) => {\n      return render(<InputWithShortcuts rgShortcutsOptions={shortcuts.options} rgShortcutsMap={shortcuts.map} />);\n    };\n\n    it('should initialize', () => {\n      const shortcuts = createShortcutsMap();\n      const {container} = renderInputWithShortcuts(shortcuts);\n      expect(container).to.exist;\n    });\n\n    it('should call shortcut handler', () => {\n      const shortcuts = createShortcutsMap();\n      renderInputWithShortcuts(shortcuts);\n      simulateCombo('enter');\n\n      expect(shortcuts.map.enter).toHaveBeenCalled();\n    });\n\n    it('should disable shortcuts', () => {\n      const shortcuts = createShortcutsMap();\n      shortcuts.options.disabled = true;\n\n      renderInputWithShortcuts(shortcuts);\n\n      simulateCombo('enter');\n\n      expect(shortcuts.map.enter).not.toHaveBeenCalled();\n    });\n  });\n});", "meta": {"repo": "JetBrains/ring-ui", "stars": 3702, "component": "src/shortcuts/shortcuts-hoc.tsx", "test": "src/shortcuts/shortcuts-hoc.test.tsx"}}
{"input": "import * as React from 'react';\nimport { Props as FeatureProps } from './feature';\nimport { generateID } from './util/uid';\nimport { LayerCommonProps, Props as LayerProps } from './layer';\nimport { Map } from 'mapbox-gl';\n\nexport interface EnhancedLayerProps {\n  id?: string;\n  map: Map;\n}\n\nexport type OwnProps = EnhancedLayerProps & LayerCommonProps;\n\ntype LayerChildren = React.ReactElement<FeatureProps> | undefined;\n\nexport function layerMouseTouchEvents(\n  WrappedComponent: React.ComponentClass<LayerProps>\n) {\n  return class EnhancedLayer extends React.Component<OwnProps> {\n    public hover: number[] = [];\n    public draggedChildren:\n      | Array<React.ReactElement<FeatureProps>>\n      | undefined = undefined;\n\n    public id: string = this.props.id || `layer-${generateID()}`;\n\n    public getChildren = () =>\n      ([] as LayerChildren[])\n        .concat(this.props.children)\n        .filter(\n          (el): el is React.ReactElement<FeatureProps> =>\n            typeof el !== 'undefined'\n        );\n    public getChildFromId = (\n      children: Array<React.ReactElement<FeatureProps>>,\n      id: number\n    ) => children[id];\n\n    public areFeaturesDraggable = (\n      children: Array<React.ReactElement<FeatureProps>>,\n      featureIds: number[] = this.hover\n    ) =>\n      !!featureIds\n        .map(\n          id =>\n            this.getChildFromId(children, id)\n              ? this.getChildFromId(children, id)!.props.draggable\n              : false\n        )\n        .filter(Boolean).length;\n\n    // tslint:disable-next-line:no-any\n    public onClick = (evt: any) => {\n      const features = evt.features as Array<\n        GeoJSON.Feature<GeoJSON.GeometryObject, { id: number }>\n      >;\n      const children = this.getChildren();\n\n      const { map } = this.props;\n\n      if (features) {\n        features.forEach(feature => {\n          const { id } = feature.properties;\n          if (children) {\n            const child = this.getChildFromId(children, id);\n\n            const onClick = child && child.props.onClick;\n            if (onClick) {\n              onClick({ ...evt, feature, map });\n            }\n          }\n        });\n      }\n    };\n\n    // tslint:disable-next-line:no-any\n    public onMouseEnter = (evt: any) => {\n      const children = this.getChildren();\n\n      const { map } = this.props;\n      this.hover = [];\n\n      evt.features.forEach(\n        (feature: GeoJSON.Feature<GeoJSON.GeometryObject, { id: number }>) => {\n          const { id } = feature.properties;\n          const child = this.getChildFromId(children, id);\n          this.hover.push(id);\n\n          const onMouseEnter = child && child.props.onMouseEnter;\n          if (onMouseEnter) {\n            onMouseEnter({ ...evt, feature, map });\n          }\n        }\n      );\n\n      if (this.areFeaturesDraggable(children)) {\n        map.dragPan.disable();\n      }\n    };\n\n    // tslint:disable-next-line:no-any\n    public onMouseLeave = (evt: any) => {\n      const children = this.getChildren();\n      const { map } = this.props;\n      if (this.areFeaturesDraggable(children)) {\n        map.dragPan.enable();\n      }\n\n      this.hover.forEach(id => {\n        const child = this.getChildFromId(children, id);\n        const onMouseLeave = child && child.props.onMouseLeave;\n        if (onMouseLeave) {\n          onMouseLeave({ ...evt, map });\n        }\n      });\n\n      if (!this.draggedChildren) {\n        this.hover = [];\n      }\n    };\n\n    public onMouseDown = () => {\n      // User did this on a feature\n      if (this.hover.length) {\n        this.onFeatureDown('mousedown');\n      }\n    };\n\n    // tslint:disable-next-line:no-any\n    public onTouchStart = (evt: any) => {\n      // tslint:disable-next-line:no-any\n      this.hover = evt.features.map((feature: any) => feature.properties.id);\n\n      if (this.hover.length) {\n        this.onFeatureDown('touchstart');\n      }\n    };\n\n    public onFeatureDown = (startEvent: string) => {\n      const moveEvent = startEvent === 'mousedown' ? 'mousemove' : 'touchmove';\n      const endEvent = startEvent === 'mousedown' ? 'mouseup' : 'touchend';\n      const { map } = this.props;\n\n      map.once(moveEvent, this.onFeatureDragStart);\n      map.on(moveEvent, this.onFeatureDrag);\n\n      // tslint:disable-next-line:no-any\n      map.once(endEvent, (evt: any) => {\n        map.off(moveEvent, this.onFeatureDragStart);\n        map.off(moveEvent, this.onFeatureDrag);\n        this.onFeatureDragEnd(evt);\n      });\n    };\n\n    // tslint:disable-next-line:no-any\n    public onFeatureDragStart = (evt: any) => {\n      const { map } = this.props;\n      const children = this.getChildren();\n\n      this.hover.forEach(id => {\n        const child = this.getChildFromId(children, id);\n        if (child && !child.props.draggable) {\n          return;\n        }\n\n        const onDragStart = child && child.props.onDragStart;\n        if (onDragStart) {\n          onDragStart({ ...evt, map });\n        }\n      });\n    };\n\n    // tslint:disable-next-line:no-any\n    public onFeatureDrag = (evt: any) => {\n      const children = this.getChildren();\n      const { map } = this.props;\n      const { lngLat: { lng, lat } } = evt;\n      this.draggedChildren = [];\n\n      this.hover.forEach(id => {\n        const child = this.getChildFromId(children, id);\n        const onDrag = child && child.props.onDrag;\n\n        // drag children if draggable\n        if (child && child.props.draggable) {\n          this.draggedChildren!.push(\n            React.cloneElement(child, {\n              coordinates: [lng, lat]\n            })\n          );\n\n          if (onDrag) {\n            onDrag({ ...evt, map });\n          }\n        }\n      });\n\n      this.forceUpdate();\n    };\n\n    // tslint:disable-next-line:no-any\n    public onFeatureDragEnd = (evt: any) => {\n      const { map } = this.props;\n      const children = this.getChildren();\n\n      this.hover.forEach(id => {\n        const child = this.getChildFromId(children, id);\n        const onDragEnd = child && child.props.onDragEnd;\n\n        if (onDragEnd && child!.props.draggable && this.draggedChildren) {\n          onDragEnd({ ...evt, map });\n        }\n      });\n\n      this.draggedChildren = undefined;\n    };\n\n    public componentDidMount() {\n      const { map } = this.props;\n\n      map.on('click', this.id, this.onClick);\n      map.on('mouseenter', this.id, this.onMouseEnter);\n      map.on('mouseleave', this.id, this.onMouseLeave);\n      map.on('mousedown', this.id, this.onMouseDown);\n      map.on('touchstart', this.id, this.onTouchStart);\n    }\n\n    public componentWillUnmount() {\n      const { map } = this.props;\n\n      map.off('click', this.onClick);\n      map.off('mouseenter', this.onMouseEnter);\n      map.off('mouseleave', this.onMouseLeave);\n      map.off('mousedown', this.onMouseDown);\n      map.off('touchstart', this.onTouchStart);\n    }\n\n    public render() {\n      return (\n        <WrappedComponent\n          {...this.props}\n          id={this.id}\n          map={this.props.map}\n          draggedChildren={this.draggedChildren}\n        />\n      );\n    }\n  };\n}\n\nexport default layerMouseTouchEvents;", "output": "import * as React from 'react';\nimport layerMouseTouchEvents from '../layer-events-hoc';\nimport { MockComponent, mountWithMap, getMapMock } from '../jest/util';\nimport { withMap } from '../context';\n\nconst LayerHOC = withMap(layerMouseTouchEvents(MockComponent));\n\ndescribe('layer-events-hoc', () => {\n  it('Should default the id if none is passed', () => {\n    const res = mountWithMap(<LayerHOC />, getMapMock());\n    expect(res.find('h1').text()).toBe('layer-1');\n  });\n\n  it('should listen all mouse and touch events', () => {\n    const mapMock = getMapMock();\n    mountWithMap(<LayerHOC />, mapMock);\n\n    const events = [\n      'click',\n      'mouseenter',\n      'mouseleave',\n      'mousedown',\n      'touchstart'\n    ];\n\n    expect(mapMock.on.mock.calls.map(call => call[0])).toEqual(events);\n  });\n});", "meta": {"repo": "alex3165/react-mapbox-gl", "stars": 1972, "component": "src/layer-events-hoc.tsx", "test": "src/__tests__/layer-events-hoc.test.tsx"}}
{"input": "import classnames from 'classnames'\nimport React, { ReactEventHandler } from 'react'\nimport { Dim } from '../frame'\n\nexport interface VideoSrcProps {\n  id?: string\n  autoPlay: boolean\n  onClick?: ReactEventHandler<HTMLVideoElement>\n  onLoadedMetadata?: ReactEventHandler<HTMLVideoElement>\n  onResize?: (dimensions: Dim) => void\n  src?: string\n  srcObject: MediaStream | null\n  muted?: boolean\n  objectFit?: string\n  mirrored?: boolean\n}\n\nconst videoStyle = {\n  width: '100%',\n}\n\nexport default class VideoSrc extends React.PureComponent<VideoSrcProps> {\n  videoRef = React.createRef<HTMLVideoElement>()\n\n  componentDidMount () {\n    this.componentDidUpdate()\n\n    this.videoRef.current!.onresize = e => {\n      const el = e.target as HTMLVideoElement\n      this.maybeTriggerResize(el)\n    }\n  }\n  componentDidUpdate() {\n    const { srcObject, src } = this.props\n    const muted = !!this.props.muted\n\n    const video = this.videoRef.current\n\n    if (video) {\n      if ('srcObject' in video as unknown) {\n        if (video.srcObject !== srcObject) {\n          video.srcObject = srcObject\n        }\n      } else if (video.src !== src) {\n        video.src = src || ''\n      }\n\n      // Rather than setting muted property in <video> directly, we set it here\n      // to fix some issues in tests. For more details see commit 4b3cf45bf.\n      video.muted = muted\n\n      video.style.objectFit = this.props.objectFit || ''\n    }\n  }\n  handleLoadedMetadata = (e: React.SyntheticEvent<HTMLVideoElement>) => {\n    const el = e.target as HTMLVideoElement\n    this.maybeTriggerResize(el)\n\n    if (this.props.onLoadedMetadata) {\n      this.props.onLoadedMetadata(e)\n    }\n  }\n  maybeTriggerResize = (el: HTMLVideoElement) => {\n    const { onResize } = this.props\n\n    if (onResize && el.videoWidth && el.videoHeight) {\n      onResize({\n        x: el.videoWidth,\n        y: el.videoHeight,\n      })\n    }\n  }\n  render() {\n    const { mirrored } = this.props\n\n    const className = classnames({\n      mirrored,\n    })\n\n    return (\n      <video\n        id={this.props.id}\n        className={className}\n        autoPlay={this.props.autoPlay}\n        onClick={this.props.onClick}\n        onLoadedMetadata={this.props.onLoadedMetadata}\n        playsInline={true}\n        ref={this.videoRef}\n        style={videoStyle}\n      />\n    )\n  }\n}", "output": "jest.mock('../window')\n\nimport React, { ReactEventHandler } from 'react'\nimport ReactDOM from 'react-dom'\nimport TestUtils from 'react-dom/test-utils'\nimport { Dim } from '../frame'\nimport { MediaStream } from '../window'\nimport VideoSrc, { VideoSrcProps } from './VideoSrc'\n\ndescribe('components/VideoSrc', () => {\n  interface State {\n    src: string | undefined\n    srcObject: MediaStream | null\n  }\n\n  class VideoSrcWrapper extends React.PureComponent<VideoSrcProps, State> {\n    ref = React.createRef<VideoSrc>()\n\n    state = {\n      src: undefined,\n      srcObject: null,\n    }\n\n    render() {\n      return <VideoSrc\n        {...this.props}\n        ref={this.ref}\n        src={this.state.src || this.props.src}\n        srcObject={this.state.srcObject || this.props.srcObject}\n      />\n    }\n  }\n\n  let component: VideoSrcWrapper\n  let videoSrc: VideoSrc\n  let onLoadedMetadata: jest.MockedFunction<ReactEventHandler<HTMLVideoElement>>\n  let onClick: jest.MockedFunction<ReactEventHandler<HTMLVideoElement>>\n  let onResize: jest.MockedFunction<(dimensions: Dim) => void>\n  let src: string | undefined\n  let srcObject: MediaStream | null = null\n\n  async function render () {\n    const div = document.createElement('div')\n    component = await new Promise<VideoSrcWrapper>(resolve => {\n      ReactDOM.render(\n        <VideoSrcWrapper\n          ref={instance => resolve(instance!)}\n          id=\"test\"\n          autoPlay\n          mirrored\n          muted\n          onClick={onClick}\n          onLoadedMetadata={onLoadedMetadata}\n          onResize={onResize}\n          src={src}\n          srcObject={srcObject}\n          objectFit='contain'\n        />,\n        div,\n      )\n    })\n    videoSrc = TestUtils.findRenderedComponentWithType(component, VideoSrc)\n    // wrapper = div.children[0]\n  }\n\n  beforeEach(() => {\n    src = undefined\n    srcObject = null\n  })\n\n  describe('render', () => {\n    it('renders and sets src accordingly', async () => {\n      src = 'http://localhost/test.mp4'\n      await render()\n      expect(videoSrc.videoRef.current!.src).toBe(src)\n    })\n  })\n\n  describe('componentDidUpdate', () => {\n    it('updates srcObject', async () => {\n      await render()\n      const stream = new MediaStream()\n      videoSrc.videoRef.current!.srcObject = null\n      component.setState({\n        srcObject: stream,\n      })\n      expect(videoSrc.videoRef.current!.srcObject).toBe(stream)\n      expect(videoSrc.videoRef.current!.muted).toBe(true)\n    })\n  })\n})", "meta": {"repo": "peer-calls/peer-calls", "stars": 1846, "component": "src/client/components/VideoSrc.tsx", "test": "src/client/components/VideoSrc.test.tsx"}}
{"input": "import React, { Fragment } from 'react';\nimport { Image, View, Linking, ScrollView } from 'react-native';\n\nimport Button, {\n  ButtonVariants,\n} from '../../../../component-library/components/Buttons/Button';\nimport { strings } from '../../../../../locales/i18n';\nimport Text, {\n  TextColor,\n  TextVariant,\n} from '../../../../component-library/components/Texts/Text';\nimport { useTheme } from '../../../../util/theme';\nimport EnableBackupAndSyncCardImage from '../../../../images/enableBackupAndSyncCard.png';\nimport { createStyles } from './TurnOnBackupAndSync.styles';\nimport AppConstants from '../../../../core/AppConstants';\nimport SwitchLoadingModal from '../../../UI/Notification/SwitchLoadingModal';\nimport { useNavigation } from '@react-navigation/native';\nimport { useSelector } from 'react-redux';\nimport { RootState } from '../../../../reducers';\nimport { selectIsBackupAndSyncEnabled } from '../../../../selectors/identity';\nimport Routes from '../../../../constants/navigation/Routes';\nimport { useBackupAndSync } from '../../../../util/identity/hooks/useBackupAndSync';\nimport { BACKUPANDSYNC_FEATURES } from '@metamask/profile-sync-controller/user-storage';\nimport { MetaMetricsEvents, useMetrics } from '../../../hooks/useMetrics';\nimport { selectIsMetamaskNotificationsEnabled } from '../../../../selectors/notifications';\n\nexport const turnOnBackupAndSyncTestIds = {\n  view: 'turn-on-backup-and-sync-view',\n  cancelButton: 'turn-on-backup-and-sync-cancel-button',\n  enableButton: 'turn-on-backup-and-sync-enable-button',\n};\n\nconst TurnOnBackupAndSync = () => {\n  const theme = useTheme();\n  const styles = createStyles(theme);\n  const navigation = useNavigation();\n\n  const { setIsBackupAndSyncFeatureEnabled } = useBackupAndSync();\n  const { trackEvent, createEventBuilder } = useMetrics();\n\n  const isBasicFunctionalityEnabled = useSelector((state: RootState) =>\n    Boolean(state?.settings?.basicFunctionalityEnabled),\n  );\n  const isBackupAndSyncEnabled = useSelector(selectIsBackupAndSyncEnabled);\n  const isMetamaskNotificationsEnabled = useSelector(\n    selectIsMetamaskNotificationsEnabled,\n  );\n\n  const goToLearnMore = () => {\n    Linking.openURL(AppConstants.URLS.PROFILE_SYNC);\n  };\n\n  const trackEnableBackupAndSyncEvent = (newValue: boolean) => {\n    trackEvent(\n      createEventBuilder(MetaMetricsEvents.SETTINGS_UPDATED)\n        .addProperties({\n          settings_group: 'security_privacy',\n          settings_type: 'profile_syncing',\n          old_value: !newValue,\n          new_value: newValue,\n          was_notifications_on: isMetamaskNotificationsEnabled,\n        })\n        .build(),\n    );\n  };\n\n  const handleGoBack = () => {\n    navigation.goBack();\n  };\n\n  const handleEnableBackupAndSync = async () => {\n    if (!isBasicFunctionalityEnabled) {\n      navigation.navigate(Routes.MODAL.ROOT_MODAL_FLOW, {\n        screen: Routes.SHEET.CONFIRM_TURN_ON_BACKUP_AND_SYNC,\n        params: {\n          enableBackupAndSync: async () => {\n            navigation.navigate(Routes.SETTINGS_VIEW, {\n              screen: Routes.SETTINGS.BACKUP_AND_SYNC,\n            });\n            await setIsBackupAndSyncFeatureEnabled(\n              BACKUPANDSYNC_FEATURES.main,\n              true,\n            );\n          },\n          trackEnableBackupAndSyncEvent,\n        },\n      });\n      return;\n    }\n    if (!isBackupAndSyncEnabled) {\n      await setIsBackupAndSyncFeatureEnabled(BACKUPANDSYNC_FEATURES.main, true);\n    }\n    navigation.navigate(Routes.SETTINGS_VIEW, {\n      screen: Routes.SETTINGS.BACKUP_AND_SYNC,\n    });\n  };\n\n  return (\n    <Fragment>\n      <View style={styles.wrapper} testID={turnOnBackupAndSyncTestIds.view}>\n        <Text\n          variant={TextVariant.HeadingMD}\n          color={TextColor.Default}\n          style={styles.textTitle}\n        >\n          {strings('backupAndSync.enable.title')}\n        </Text>\n        <ScrollView>\n          <View style={styles.card}>\n            <Image source={EnableBackupAndSyncCardImage} style={styles.image} />\n          </View>\n          <Text\n            variant={TextVariant.BodyMD}\n            color={TextColor.Alternative}\n            style={styles.textSpace}\n          >\n            {strings('backupAndSync.enable.description')}{' '}\n            <Text\n              variant={TextVariant.BodyMD}\n              color={TextColor.Info}\n              onPress={goToLearnMore}\n            >\n              {strings('backupAndSync.privacyLink')}\n            </Text>\n          </Text>\n          <Text\n            style={styles.textSettings}\n            variant={TextVariant.BodyMD}\n            color={TextColor.Alternative}\n          >\n            {strings('backupAndSync.enable.updatePreferences')}\n          </Text>\n          <Text variant={TextVariant.BodyMDBold}>\n            {strings('backupAndSync.enable.settingsPath')}\n          </Text>\n        </ScrollView>\n\n        <View style={styles.btnContainer}>\n          <Button\n            variant={ButtonVariants.Secondary}\n            label={strings('notifications.activation_card.cancel')}\n            onPress={handleGoBack}\n            style={styles.ctaBtn}\n            testID={turnOnBackupAndSyncTestIds.cancelButton}\n          />\n          <Button\n            variant={ButtonVariants.Primary}\n            label={strings('notifications.activation_card.cta')}\n            onPress={handleEnableBackupAndSync}\n            style={styles.ctaBtn}\n            testID={turnOnBackupAndSyncTestIds.enableButton}\n          />\n        </View>\n      </View>\n      <SwitchLoadingModal\n        loading={false}\n        loadingText={strings('app_settings.enabling_notifications')}\n      />\n    </Fragment>\n  );\n};\n\nexport default TurnOnBackupAndSync;", "output": "import React from 'react';\n\nimport TurnOnBackupAndSync, {\n  turnOnBackupAndSyncTestIds,\n} from './TurnOnBackupAndSync';\nimport renderWithProvider from '../../../../util/test/renderWithProvider';\nimport Routes from '../../../../constants/navigation/Routes';\nimport { fireEvent, waitFor } from '@testing-library/react-native';\nimport { BACKUPANDSYNC_FEATURES } from '@metamask/profile-sync-controller/user-storage';\n\nconst MOCK_STORE_STATE = {\n  engine: {\n    backgroundState: {\n      UserStorageController: {\n        isBackupAndSyncEnabled: true,\n      },\n      AuthenticationController: {\n        isSignedIn: true,\n      },\n    },\n  },\n  settings: {\n    basicFunctionalityEnabled: true,\n  },\n};\n\nconst { InteractionManager } = jest.requireActual('react-native');\n\nInteractionManager.runAfterInteractions = jest.fn(async (callback) =>\n  callback(),\n);\n\nconst mockNavigate = jest.fn();\njest.mock('@react-navigation/native', () => {\n  const actualNav = jest.requireActual('@react-navigation/native');\n  return {\n    ...actualNav,\n    useNavigation: () => ({\n      navigate: mockNavigate,\n    }),\n  };\n});\n\nconst mockSetIsBackupAndSyncFeatureEnabled = jest.fn();\njest.mock('../../../../util/identity/hooks/useBackupAndSync', () => ({\n  useBackupAndSync: () => ({\n    setIsBackupAndSyncFeatureEnabled: mockSetIsBackupAndSyncFeatureEnabled,\n    error: null,\n  }),\n}));\n\ndescribe('TurnOnBackupAndSync', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  it('renders correctly', () => {\n    const { toJSON } = renderWithProvider(<TurnOnBackupAndSync />, {\n      state: MOCK_STORE_STATE,\n    });\n    expect(toJSON()).toMatchSnapshot();\n  });\n\n  it('enables backup and sync when clicking on the cta if backup and sync is disabled, and navigates to backup and sync settings either way', async () => {\n    const { getByTestId } = renderWithProvider(<TurnOnBackupAndSync />, {\n      state: {\n        ...MOCK_STORE_STATE,\n        engine: {\n          backgroundState: {\n            ...MOCK_STORE_STATE.engine.backgroundState,\n            UserStorageController: {\n              isBackupAndSyncEnabled: false,\n            },\n          },\n        },\n      },\n    });\n\n    const switchElement = getByTestId(turnOnBackupAndSyncTestIds.enableButton);\n    fireEvent.press(switchElement);\n\n    await waitFor(() => {\n      expect(mockSetIsBackupAndSyncFeatureEnabled).toHaveBeenCalledWith(\n        BACKUPANDSYNC_FEATURES.main,\n        true,\n      );\n      expect(mockNavigate).toHaveBeenCalledWith(Routes.SETTINGS_VIEW, {\n        screen: Routes.SETTINGS.BACKUP_AND_SYNC,\n      });\n    });\n  });\n\n  it('opens a modal when clicking on the cta while basic functionality is off', () => {\n    const { getByTestId } = renderWithProvider(<TurnOnBackupAndSync />, {\n      state: {\n        ...MOCK_STORE_STATE,\n        engine: {\n          backgroundState: {\n            ...MOCK_STORE_STATE.engine.backgroundState,\n            UserStorageController: {\n              isBackupAndSyncEnabled: false,\n            },\n          },\n        },\n        settings: {\n          ...MOCK_STORE_STATE.settings,\n          basicFunctionalityEnabled: false,\n        },\n      },\n    });\n\n    const switchElement = getByTestId(turnOnBackupAndSyncTestIds.enableButton);\n    fireEvent.press(switchElement);\n\n    expect(mockNavigate).toHaveBeenCalledWith(Routes.MODAL.ROOT_MODAL_FLOW, {\n      screen: Routes.SHEET.CONFIRM_TURN_ON_BACKUP_AND_SYNC,\n      params: {\n        enableBackupAndSync: expect.any(Function),\n        trackEnableBackupAndSyncEvent: expect.any(Function),\n      },\n    });\n  });\n});", "meta": {"repo": "MetaMask/metamask-mobile", "stars": 2454, "component": "app/components/Views/Identity/TurnOnBackupAndSync/TurnOnBackupAndSync.tsx", "test": "app/components/Views/Identity/TurnOnBackupAndSync/TurnOnBackupAndSync.test.tsx"}}
{"input": "/**\n * Teleport\n * Copyright (C) 2024  Gravitational, Inc.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\nimport { useEffect, useRef } from 'react';\nimport { useTheme } from 'styled-components';\n\nimport { Box, Indicator } from 'design';\n\nimport AuthnDialog from 'teleport/components/AuthnDialog';\nimport Document from 'teleport/Console/Document';\nimport useKubeExecSession from 'teleport/Console/DocumentKubeExec/useKubeExecSession';\nimport { Terminal, TerminalRef } from 'teleport/Console/DocumentSsh/Terminal';\nimport * as stores from 'teleport/Console/stores/types';\nimport { useMfaEmitter } from 'teleport/lib/useMfa';\n\nimport KubeExecData from './KubeExecDataDialog';\n\ntype Props = {\n  visible: boolean;\n  doc: stores.DocumentKubeExec;\n};\n\nexport default function DocumentKubeExec({ doc, visible }: Props) {\n  const terminalRef = useRef<TerminalRef>(undefined);\n  const { tty, status, closeDocument, sendKubeExecData } =\n    useKubeExecSession(doc);\n  const mfa = useMfaEmitter(tty);\n  useEffect(() => {\n    // when switching tabs, closing tabs, or\n    // when the pod information modal is dismissed\n    // focus the terminal\n    if (status === 'initialized') {\n      terminalRef.current?.focus();\n    }\n  }, [visible, mfa.challenge, status]);\n  const theme = useTheme();\n\n  const terminal = (\n    <Terminal\n      ref={terminalRef}\n      tty={tty}\n      fontFamily={theme.fonts.mono}\n      theme={theme.colors.terminal}\n      convertEol\n      disableAutoFocus={true}\n    />\n  );\n\n  return (\n    <Document visible={visible} flexDirection=\"column\">\n      {status === 'loading' && (\n        <Box textAlign=\"center\" m={10}>\n          <Indicator />\n        </Box>\n      )}\n      <AuthnDialog mfaState={mfa} onClose={closeDocument} />\n\n      {status === 'waiting-for-exec-data' && (\n        <KubeExecData onExec={sendKubeExecData} onClose={closeDocument} />\n      )}\n      {status !== 'loading' && terminal}\n    </Document>\n  );\n}", "output": "/**\n * Teleport\n * Copyright (C) 2024  Gravitational, Inc.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\nimport { screen } from '@testing-library/react';\n\nimport '@testing-library/jest-dom';\nimport 'jest-canvas-mock';\n\nimport { act, render } from 'design/utils/testing';\n\nimport { ContextProvider } from 'teleport';\nimport { TestLayout } from 'teleport/Console/Console.story';\nimport ConsoleCtx from 'teleport/Console/consoleContext';\nimport Tty from 'teleport/lib/term/tty';\nimport { createTeleportContext } from 'teleport/mocks/contexts';\nimport type { Session } from 'teleport/services/session';\n\nimport DocumentKubeExec from './DocumentKubeExec';\nimport useKubeExecSession, { Status } from './useKubeExecSession';\n\njest.mock('./useKubeExecSession');\n\nconst mockUseKubeExecSession = useKubeExecSession as jest.MockedFunction<\n  typeof useKubeExecSession\n>;\n\ndescribe('DocumentKubeExec', () => {\n  const setup = (status: Status) => {\n    mockUseKubeExecSession.mockReturnValue({\n      tty: {\n        sendKubeExecData: jest.fn(),\n        on: jest.fn(),\n        removeListener: jest.fn(),\n        connect: jest.fn(),\n        disconnect: jest.fn(),\n        removeAllListeners: jest.fn(),\n      } as unknown as Tty,\n      status,\n      closeDocument: jest.fn(),\n      sendKubeExecData: jest.fn(),\n      session: baseSession,\n    });\n\n    const { ctx, consoleCtx } = getContexts();\n\n    render(\n      <ContextProvider ctx={ctx}>\n        <TestLayout ctx={consoleCtx}>\n          <DocumentKubeExec doc={baseDoc} visible={true} />\n        </TestLayout>\n      </ContextProvider>\n    );\n  };\n\n  Object.defineProperty(window, 'matchMedia', {\n    writable: true,\n    value: jest.fn().mockImplementation(query => ({\n      matches: false,\n      media: query,\n      onchange: null,\n      addListener: jest.fn(), // Deprecated\n      removeListener: jest.fn(), // Deprecated\n      addEventListener: jest.fn(),\n      removeEventListener: jest.fn(),\n      dispatchEvent: jest.fn(),\n    })),\n  });\n\n  test('renders loading indicator when status is loading', async () => {\n    jest.useFakeTimers();\n    setup('loading');\n\n    act(() => jest.runAllTimers());\n    expect(screen.getByTestId('indicator')).toBeInTheDocument();\n  });\n\n  test('renders terminal window when status is initialized', () => {\n    setup('initialized');\n\n    expect(screen.getByTestId('terminal')).toBeInTheDocument();\n  });\n\n  test('renders data dialog when status is waiting-for-exec-data', () => {\n    setup('waiting-for-exec-data');\n\n    expect(screen.getByText('Exec into a pod')).toBeInTheDocument();\n    expect(screen.getByLabelText('Namespace')).toHaveFocus();\n  });\n\n  test('does not render data dialog when status is initialized', () => {\n    setup('initialized');\n\n    expect(screen.queryByText('Exec into a pod')).not.toBeInTheDocument();\n  });\n});\n\nfunction getContexts() {\n  const ctx = createTeleportContext();\n  const consoleCtx = new ConsoleCtx();\n  const tty = consoleCtx.createTty(baseSession);\n  tty.connect = () => null;\n  consoleCtx.createTty = () => tty;\n  consoleCtx.storeUser = ctx.storeUser;\n\n  return { ctx, consoleCtx };\n}\n\nconst baseDoc = {\n  kind: 'kubeExec',\n  status: 'connected',\n  sid: 'sid-value',\n  clusterId: 'clusterId-value',\n  serverId: 'serverId-value',\n  login: 'login-value',\n  kubeCluster: 'kubeCluster1',\n  kubeNamespace: 'namespace1',\n  pod: 'pod1',\n  container: '',\n  id: 3,\n  url: 'fd',\n  created: new Date(),\n  command: '/bin/bash',\n  isInteractive: true,\n} as const;\n\nconst baseSession: Session = {\n  kind: 'k8s',\n  login: '123',\n  sid: '456',\n  namespace: '',\n  created: new Date(),\n  durationText: '',\n  serverId: '',\n  resourceName: '',\n  clusterId: '',\n  parties: [],\n  addr: '',\n  participantModes: [],\n  moderated: false,\n  command: '/bin/bash',\n};", "meta": {"repo": "gravitational/teleport", "stars": 18686, "component": "web/packages/teleport/src/Console/DocumentKubeExec/DocumentKubeExec.tsx", "test": "web/packages/teleport/src/Console/DocumentKubeExec/DocumentKubeExec.test.tsx"}}
{"input": "import { useRouter } from 'next/router';\nimport { useCallback, useEffect, useState } from 'react';\nimport * as Y from 'yjs';\n\nimport { useUpdateDoc } from '@/docs/doc-management/';\nimport { KEY_LIST_DOC_VERSIONS } from '@/docs/doc-versioning';\nimport { isFirefox } from '@/utils/userAgent';\n\nimport { toBase64 } from '../utils';\n\nconst SAVE_INTERVAL = 60000;\n\nconst useSaveDoc = (docId: string, yDoc: Y.Doc, canSave: boolean) => {\n  const { mutate: updateDoc } = useUpdateDoc({\n    listInvalideQueries: [KEY_LIST_DOC_VERSIONS],\n    onSuccess: () => {\n      setIsLocalChange(false);\n    },\n  });\n  const [isLocalChange, setIsLocalChange] = useState<boolean>(false);\n\n  /**\n   * Update initial doc when doc is updated by other users,\n   * so only the user typing will trigger the save.\n   * This is to avoid saving the same doc multiple time.\n   */\n  useEffect(() => {\n    const onUpdate = (\n      _uintArray: Uint8Array,\n      _pluginKey: string,\n      _updatedDoc: Y.Doc,\n      transaction: Y.Transaction,\n    ) => {\n      setIsLocalChange(transaction.local);\n    };\n\n    yDoc.on('update', onUpdate);\n\n    return () => {\n      yDoc.off('update', onUpdate);\n    };\n  }, [yDoc]);\n\n  const saveDoc = useCallback(() => {\n    if (!canSave || !isLocalChange) {\n      return false;\n    }\n\n    updateDoc({\n      id: docId,\n      content: toBase64(Y.encodeStateAsUpdate(yDoc)),\n    });\n\n    return true;\n  }, [canSave, yDoc, docId, isLocalChange, updateDoc]);\n\n  const router = useRouter();\n\n  useEffect(() => {\n    const onSave = (e?: Event) => {\n      const isSaving = saveDoc();\n\n      /**\n       * Firefox does not trigger the request every time the user leaves the page.\n       * Plus the request is not intercepted by the service worker.\n       * So we prevent the default behavior to have the popup asking the user\n       * if he wants to leave the page, by adding the popup, we let the time to the\n       * request to be sent, and intercepted by the service worker (for the offline part).\n       */\n      if (\n        isSaving &&\n        typeof e !== 'undefined' &&\n        e.preventDefault &&\n        isFirefox()\n      ) {\n        e.preventDefault();\n      }\n    };\n\n    // Save every minute\n    const timeout = setInterval(onSave, SAVE_INTERVAL);\n    // Save when the user leaves the page\n    addEventListener('beforeunload', onSave);\n    // Save when the user navigates to another page\n    router.events.on('routeChangeStart', onSave);\n\n    return () => {\n      clearInterval(timeout);\n\n      removeEventListener('beforeunload', onSave);\n      router.events.off('routeChangeStart', onSave);\n    };\n  }, [router.events, saveDoc]);\n};\n\nexport default useSaveDoc;", "output": "import { act, renderHook, waitFor } from '@testing-library/react';\nimport fetchMock from 'fetch-mock';\nimport { useRouter } from 'next/router';\nimport * as Y from 'yjs';\n\nimport { AppWrapper } from '@/tests/utils';\n\nimport useSaveDoc from '../useSaveDoc';\n\njest.mock('next/router', () => ({\n  useRouter: jest.fn(),\n}));\n\njest.mock('@/docs/doc-versioning', () => ({\n  KEY_LIST_DOC_VERSIONS: 'test-key-list-doc-versions',\n}));\n\njest.mock('@/docs/doc-management', () => ({\n  useUpdateDoc: jest.requireActual('@/docs/doc-management/api/useUpdateDoc')\n    .useUpdateDoc,\n}));\n\ndescribe('useSaveDoc', () => {\n  const mockRouterEvents = {\n    on: jest.fn(),\n    off: jest.fn(),\n  };\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n    fetchMock.restore();\n\n    (useRouter as jest.Mock).mockReturnValue({\n      events: mockRouterEvents,\n    });\n  });\n\n  it('should setup event listeners on mount', () => {\n    const yDoc = new Y.Doc();\n    const docId = 'test-doc-id';\n\n    const addEventListenerSpy = jest.spyOn(window, 'addEventListener');\n\n    renderHook(() => useSaveDoc(docId, yDoc, true), {\n      wrapper: AppWrapper,\n    });\n\n    // Verify router event listeners are set up\n    expect(mockRouterEvents.on).toHaveBeenCalledWith(\n      'routeChangeStart',\n      expect.any(Function),\n    );\n\n    // Verify window event listener is set up\n    expect(addEventListenerSpy).toHaveBeenCalledWith(\n      'beforeunload',\n      expect.any(Function),\n    );\n\n    addEventListenerSpy.mockRestore();\n  });\n\n  it('should not save when canSave is false', async () => {\n    jest.useFakeTimers();\n    const yDoc = new Y.Doc();\n    const docId = 'test-doc-id';\n\n    fetchMock.patch('http://test.jest/api/v1.0/documents/test-doc-id/', {\n      body: JSON.stringify({\n        id: 'test-doc-id',\n        content: 'test-content',\n        title: 'test-title',\n      }),\n    });\n\n    renderHook(() => useSaveDoc(docId, yDoc, false), {\n      wrapper: AppWrapper,\n    });\n\n    act(() => {\n      // Trigger a local update\n      yDoc.getMap('test').set('key', 'value');\n    });\n\n    act(() => {\n      // Now advance timers after state has updated\n      jest.advanceTimersByTime(61000);\n    });\n\n    await waitFor(() => {\n      expect(fetchMock.calls().length).toBe(0);\n    });\n\n    jest.useRealTimers();\n  });\n\n  it('should save when there are local changes', async () => {\n    jest.useFakeTimers();\n    const yDoc = new Y.Doc();\n    const docId = 'test-doc-id';\n\n    fetchMock.patch('http://test.jest/api/v1.0/documents/test-doc-id/', {\n      body: JSON.stringify({\n        id: 'test-doc-id',\n        content: 'test-content',\n        title: 'test-title',\n      }),\n    });\n\n    renderHook(() => useSaveDoc(docId, yDoc, true), {\n      wrapper: AppWrapper,\n    });\n\n    act(() => {\n      // Trigger a local update\n      yDoc.getMap('test').set('key', 'value');\n    });\n\n    act(() => {\n      // Now advance timers after state has updated\n      jest.advanceTimersByTime(61000);\n    });\n\n    await waitFor(() => {\n      expect(fetchMock.lastCall()?.[0]).toBe(\n        'http://test.jest/api/v1.0/documents/test-doc-id/',\n      );\n    });\n\n    jest.useRealTimers();\n  });\n\n  it('should not save when there are no local changes', async () => {\n    jest.useFakeTimers();\n    const yDoc = new Y.Doc();\n    const docId = 'test-doc-id';\n\n    fetchMock.patch('http://test.jest/api/v1.0/documents/test-doc-id/', {\n      body: JSON.stringify({\n        id: 'test-doc-id',\n        content: 'test-content',\n        title: 'test-title',\n      }),\n    });\n\n    renderHook(() => useSaveDoc(docId, yDoc, true), {\n      wrapper: AppWrapper,\n    });\n\n    act(() => {\n      // Now advance timers after state has updated\n      jest.advanceTimersByTime(61000);\n    });\n\n    await waitFor(() => {\n      expect(fetchMock.calls().length).toBe(0);\n    });\n\n    jest.useRealTimers();\n  });\n\n  it('should cleanup event listeners on unmount', () => {\n    const yDoc = new Y.Doc();\n    const docId = 'test-doc-id';\n    const removeEventListenerSpy = jest.spyOn(window, 'removeEventListener');\n\n    const { unmount } = renderHook(() => useSaveDoc(docId, yDoc, true), {\n      wrapper: AppWrapper,\n    });\n\n    unmount();\n\n    // Verify router event listeners are cleaned up\n    expect(mockRouterEvents.off).toHaveBeenCalledWith(\n      'routeChangeStart',\n      expect.any(Function),\n    );\n\n    // Verify window event listener is cleaned up\n    expect(removeEventListenerSpy).toHaveBeenCalledWith(\n      'beforeunload',\n      expect.any(Function),\n    );\n  });\n});", "meta": {"repo": "suitenumerique/docs", "stars": 12672, "component": "src/frontend/apps/impress/src/features/docs/doc-editor/hook/useSaveDoc.tsx", "test": "src/frontend/apps/impress/src/features/docs/doc-editor/hook/__tests__/useSaveDoc.test.tsx"}}
{"input": "/**\n * Teleport\n * Copyright (C) 2023  Gravitational, Inc.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport { Link as InternalRouteLink } from 'react-router-dom';\nimport styled from 'styled-components';\n\nimport { Box, ButtonPrimary, ButtonSecondary, Flex, Link, Text } from 'design';\nimport * as Icons from 'design/Icon';\nimport FieldInput from 'shared/components/FieldInput';\nimport Validation from 'shared/components/Validation';\nimport { requiredIamRoleName } from 'shared/components/Validation/rules';\n\nimport { TextSelectCopyMulti } from 'teleport/components/TextSelectCopy';\nimport cfg from 'teleport/config';\nimport { Header } from 'teleport/Discover/Shared';\nimport { AWS_RESOURCE_GROUPS_TAG_EDITOR_LINK } from 'teleport/Discover/Shared/const';\nimport {\n  RoleArnInput,\n  ShowConfigurationScript,\n} from 'teleport/Integrations/shared';\nimport { AwsOidcPolicyPreset } from 'teleport/services/integrations';\nimport useStickyClusterId from 'teleport/useStickyClusterId';\n\nimport { ConfigureAwsOidcSummary } from './ConfigureAwsOidcSummary';\nimport { FinishDialog } from './FinishDialog';\nimport { useAwsOidcIntegration } from './useAwsOidcIntegration';\n\nexport function AwsOidc() {\n  const {\n    integrationConfig,\n    setIntegrationConfig,\n    scriptUrl,\n    setScriptUrl,\n    handleOnCreate,\n    createdIntegration,\n    createIntegrationAttempt,\n    generateAwsOidcConfigIdpScript,\n  } = useAwsOidcIntegration();\n  const { clusterId } = useStickyClusterId();\n\n  return (\n    <Box pt={3}>\n      <Header>Set up your AWS account</Header>\n\n      <Box width=\"800px\" mb={4}>\n        Instead of storing long-lived static credentials, Teleport will become a\n        trusted OIDC provider with AWS to be able to request short lived\n        credentials when performing operations automatically such as when\n        connecting{' '}\n        <RouteLink\n          to={{\n            pathname: `${cfg.routes.root}/discover`,\n            state: { searchKeywords: 'ec2' },\n          }}\n        >\n          AWS EC2\n        </RouteLink>{' '}\n        or{' '}\n        <RouteLink\n          to={{\n            pathname: `${cfg.routes.root}/discover`,\n            state: { searchKeywords: 'rds' },\n          }}\n        >\n          AWS RDS\n        </RouteLink>{' '}\n        instances during resource enrollment.\n        <Box mt={3}>\n          AWS Resources created by the integration are tagged so that you can\n          search and export them using the{' '}\n          <Link target=\"_blank\" href={AWS_RESOURCE_GROUPS_TAG_EDITOR_LINK}>\n            AWS Resource Groups / Tag Editor\n          </Link>\n          . The following tags are applied:\n          <TextSelectCopyMulti\n            bash={false}\n            lines={[\n              {\n                text:\n                  `teleport.dev/cluster: ` +\n                  clusterId +\n                  `\\n` +\n                  `teleport.dev/origin: integration_awsoidc\\n` +\n                  `teleport.dev/integration: ` +\n                  integrationConfig.name,\n              },\n            ]}\n          />\n        </Box>\n      </Box>\n\n      <Validation>\n        {({ validator }) => (\n          <>\n            <Container mb={5} width={800}>\n              <Text bold>Step 1</Text>\n              <Box width=\"600px\">\n                <FieldInput\n                  autoFocus={true}\n                  value={integrationConfig.name}\n                  label=\"Give this AWS integration a name\"\n                  placeholder=\"Integration Name\"\n                  onChange={e =>\n                    setIntegrationConfig({\n                      ...integrationConfig,\n                      name: e.target.value,\n                    })\n                  }\n                  disabled={!!scriptUrl}\n                />\n                <FieldInput\n                  rule={requiredIamRoleName}\n                  value={integrationConfig.roleName}\n                  placeholder=\"Integration role name\"\n                  label=\"Give a name for an AWS IAM role this integration will create\"\n                  onChange={e =>\n                    setIntegrationConfig({\n                      ...integrationConfig,\n                      roleName: e.target.value,\n                    })\n                  }\n                  disabled={!!scriptUrl}\n                />\n              </Box>\n              {scriptUrl ? (\n                <ButtonSecondary\n                  mb={3}\n                  onClick={() => {\n                    setScriptUrl('');\n                  }}\n                >\n                  Edit\n                </ButtonSecondary>\n              ) : (\n                <ButtonSecondary\n                  mb={3}\n                  onClick={() =>\n                    generateAwsOidcConfigIdpScript(\n                      validator,\n                      AwsOidcPolicyPreset.Unspecified\n                    )\n                  }\n                >\n                  Generate Command\n                </ButtonSecondary>\n              )}\n            </Container>\n            {scriptUrl && (\n              <>\n                <Container mb={5} width={800}>\n                  <Flex gap={1} alignItems=\"center\">\n                    <Text bold>Step 2</Text>\n                    <ConfigureAwsOidcSummary\n                      roleName={integrationConfig.roleName}\n                      integrationName={integrationConfig.name}\n                    />\n                  </Flex>\n                  <ShowConfigurationScript scriptUrl={scriptUrl} />\n                </Container>\n                <Container mb={5} width={800}>\n                  <Text bold>Step 3</Text>\n                  <RoleArnInput\n                    roleName={integrationConfig.roleName}\n                    roleArn={integrationConfig.roleArn}\n                    setRoleArn={(v: string) =>\n                      setIntegrationConfig({\n                        ...integrationConfig,\n                        roleArn: v,\n                      })\n                    }\n                    disabled={createIntegrationAttempt.status === 'processing'}\n                  />\n                </Container>\n              </>\n            )}\n            {createIntegrationAttempt.status === 'error' && (\n              <Flex>\n                <Icons.Warning mr={2} color=\"error.main\" size=\"small\" />\n                <Text color=\"error.main\">\n                  Error: {createIntegrationAttempt.statusText}\n                </Text>\n              </Flex>\n            )}\n            <Box mt={6}>\n              <ButtonPrimary\n                onClick={() => handleOnCreate(validator)}\n                disabled={\n                  !scriptUrl ||\n                  createIntegrationAttempt.status === 'processing' ||\n                  !integrationConfig.roleArn\n                }\n              >\n                Create Integration\n              </ButtonPrimary>\n              <ButtonSecondary\n                ml={3}\n                as={InternalRouteLink}\n                to={cfg.getIntegrationEnrollRoute(null)}\n              >\n                Back\n              </ButtonSecondary>\n            </Box>\n          </>\n        )}\n      </Validation>\n      {createdIntegration && <FinishDialog integration={createdIntegration} />}\n    </Box>\n  );\n}\n\nconst Container = styled(Box)`\n  max-width: 1000px;\n  background-color: ${p => p.theme.colors.spotBackground[0]};\n  border-radius: ${p => `${p.theme.space[2]}px`};\n  padding: ${p => p.theme.space[3]}px;\n`;\n\nconst RouteLink = styled(InternalRouteLink)`\n  color: ${({ theme }) => theme.colors.buttons.link.default};\n\n  &:hover,\n  &:focus {\n    color: ${({ theme }) => theme.colors.buttons.link.hover};\n  }\n`;", "output": "/**\n * Teleport\n * Copyright (C) 2024  Gravitational, Inc.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nimport { MemoryRouter } from 'react-router';\n\nimport {\n  fireEvent,\n  render,\n  screen,\n  userEvent,\n  waitFor,\n} from 'design/utils/testing';\n\nimport { ApiError } from 'teleport/services/api/parseError';\nimport { integrationService } from 'teleport/services/integrations';\nimport { userEventService } from 'teleport/services/userEvent';\n\nimport { AwsOidc } from './AwsOidc';\n\ntest('render', async () => {\n  jest\n    .spyOn(userEventService, 'captureIntegrationEnrollEvent')\n    .mockImplementation();\n  render(\n    <MemoryRouter>\n      <AwsOidc />\n    </MemoryRouter>\n  );\n\n  expect(screen.getByText(/Set up your AWS account/i)).toBeInTheDocument();\n  expect(\n    screen.getByLabelText(/Give this AWS integration a name/i)\n  ).toBeInTheDocument();\n  expect(\n    screen.getByLabelText(\n      /Give a name for an AWS IAM role this integration will create/i\n    )\n  ).toBeInTheDocument();\n});\n\ntest('generate command', async () => {\n  const user = userEvent.setup({ delay: null });\n  jest\n    .spyOn(userEventService, 'captureIntegrationEnrollEvent')\n    .mockImplementation();\n\n  let spyPing = jest\n    .spyOn(integrationService, 'pingAwsOidcIntegration')\n    .mockResolvedValue({} as any); // response doesn't matter\n\n  const spyCreate = jest\n    .spyOn(integrationService, 'createIntegration')\n    .mockResolvedValue({} as any); // response doesn't matter\n\n  window.prompt = jest.fn();\n\n  render(\n    <MemoryRouter>\n      <AwsOidc />\n    </MemoryRouter>\n  );\n\n  const pluginConfig = {\n    name: 'integration-name',\n    roleName: 'integration-role-name',\n  };\n\n  expect(screen.getByText(/Set up your AWS account/i)).toBeInTheDocument();\n  fireEvent.change(screen.getByLabelText(/Give this AWS integration a name/i), {\n    target: { value: pluginConfig.name },\n  });\n  fireEvent.change(\n    screen.getByLabelText(\n      /Give a name for an AWS IAM role this integration will create/i\n    ),\n    {\n      target: { value: pluginConfig.roleName },\n    }\n  );\n\n  fireEvent.click(screen.getByRole('button', { name: /Generate Command/i }));\n\n  const commandBoxEl = screen.getByText(/AWS CloudShell/i, { exact: false });\n  await waitFor(() => {\n    expect(commandBoxEl).toBeInTheDocument();\n  });\n\n  // the first element found shows AWS tags added by OIDC integraiton.\n  // second element is the command copy box.\n  await user.click(screen.getAllByTestId('btn-copy')[1]);\n  const clipboardText = await navigator.clipboard.readText();\n  expect(clipboardText).toContain(`integrationName=${pluginConfig.name}`);\n  expect(clipboardText).toContain(`role=${pluginConfig.roleName}`);\n\n  // Fill out arn.\n  fireEvent.change(screen.getByLabelText(/role arn/i), {\n    target: {\n      value: `arn:aws:iam::123456789012:role/${pluginConfig.roleName}`,\n    },\n  });\n\n  // Test ping is called before create.\n  fireEvent.click(screen.getByRole('button', { name: /create integration/i }));\n  await waitFor(() => expect(spyPing).toHaveBeenCalledTimes(1));\n  await waitFor(() => expect(spyCreate).toHaveBeenCalledTimes(1));\n\n  let pingOrder = spyPing.mock.invocationCallOrder[0];\n  let createOrder = spyCreate.mock.invocationCallOrder[0];\n  expect(pingOrder).toBeLessThan(createOrder);\n\n  // Test create is still called with 404 ping error.\n  jest.clearAllMocks();\n  let error = new ApiError({\n    message: '',\n    response: { status: 404 } as Response,\n  });\n  spyPing = jest\n    .spyOn(integrationService, 'pingAwsOidcIntegration')\n    .mockRejectedValue(error);\n\n  fireEvent.click(screen.getByRole('button', { name: /create integration/i }));\n  await waitFor(() => expect(spyPing).toHaveBeenCalledTimes(1));\n  await waitFor(() => expect(spyCreate).toHaveBeenCalledTimes(1));\n\n  // Test create isn't called with non 404 error\n  jest.clearAllMocks();\n  error = new ApiError({ message: '', response: { status: 400 } as Response });\n  spyPing = jest\n    .spyOn(integrationService, 'pingAwsOidcIntegration')\n    .mockRejectedValue(error);\n\n  fireEvent.click(screen.getByRole('button', { name: /create integration/i }));\n  await waitFor(() => expect(spyPing).toHaveBeenCalledTimes(1));\n  await waitFor(() => expect(spyCreate).toHaveBeenCalledTimes(0));\n});", "meta": {"repo": "gravitational/teleport", "stars": 18686, "component": "web/packages/teleport/src/Integrations/Enroll/AwsOidc/AwsOidc.tsx", "test": "web/packages/teleport/src/Integrations/Enroll/AwsOidc/AwsOidc.test.tsx"}}
{"input": "/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the \"Elastic License\n * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n * Public License v 1\"; you may not use this file except in compliance with, at\n * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n * License v3.0 only\", or the \"Server Side Public License, v 1\".\n */\n\nimport React, { useCallback, useEffect } from 'react';\nimport { FormattedMessage } from '@kbn/i18n-react';\nimport { EuiCallOut, EuiLink, EuiLoadingSpinner, EuiPage, EuiPageBody } from '@elastic/eui';\nimport { i18n } from '@kbn/i18n';\nimport { ElasticRequestState } from '@kbn/unified-doc-viewer';\nimport { useEsDocSearch } from '@kbn/unified-doc-viewer-plugin/public';\nimport type { EsDocSearchProps } from '@kbn/unified-doc-viewer-plugin/public/types';\nimport type { DataTableRecord } from '@kbn/discover-utils/types';\nimport { setBreadcrumbs } from '../../../utils/breadcrumbs';\nimport { useDiscoverServices } from '../../../hooks/use_discover_services';\nimport { SingleDocViewer } from './single_doc_viewer';\nimport { createDataViewDataSource } from '../../../../common/data_sources';\nimport { useScopedServices } from '../../../components/scoped_services_provider';\n\nexport interface DocProps extends EsDocSearchProps {\n  /**\n   * Discover main view url\n   */\n  referrer?: string;\n}\n\nexport function Doc(props: DocProps) {\n  const { dataView } = props;\n  const { scopedProfilesManager } = useScopedServices();\n  const services = useDiscoverServices();\n  const { locator, chrome, docLinks } = services;\n  const indexExistsLink = docLinks.links.apis.indexExists;\n\n  const onBeforeFetch = useCallback(async () => {\n    await scopedProfilesManager.resolveDataSourceProfile({\n      dataSource: dataView?.id ? createDataViewDataSource({ dataViewId: dataView.id }) : undefined,\n      dataView,\n      query: { query: '', language: 'kuery' },\n    });\n  }, [scopedProfilesManager, dataView]);\n\n  const onProcessRecord = useCallback(\n    (record: DataTableRecord) => {\n      return scopedProfilesManager.resolveDocumentProfile({ record });\n    },\n    [scopedProfilesManager]\n  );\n\n  const [reqState, record] = useEsDocSearch({\n    ...props,\n    onBeforeFetch,\n    onProcessRecord,\n  });\n\n  useEffect(() => {\n    setBreadcrumbs({\n      services,\n      titleBreadcrumbText: `${props.index}#${props.id}`,\n      rootBreadcrumbPath: props.referrer,\n    });\n  }, [chrome, props.referrer, props.index, props.id, dataView, locator, services]);\n\n  return (\n    <EuiPage>\n      <h1\n        id=\"singleDocTitle\"\n        className=\"euiScreenReaderOnly\"\n        data-test-subj=\"discoverSingleDocTitle\"\n      >\n        {i18n.translate('discover.doc.pageTitle', {\n          defaultMessage: 'Single document - #{id}',\n          values: { id: props.id },\n        })}\n      </h1>\n      <EuiPageBody panelled paddingSize=\"m\" panelProps={{ role: 'main' }}>\n        {reqState === ElasticRequestState.NotFoundDataView && (\n          <EuiCallOut\n            color=\"danger\"\n            data-test-subj={`doc-msg-notFoundDataView`}\n            iconType=\"warning\"\n            title={\n              <FormattedMessage\n                id=\"discover.doc.failedToLocateDataView\"\n                defaultMessage=\"No data view matches ID {dataViewId}.\"\n                values={{ dataViewId: dataView.id }}\n              />\n            }\n          />\n        )}\n        {reqState === ElasticRequestState.NotFound && (\n          <EuiCallOut\n            color=\"danger\"\n            data-test-subj={`doc-msg-notFound`}\n            iconType=\"warning\"\n            title={\n              <FormattedMessage\n                id=\"discover.doc.failedToLocateDocumentDescription\"\n                defaultMessage=\"Cannot find document\"\n              />\n            }\n          >\n            <FormattedMessage\n              id=\"discover.doc.couldNotFindDocumentsDescription\"\n              defaultMessage=\"No documents match that ID.\"\n            />\n          </EuiCallOut>\n        )}\n\n        {reqState === ElasticRequestState.Error && (\n          <EuiCallOut\n            color=\"danger\"\n            data-test-subj={`doc-msg-error`}\n            iconType=\"warning\"\n            title={\n              <FormattedMessage\n                id=\"discover.doc.failedToExecuteQueryDescription\"\n                defaultMessage=\"Cannot run search\"\n              />\n            }\n          >\n            <FormattedMessage\n              id=\"discover.doc.somethingWentWrongDescription\"\n              defaultMessage=\"{indexName} is missing.\"\n              values={{ indexName: props.index }}\n            />{' '}\n            <EuiLink href={indexExistsLink} target=\"_blank\">\n              <FormattedMessage\n                id=\"discover.doc.somethingWentWrongDescriptionAddon\"\n                defaultMessage=\"Please ensure the index exists.\"\n              />\n            </EuiLink>\n          </EuiCallOut>\n        )}\n\n        {reqState === ElasticRequestState.Loading && (\n          <EuiCallOut data-test-subj={`doc-msg-loading`}>\n            <EuiLoadingSpinner size=\"m\" />{' '}\n            <FormattedMessage id=\"discover.doc.loadingDescription\" defaultMessage=\"Loading\u2026\" />\n          </EuiCallOut>\n        )}\n\n        {reqState === ElasticRequestState.Found && record !== null && dataView && (\n          <div data-test-subj=\"doc-hit\">\n            <SingleDocViewer record={record} dataView={dataView} />\n          </div>\n        )}\n      </EuiPageBody>\n    </EuiPage>\n  );\n}", "output": "/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the \"Elastic License\n * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n * Public License v 1\"; you may not use this file except in compliance with, at\n * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n * License v3.0 only\", or the \"Server Side Public License, v 1\".\n */\n\nimport { throwError, of } from 'rxjs';\nimport React from 'react';\nimport { act } from 'react-dom/test-utils';\nimport { mountWithIntl } from '@kbn/test-jest-helpers';\nimport type { ReactWrapper } from 'enzyme';\nimport { findTestSubject } from '@elastic/eui/lib/test';\nimport type { DocProps } from './doc';\nimport { Doc } from './doc';\nimport { dataViewMock } from '@kbn/discover-utils/src/__mocks__';\nimport { setUnifiedDocViewerServices } from '@kbn/unified-doc-viewer-plugin/public/plugin';\nimport { mockUnifiedDocViewerServices } from '@kbn/unified-doc-viewer-plugin/public/__mocks__';\nimport type { UnifiedDocViewerServices } from '@kbn/unified-doc-viewer-plugin/public/types';\nimport { createDiscoverServicesMock } from '../../../__mocks__/services';\nimport { DiscoverTestProvider } from '../../../__mocks__/test_provider';\n\nconst services = createDiscoverServicesMock();\nconst mockSearchApi = jest.fn();\n\nbeforeEach(() => {\n  jest.clearAllMocks();\n});\n\nconst waitForPromises = async () =>\n  act(async () => {\n    await new Promise((resolve) => setTimeout(resolve));\n  });\n\n/**\n * this works but logs ugly error messages until we're using React 16.9\n * should be adapted when we upgrade\n */\nasync function mountDoc(update = false) {\n  const props = {\n    id: '1',\n    index: 'index1',\n    dataView: dataViewMock,\n    referrer: 'mock-referrer',\n  } as DocProps;\n  let comp!: ReactWrapper;\n  setUnifiedDocViewerServices({\n    ...mockUnifiedDocViewerServices,\n    data: {\n      search: {\n        search: mockSearchApi,\n      },\n    },\n  } as unknown as UnifiedDocViewerServices);\n  await act(async () => {\n    comp = mountWithIntl(\n      <DiscoverTestProvider services={services}>\n        <Doc {...props} />\n      </DiscoverTestProvider>\n    );\n    if (update) comp.update();\n  });\n  if (update) {\n    await waitForPromises();\n    comp.update();\n  }\n  return comp;\n}\n\ndescribe('Test of <Doc /> of Discover', () => {\n  test('renders loading msg', async () => {\n    const comp = await mountDoc();\n    expect(findTestSubject(comp, 'doc-msg-loading').length).toBe(1);\n  });\n\n  test('renders notFound msg', async () => {\n    mockSearchApi.mockImplementation(() => throwError({ status: 404 }));\n    const comp = await mountDoc(true);\n    expect(findTestSubject(comp, 'doc-msg-notFound').length).toBe(1);\n  });\n\n  test('renders error msg', async () => {\n    mockSearchApi.mockImplementation(() => throwError({ error: 'something else' }));\n    const comp = await mountDoc(true);\n    expect(findTestSubject(comp, 'doc-msg-error').length).toBe(1);\n  });\n\n  test('renders elasticsearch hit ', async () => {\n    mockSearchApi.mockImplementation(() =>\n      of({ rawResponse: { hits: { total: 1, hits: [{ _id: 1, _source: { test: 1 } }] } } })\n    );\n    const comp = await mountDoc(true);\n    expect(findTestSubject(comp, 'doc-hit').length).toBe(1);\n  });\n});", "meta": {"repo": "elastic/kibana", "stars": 20552, "component": "src/platform/plugins/shared/discover/public/application/doc/components/doc.tsx", "test": "src/platform/plugins/shared/discover/public/application/doc/components/doc.test.tsx"}}
{"input": "/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the \"Elastic License\n * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n * Public License v 1\"; you may not use this file except in compliance with, at\n * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n * License v3.0 only\", or the \"Server Side Public License, v 1\".\n */\n\nimport React, { memo, useCallback, useMemo, useRef } from 'react';\nimport {\n  EuiDataGrid,\n  EuiDataGridProps,\n  EuiDataGridRefProps,\n  EuiDataGridSorting,\n  EuiTitle,\n} from '@elastic/eui';\nimport { i18n } from '@kbn/i18n';\nimport { IInterpreterRenderHandlers } from '@kbn/expressions-plugin/common';\nimport { createTableVisCell } from './table_vis_cell';\nimport { TableContext, TableVisConfig, TableVisUseUiStateProps } from '../types';\nimport { usePagination } from '../utils';\nimport { TableVisControls } from './table_vis_controls';\nimport { createGridColumns } from './table_vis_columns';\nimport { sortNullsLast } from './utils';\n\ninterface TableVisBasicProps {\n  fireEvent: IInterpreterRenderHandlers['event'];\n  table: TableContext;\n  visConfig: TableVisConfig;\n  title?: string;\n  uiStateProps: TableVisUseUiStateProps;\n}\n\nexport const TableVisBasic = memo(\n  ({\n    fireEvent,\n    table,\n    visConfig,\n    title,\n    uiStateProps: { columnsWidth, sort, setColumnsWidth, setSort },\n  }: TableVisBasicProps) => {\n    const dataGridRef = useRef<EuiDataGridRefProps>(null);\n\n    const { columns, rows, formattedColumns } = table;\n\n    // custom sorting is in place until the EuiDataGrid sorting gets rid of flaws -> https://github.com/elastic/eui/issues/4108\n    const sortedRows = useMemo(() => {\n      if (sort.columnIndex !== null && sort.direction) {\n        const id = columns[sort.columnIndex]?.id;\n        return sortNullsLast(rows, sort.direction, id);\n      }\n\n      return rows;\n    }, [columns, rows, sort.columnIndex, sort.direction]);\n\n    // renderCellValue is a component which renders a cell based on column and row indexes\n    const renderCellValue = useMemo(\n      () => createTableVisCell(sortedRows, formattedColumns, visConfig.autoFitRowToContent),\n      [formattedColumns, sortedRows, visConfig.autoFitRowToContent]\n    );\n\n    const rowHeightsOptions = useMemo(\n      () =>\n        visConfig.autoFitRowToContent\n          ? ({ defaultHeight: 'auto' } as unknown as EuiDataGridProps['rowHeightsOptions'])\n          : undefined,\n      [visConfig.autoFitRowToContent]\n    );\n\n    // Columns config\n    const gridColumns = createGridColumns(\n      columns,\n      sortedRows,\n      formattedColumns,\n      columnsWidth,\n      fireEvent,\n      dataGridRef.current?.closeCellPopover\n    );\n\n    // Pagination config\n    const pagination = usePagination(visConfig, rows.length);\n    // Sorting config\n    const sortingColumns = useMemo(\n      () =>\n        sort.columnIndex !== null && sort.direction\n          ? [{ id: columns[sort.columnIndex]?.id, direction: sort.direction }]\n          : [],\n      [columns, sort]\n    );\n    const onSort = useCallback(\n      (sortingCols: EuiDataGridSorting['columns'] | []) => {\n        // data table vis sorting now only handles one column sorting\n        // if data grid provides more columns to sort, pick only the next column to sort\n        const newSortValue = sortingCols.length <= 1 ? sortingCols[0] : sortingCols[1];\n        setSort(\n          newSortValue && {\n            columnIndex: columns.findIndex((c) => c.id === newSortValue.id),\n            direction: newSortValue.direction,\n          }\n        );\n      },\n      [columns, setSort]\n    );\n\n    const dataGridAriaLabel =\n      title ||\n      visConfig.title ||\n      i18n.translate('visTypeTable.defaultAriaLabel', {\n        defaultMessage: 'Data table visualization',\n      });\n\n    const onColumnResize = useCallback<NonNullable<EuiDataGridProps['onColumnResize']>>(\n      ({ columnId, width }) => {\n        const colIndex = columns.findIndex((c) => c.id === columnId);\n        setColumnsWidth({\n          colIndex,\n          width,\n        });\n      },\n      [columns, setColumnsWidth]\n    );\n\n    return (\n      <>\n        {title && (\n          <EuiTitle size=\"xs\">\n            <h3>{title}</h3>\n          </EuiTitle>\n        )}\n        <EuiDataGrid\n          aria-label={dataGridAriaLabel}\n          columns={gridColumns}\n          gridStyle={{\n            border: 'horizontal',\n            header: 'underline',\n          }}\n          rowHeightsOptions={rowHeightsOptions}\n          rowCount={rows.length}\n          columnVisibility={{\n            visibleColumns: columns.map(({ id }) => id),\n            setVisibleColumns: () => {},\n          }}\n          toolbarVisibility={\n            visConfig.showToolbar && {\n              showColumnSelector: false,\n              showFullScreenSelector: false,\n              showSortSelector: false,\n              showDisplaySelector: false,\n              additionalControls: (\n                <TableVisControls\n                  dataGridAriaLabel={dataGridAriaLabel}\n                  columns={columns}\n                  // csv exports sorted table\n                  rows={sortedRows}\n                  filename={visConfig.title}\n                />\n              ),\n            }\n          }\n          renderCellValue={renderCellValue}\n          renderFooterCellValue={\n            visConfig.showTotal\n              ? ({ columnId }) => formattedColumns[columnId].formattedTotal || null\n              : undefined\n          }\n          pagination={pagination}\n          sorting={{ columns: sortingColumns, onSort }}\n          onColumnResize={onColumnResize}\n          minSizeForControls={1}\n          ref={dataGridRef}\n        />\n      </>\n    );\n  }\n);", "output": "/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the \"Elastic License\n * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n * Public License v 1\"; you may not use this file except in compliance with, at\n * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n * License v3.0 only\", or the \"Server Side Public License, v 1\".\n */\n\nimport React from 'react';\nimport { shallow } from 'enzyme';\nimport { TableVisBasic } from './table_vis_basic';\nimport { FormattedColumn, TableVisConfig, TableVisUiState } from '../types';\nimport { DatatableColumn } from '@kbn/expressions-plugin/common';\nimport { createTableVisCell } from './table_vis_cell';\nimport { createGridColumns } from './table_vis_columns';\nimport { EuiDataGridProps } from '@elastic/eui';\n\njest.mock('./table_vis_columns', () => ({\n  createGridColumns: jest.fn(() => []),\n}));\njest.mock('./table_vis_cell', () => ({\n  createTableVisCell: jest.fn(() => () => {}),\n}));\n\ndescribe('TableVisBasic', () => {\n  const props = {\n    fireEvent: jest.fn(),\n    table: {\n      columns: [],\n      rows: [],\n      formattedColumns: {\n        test: {\n          formattedTotal: 100,\n        } as FormattedColumn,\n      },\n    },\n    visConfig: {} as TableVisConfig,\n    uiStateProps: {\n      sort: {\n        columnIndex: null,\n        direction: null,\n      },\n      columnsWidth: [],\n      setColumnsWidth: jest.fn(),\n      setSort: jest.fn(),\n    },\n  };\n\n  it('should init data grid', () => {\n    const comp = shallow(<TableVisBasic {...props} />);\n    expect(comp).toMatchSnapshot();\n  });\n\n  it('should init data grid with title provided - for split mode', () => {\n    const title = 'My data table';\n    const comp = shallow(<TableVisBasic {...props} title={title} />);\n    expect(comp).toMatchSnapshot();\n  });\n\n  it('should render the toolbar', () => {\n    const comp = shallow(\n      <TableVisBasic\n        {...props}\n        visConfig={{ ...props.visConfig, title: 'My saved vis', showToolbar: true }}\n      />\n    );\n    expect(comp).toMatchSnapshot();\n  });\n\n  it('should sort rows by column and pass the sorted rows for consumers', () => {\n    (createTableVisCell as jest.Mock).mockClear();\n    const uiStateProps = {\n      ...props.uiStateProps,\n      sort: {\n        columnIndex: 1,\n        direction: 'desc',\n      } as TableVisUiState['sort'],\n    };\n    const table = {\n      columns: [{ id: 'first' }, { id: 'second' }] as DatatableColumn[],\n      rows: [\n        { first: 1, second: 2 },\n        { first: 3, second: 4 },\n        { first: 5, second: 6 },\n      ],\n      formattedColumns: {},\n    };\n    const sortedRows = [\n      { first: 5, second: 6 },\n      { first: 3, second: 4 },\n      { first: 1, second: 2 },\n    ];\n    const comp = shallow(\n      <TableVisBasic\n        {...props}\n        table={table}\n        uiStateProps={uiStateProps}\n        visConfig={{ ...props.visConfig, showToolbar: true }}\n      />\n    );\n    expect(createTableVisCell).toHaveBeenCalledWith(sortedRows, table.formattedColumns, undefined);\n    expect(createGridColumns).toHaveBeenCalledWith(\n      table.columns,\n      sortedRows,\n      table.formattedColumns,\n      uiStateProps.columnsWidth,\n      props.fireEvent,\n      undefined\n    );\n\n    const { onSort } = comp.find('EuiDataGrid').prop<EuiDataGridProps['sorting']>('sorting')!;\n\n    // sort the first column\n    onSort([{ id: 'first', direction: 'asc' }]);\n    expect(uiStateProps.setSort).toHaveBeenCalledWith({ columnIndex: 0, direction: 'asc' });\n    // sort the second column - should erase the first column sorting since there is only one level sorting available\n    onSort([\n      { id: 'first', direction: 'asc' },\n      { id: 'second', direction: 'desc' },\n    ]);\n    expect(uiStateProps.setSort).toHaveBeenCalledWith({ columnIndex: 1, direction: 'desc' });\n  });\n\n  it('should pass renderFooterCellValue for the total row', () => {\n    const comp = shallow(\n      <TableVisBasic {...props} visConfig={{ ...props.visConfig, showTotal: true }} />\n    );\n    const renderFooterCellValue: (props: any) => void = comp\n      .find('EuiDataGrid')\n      .prop('renderFooterCellValue');\n    expect(renderFooterCellValue).toEqual(expect.any(Function));\n    expect(renderFooterCellValue({ columnId: 'test' })).toEqual(100);\n  });\n});", "meta": {"repo": "elastic/kibana", "stars": 20552, "component": "src/platform/plugins/private/vis_types/table/public/components/table_vis_basic.tsx", "test": "src/platform/plugins/private/vis_types/table/public/components/table_vis_basic.test.tsx"}}
{"input": "/**\n * Higher-order component (HOC) to wrap a component with a custom hook that injects props.\n *\n * WHY:\n * - Some components depend on logic or derived state provided by a custom hook.\n * - This HOC pattern allows us to move hook logic *outside* of the component and keep the\n *   UI component focused purely on presentation.\n * - It enables reuse and testing of both the hook and the component in isolation.\n * - It also simplifies usage for consumers, they just pass `HookProps` and get a fully\n *   functional component without worrying about wiring up the hook.\n *\n * HOW:\n * - `useHook` is a function hook that takes `HookProps` (input props) and returns `InjectedProps`\n *   (props that the inner `Component` needs).\n * - The HOC returns a new component that:\n *    1. Accepts `HookProps` as its props.\n *    2. Calls the `useHook` with those props to get derived/injected props.\n *    3. Renders the target `Component` with those injected props.\n *\n * Usage:\n * const SmartComponent = withHoc(useMyHook, MyComponent);\n * <SmartComponent someHookInput={...} /> // Only provides HookProps\n */\nexport function withHoc<HookProps extends {}, InjectedProps extends {}>(\n    useHook: (props: HookProps) => InjectedProps,\n    Component: React.ComponentType<InjectedProps>\n): React.FC<HookProps> {\n    return function EnhancedComponent(props: HookProps) {\n        const injectedProps = useHook(props);\n        return <Component {...injectedProps} />;\n    };\n}", "output": "import React from 'react';\n\nimport { render, screen } from '@testing-library/react';\n\nimport { withHoc } from './withHoc';\n\ntype HookProps = { input: string };\ntype InjectedProps = { label: string };\n\nconst mockHook = jest.fn<InjectedProps, [HookProps]>(({ input }) => ({\n    label: `Label: ${input}`,\n}));\n\nconst DummyComponent: React.FC<InjectedProps> = ({ label }) => {\n    return <div>{label}</div>;\n};\n\nconst WrappedComponent = withHoc(mockHook, DummyComponent);\n\ndescribe('withHoc', () => {\n    it('calls hook with props and renders component with injected props', () => {\n        render(<WrappedComponent input=\"Test\" />);\n\n        expect(mockHook).toHaveBeenCalledWith({ input: 'Test' });\n\n        expect(screen.getByText('Label: Test')).toBeInTheDocument();\n    });\n});", "meta": {"repo": "ProtonMail/WebClients", "stars": 4792, "component": "applications/drive/src/app/hooks/withHoc/withHoc.tsx", "test": "applications/drive/src/app/hooks/withHoc/withHoc.test.tsx"}}
{"input": "import type { ReactNode } from \"react\";\n\n/**\n * Controls are renderers for a specific type of data. For example, an input\n * for a string, a checkbox for a boolean, a select for an enum, etc.\n *\n * Use controls to render the atoms of your form. If you plan to wrap each\n * control in a label, you can use the `wrapEach` prop when you build your form.\n */\nexport type Control<Value, Options extends { id: string } = { id: string }> = (\n  value: Value,\n  onValueChange: (value: Value) => void,\n  options: Options,\n  globals?: any\n) => JSX.Element;\n\nexport type ControlsMap<Controls> = {\n  [K in keyof Controls]: Controls[K] extends Control<infer Value, infer Options>\n    ? { value: Value; options: Options }\n    : never;\n};\n\nexport type Fields<\n  Controls_ extends Record<string, Control<any, any>>,\n  Data\n> = {\n  [K in keyof ControlsMap<Controls_>]: {\n    /**\n     * What control to use.\n     */\n    control: K;\n    /**\n     * Given the data, return the value for this field.\n     */\n    value: (data: Data) => ControlsMap<Controls_>[K][\"value\"];\n    /**\n     * Update the data with the new value.\n     */\n    onChange: (value: ControlsMap<Controls_>[K][\"value\"]) => void;\n    /**\n     * If this field should be hidden.\n     */\n    hidden?: boolean | ((data: Data) => boolean);\n  } & ControlsMap<Controls_>[K][\"options\"];\n}[keyof ControlsMap<Controls_>];\n\n/**\n * Sections are used to group fields together and optionally hide them.\n * They are recursive and can contain other fields, sections, or React nodes.\n */\nexport type Sections<\n  Controls_ extends Record<string, Control<any, any>>,\n  Data\n> = {\n  /**\n   * If these fields should be hidden.\n   */\n  hidden?: boolean | ((data: Data) => boolean);\n  /**\n   * The elements in this section.  Can be fields or other sections.\n   */\n  elements: (Fields<Controls_, Data> | Sections<Controls_, Data> | ReactNode)[];\n  /**\n   * Wraps all fields in this section.\n   */\n  wrapper?: ({\n    children,\n    data,\n  }: {\n    children: ReactNode;\n    data: Data;\n  }) => ReactNode;\n  /**\n   * Wraps each field in this section, and any sections contained by this section. It works recursively\n   * so if you don't want it to wrap fields in a subsection, you can set `wrapEach` to `false` in\n   * that subsection.\n   */\n  wrapEach?:\n    | (({\n        children,\n        data,\n        field,\n      }: {\n        children: ReactNode;\n        data: Data;\n        field: Fields<Controls_, Data>;\n      }) => ReactNode)\n    | false;\n};\n\n/**\n * Form-rendering framework tightly coupled to type and data. Creates a form\n * creator function with a known set of control types that can be used.\n */\nexport function createControls<\n  Controls_ extends Record<string, Control<any, any>>\n>(controls: Controls_) {\n  return function createForm<Data>(\n    elements: Sections<Controls_, Data> | Sections<Controls_, Data>[\"elements\"]\n  ) {\n    function renderElementsRecursive(\n      data: Data,\n      elements: Sections<Controls_, Data>[\"elements\"],\n      parentWrapEach?: Sections<Controls_, Data>[\"wrapEach\"],\n      globals?: any\n    ): ReactNode {\n      return elements.map((element) => {\n        if (!element) return null;\n        if (typeof element === \"object\" && \"elements\" in element) {\n          // If it's a section, render it recursively.\n          const {\n            elements,\n            hidden,\n            wrapper,\n            wrapEach = parentWrapEach,\n          } = element;\n          if (\n            hidden &&\n            (typeof hidden === \"function\" ? hidden(data) : hidden)\n          ) {\n            return null;\n          }\n\n          return wrapper\n            ? wrapper({\n                children: renderElementsRecursive(\n                  data,\n                  elements,\n                  wrapEach,\n                  globals\n                ),\n                data,\n              })\n            : renderElementsRecursive(data, elements, wrapEach, globals);\n        } else if (typeof element === \"object\" && \"control\" in element) {\n          // If it's a field, render the control.\n          const { control, value, onChange, hidden, ...options } = element;\n\n          const controller = controls[element.control];\n          if (!controller) {\n            throw new Error(\n              `Unknown control \"${String(\n                element.control\n              )}\". Available controls are: ${Object.keys(controls).join(\", \")}`\n            );\n          }\n\n          if (\n            hidden &&\n            (typeof hidden === \"function\" ? hidden(data) : hidden)\n          ) {\n            return null;\n          }\n\n          // Wrap the control if necessary.\n          const wrapped = parentWrapEach\n            ? parentWrapEach({\n                children: controller(value(data), onChange, options, globals),\n                data,\n                field: element,\n              })\n            : controller(value(data), onChange, options, globals);\n\n          // Wrap the control in a label if necessary.\n          return wrapped;\n        } else {\n          // Otherwise, just render the element.\n          return element;\n        }\n      });\n    }\n\n    return function Form({ data, globals }: { data: Data; globals?: any }) {\n      return renderElementsRecursive(\n        data,\n        Array.isArray(elements) ? elements : [elements],\n        Array.isArray(elements) ? undefined : elements.wrapEach,\n        globals\n      );\n    };\n  };\n}", "output": "import { describe, test, expect } from \"vitest\";\nimport { createControls } from \"./formulaic\";\n\n// describe(\"szform\", () => {\n//   test(\"is passed current data\", () => {\n//     expect(createControls({ x: 100 })).toBe(true);\n//   });\n// });", "meta": {"repo": "tone-row/flowchart-fun", "stars": 3224, "component": "formulaic/src/formulaic.tsx", "test": "formulaic/src/formulaic.test.tsx"}}
{"input": "import React from 'react';\nimport { ActivityIndicator, StyleSheet, View } from 'react-native';\n\nimport { useStyles } from '../../../../../../../../component-library/hooks';\nimport InfoRow from '../../../../UI/info-row';\nimport InfoSection from '../../../../UI/info-row/info-section';\n\nconst styleSheet = () => StyleSheet.create({\n  base: {\n    display: 'flex',\n    justifyContent: 'space-between',\n  },\n});\n\nconst StaticSimulation: React.FC<{\n  title: string;\n  titleTooltip: string;\n  description?: string;\n  simulationElements: React.ReactNode;\n  isLoading?: boolean;\n  isCollapsed?: boolean;\n}> = ({\n  title,\n  titleTooltip,\n  description,\n  simulationElements,\n  isLoading,\n  isCollapsed = false,\n}) => {\n  const { styles, theme } = useStyles(styleSheet, {});\n\n  return(\n    <View style={isCollapsed ? styles.base : {}}>\n      <InfoSection>\n        <InfoRow label={title} tooltip={titleTooltip}>\n          {description}\n        </InfoRow>\n        {isLoading ? (\n          <ActivityIndicator\n            size=\"small\"\n            color={theme.colors.warning.default}\n          />\n        ) : (\n          simulationElements\n          )}\n        </InfoSection>\n    </View>\n  );\n};\n\nexport default StaticSimulation;", "output": "import React from 'react';\nimport { Text } from 'react-native';\nimport { render } from '@testing-library/react-native';\nimport StaticSimulation from './static';\n\nconst mockProps = {\n  title: 'Test Title',\n  titleTooltip: 'Test Tooltip',\n  description: 'Test Description',\n  simulationElements: <></>,\n};\n\ndescribe('StaticSimulation', () => {\n  it('renders correctly with basic props', () => {\n    const { getByText } = render(<StaticSimulation {...mockProps} />);\n\n    expect(getByText('Test Title')).toBeDefined();\n    expect(getByText('Test Description')).toBeDefined();\n  });\n\n  it('shows loader when isLoading is true', () => {\n    const { queryByTestId } = render(\n      <StaticSimulation {...mockProps} isLoading />,\n    );\n\n    expect(queryByTestId('confirm-v3v4-simulation-loader')).toBeDefined();\n  });\n\n  it('shows simulation elements when not loading', () => {\n    const simulationElements = <Text>Test Simulation</Text>;\n    const { getByText } = render(\n      <StaticSimulation\n        {...mockProps}\n        simulationElements={simulationElements}\n        isLoading={false}\n      />,\n    );\n\n    expect(getByText('Test Simulation')).toBeDefined();\n  });\n});", "meta": {"repo": "MetaMask/metamask-mobile", "stars": 2454, "component": "app/components/Views/confirmations/components/info/typed-sign-v3v4/simulation/static/static.tsx", "test": "app/components/Views/confirmations/components/info/typed-sign-v3v4/simulation/static/static.test.tsx"}}
{"input": "/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the \"Elastic License\n * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n * Public License v 1\"; you may not use this file except in compliance with, at\n * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n * License v3.0 only\", or the \"Server Side Public License, v 1\".\n */\n\nimport { EuiFlexGroup, EuiFlexItem } from '@elastic/eui';\nimport { css } from '@emotion/react';\nimport type { ReactNode } from 'react';\nimport React from 'react';\nimport { ResizableLayoutDirection } from '../types';\n\nexport const PanelsStatic = ({\n  className,\n  direction,\n  hideFixedPanel,\n  fixedPanel,\n  flexPanel,\n}: {\n  className?: string;\n  direction: ResizableLayoutDirection;\n  hideFixedPanel?: boolean;\n  fixedPanel: ReactNode;\n  flexPanel: ReactNode;\n}) => {\n  // By default a flex item has overflow: visible, min-height: auto, and min-width: auto.\n  // This can cause the item to overflow the flexbox parent when its content is too large.\n  // Setting the overflow to something other than visible (e.g. auto) resets the min-height\n  // and min-width to 0 and makes the item respect the flexbox parent's size.\n  // https://stackoverflow.com/questions/36247140/why-dont-flex-items-shrink-past-content-size\n  const flexPanelCss = css`\n    overflow: auto;\n  `;\n\n  return (\n    <EuiFlexGroup\n      className={className}\n      direction={direction === ResizableLayoutDirection.Vertical ? 'column' : 'row'}\n      alignItems=\"stretch\"\n      gutterSize=\"none\"\n      responsive={false}\n      css={css`\n        height: 100%;\n      `}\n    >\n      {!hideFixedPanel && <EuiFlexItem grow={false}>{fixedPanel}</EuiFlexItem>}\n      <EuiFlexItem css={flexPanelCss}>{flexPanel}</EuiFlexItem>\n    </EuiFlexGroup>\n  );\n};", "output": "/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the \"Elastic License\n * 2.0\", the \"GNU Affero General Public License v3.0 only\", and the \"Server Side\n * Public License v 1\"; you may not use this file except in compliance with, at\n * your election, the \"Elastic License 2.0\", the \"GNU Affero General Public\n * License v3.0 only\", or the \"Server Side Public License, v 1\".\n */\n\nimport { EuiFlexGroup } from '@elastic/eui';\nimport { mount } from 'enzyme';\nimport type { ReactElement } from 'react';\nimport React from 'react';\nimport { ResizableLayoutDirection } from '../types';\nimport { PanelsStatic } from './panels_static';\n\ndescribe('Panels static', () => {\n  const mountComponent = ({\n    direction = ResizableLayoutDirection.Vertical,\n    hideFixedPanel = false,\n    fixedPanel = <></>,\n    flexPanel = <></>,\n  }: {\n    direction?: ResizableLayoutDirection;\n    hideFixedPanel?: boolean;\n    fixedPanel: ReactElement;\n    flexPanel: ReactElement;\n  }) => {\n    return mount(\n      <PanelsStatic\n        direction={direction}\n        hideFixedPanel={hideFixedPanel}\n        fixedPanel={fixedPanel}\n        flexPanel={flexPanel}\n      />\n    );\n  };\n\n  it('should render both panels when hideFixedPanel is false', () => {\n    const fixedPanel = <div data-test-subj=\"fixedPanel\" />;\n    const flexPanel = <div data-test-subj=\"flexPanel\" />;\n    const component = mountComponent({ fixedPanel, flexPanel });\n    expect(component.contains(fixedPanel)).toBe(true);\n    expect(component.contains(flexPanel)).toBe(true);\n  });\n\n  it('should render only flex panel when hideFixedPanel is true', () => {\n    const fixedPanel = <div data-test-subj=\"fixedPanel\" />;\n    const flexPanel = <div data-test-subj=\"flexPanel\" />;\n    const component = mountComponent({ hideFixedPanel: true, fixedPanel, flexPanel });\n    expect(component.contains(fixedPanel)).toBe(false);\n    expect(component.contains(flexPanel)).toBe(true);\n  });\n\n  it('should pass direction \"column\" to EuiFlexGroup when direction is ResizableLayoutDirection.Vertical', () => {\n    const component = mountComponent({\n      direction: ResizableLayoutDirection.Vertical,\n      fixedPanel: <></>,\n      flexPanel: <></>,\n    });\n    expect(component.find(EuiFlexGroup).prop('direction')).toBe('column');\n  });\n\n  it('should pass direction \"row\" to EuiFlexGroup when direction is ResizableLayoutDirection.Horizontal', () => {\n    const component = mountComponent({\n      direction: ResizableLayoutDirection.Horizontal,\n      fixedPanel: <></>,\n      flexPanel: <></>,\n    });\n    expect(component.find(EuiFlexGroup).prop('direction')).toBe('row');\n  });\n});", "meta": {"repo": "elastic/kibana", "stars": 20552, "component": "src/platform/packages/shared/kbn-resizable-layout/src/panels_static.tsx", "test": "src/platform/packages/shared/kbn-resizable-layout/src/panels_static.test.tsx"}}
{"input": "/*\n * SPDX-License-Identifier: Apache-2.0\n *\n * The OpenSearch Contributors require contributions made to\n * this file be licensed under the Apache-2.0 license or a\n * compatible open source license.\n *\n * Any modifications Copyright OpenSearch Contributors. See\n * GitHub history for details.\n */\n\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport React from 'react';\nimport { FormattedMessage, I18nProvider } from '@osd/i18n/react';\nimport { EuiCallOut, EuiLink, EuiLoadingSpinner, EuiPage, EuiPageContent } from '@elastic/eui';\nimport { IndexPatternsContract } from 'src/plugins/data/public';\nimport { OpenSearchRequestState, useOpenSearchDocSearch } from './use_opensearch_doc_search';\nimport { DocViewer } from '../doc_viewer/doc_viewer';\n\nexport interface DocProps {\n  /**\n   * Id of the doc in OpenSearch\n   */\n  id: string;\n  /**\n   * Index in OpenSearch to query\n   */\n  index: string;\n  /**\n   * IndexPattern ID used to get IndexPattern entity\n   * that's used for adding additional fields (stored_fields, script_fields, docvalue_fields)\n   */\n  indexPatternId: string;\n  /**\n   * IndexPatternService to get a given index pattern by ID\n   */\n  indexPatternService: IndexPatternsContract;\n}\n\nexport function Doc(props: DocProps) {\n  const [reqState, hit, indexPattern] = useOpenSearchDocSearch(props);\n  return (\n    <I18nProvider>\n      <EuiPage className=\"discover.context.appPage\" data-test-subj=\"discoverAppPage\">\n        <EuiPageContent paddingSize=\"s\">\n          {reqState === OpenSearchRequestState.NotFoundIndexPattern && (\n            <EuiCallOut\n              color=\"danger\"\n              data-test-subj={`doc-msg-notFoundIndexPattern`}\n              iconType=\"alert\"\n              title={\n                <FormattedMessage\n                  id=\"discover.doc.failedToLocateIndexPattern\"\n                  defaultMessage=\"No index pattern matches ID {indexPatternId}\"\n                  values={{ indexPatternId: props.indexPatternId }}\n                />\n              }\n            />\n          )}\n          {reqState === OpenSearchRequestState.NotFound && (\n            <EuiCallOut\n              color=\"danger\"\n              data-test-subj={`doc-msg-notFound`}\n              iconType=\"alert\"\n              title={\n                <FormattedMessage\n                  id=\"discover.doc.failedToLocateDocumentDescription\"\n                  defaultMessage=\"Cannot find document\"\n                />\n              }\n            >\n              <FormattedMessage\n                id=\"discover.doc.couldNotFindDocumentsDescription\"\n                defaultMessage=\"No documents match that ID.\"\n              />\n            </EuiCallOut>\n          )}\n\n          {reqState === OpenSearchRequestState.Error && (\n            <EuiCallOut\n              color=\"danger\"\n              data-test-subj={`doc-msg-error`}\n              iconType=\"alert\"\n              title={\n                <FormattedMessage\n                  id=\"discover.doc.failedToExecuteQueryDescription\"\n                  defaultMessage=\"Cannot run search\"\n                />\n              }\n            >\n              <FormattedMessage\n                id=\"discover.doc.somethingWentWrongDescription\"\n                defaultMessage=\"{indexName} is missing.\"\n                values={{ indexName: props.index }}\n              />{' '}\n              <EuiLink\n                href={`https://opensearch.org/docs/latest/opensearch/rest-api/index-apis/exists/`}\n                target=\"_blank\"\n              >\n                <FormattedMessage\n                  id=\"discover.doc.somethingWentWrongDescriptionAddon\"\n                  defaultMessage=\"Please ensure the index exists.\"\n                />\n              </EuiLink>\n            </EuiCallOut>\n          )}\n\n          {reqState === OpenSearchRequestState.Loading && (\n            <EuiCallOut data-test-subj={`doc-msg-loading`}>\n              <EuiLoadingSpinner size=\"m\" />{' '}\n              <FormattedMessage id=\"discover.doc.loadingDescription\" defaultMessage=\"Loading\u2026\" />\n            </EuiCallOut>\n          )}\n\n          {reqState === OpenSearchRequestState.Found && hit !== null && indexPattern && (\n            <div data-test-subj=\"doc-hit\">\n              <DocViewer hit={hit} indexPattern={indexPattern} />\n            </div>\n          )}\n        </EuiPageContent>\n      </EuiPage>\n    </I18nProvider>\n  );\n}", "output": "/*\n * SPDX-License-Identifier: Apache-2.0\n *\n * The OpenSearch Contributors require contributions made to\n * this file be licensed under the Apache-2.0 license or a\n * compatible open source license.\n *\n * Any modifications Copyright OpenSearch Contributors. See\n * GitHub history for details.\n */\n\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport { throwError, of } from 'rxjs';\nimport React from 'react';\nimport { act } from 'react-dom/test-utils';\nimport { mountWithIntl } from 'test_utils/enzyme_helpers';\nimport { ReactWrapper } from 'enzyme';\nimport { findTestSubject } from 'test_utils/helpers';\nimport { Doc, DocProps } from './doc';\n\nconst mockSearchApi = jest.fn();\n\njest.mock('../../../opensearch_dashboards_services', () => {\n  let registry: any[] = [];\n\n  return {\n    getServices: () => ({\n      metadata: {\n        branch: 'test',\n      },\n      data: {\n        search: {\n          search: mockSearchApi,\n        },\n      },\n    }),\n    getDocViewsRegistry: () => ({\n      addDocView(view: any) {\n        registry.push(view);\n      },\n      getDocViewsSorted() {\n        return registry;\n      },\n      resetRegistry: () => {\n        registry = [];\n      },\n    }),\n    getDocViewsLinksRegistry: () => ({\n      addDocViewLink(view: any) {\n        registry.push(view);\n      },\n      getDocViewsLinksSorted() {\n        return registry;\n      },\n      resetRegistry: () => {\n        registry = [];\n      },\n    }),\n  };\n});\n\nbeforeEach(() => {\n  jest.clearAllMocks();\n});\n\nconst waitForPromises = async () =>\n  act(async () => {\n    await new Promise((resolve) => setTimeout(resolve));\n  });\n\n/**\n * this works but logs ugly error messages until we're using React 16.9\n * should be adapted when we upgrade\n */\nasync function mountDoc(update = false, indexPatternGetter: any = null) {\n  const indexPattern = {\n    getComputedFields: () => [],\n  };\n  const indexPatternService = {\n    get: indexPatternGetter ? indexPatternGetter : jest.fn(() => Promise.resolve(indexPattern)),\n    isLongNumeralsSupported: jest.fn(),\n  } as any;\n\n  const props = {\n    id: '1',\n    index: 'index1',\n    indexPatternId: 'xyz',\n    indexPatternService,\n  } as DocProps;\n  let comp!: ReactWrapper;\n  await act(async () => {\n    comp = mountWithIntl(<Doc {...props} />);\n    if (update) comp.update();\n  });\n  if (update) {\n    await waitForPromises();\n    comp.update();\n  }\n  return comp;\n}\n\ndescribe('Test of <Doc /> of Discover', () => {\n  test('renders loading msg', async () => {\n    const comp = await mountDoc();\n    expect(findTestSubject(comp, 'doc-msg-loading').length).toBe(1);\n  });\n\n  test('renders IndexPattern notFound msg', async () => {\n    const indexPatternGetter = jest.fn(() => Promise.reject({ savedObjectId: '007' }));\n    const comp = await mountDoc(true, indexPatternGetter);\n    expect(findTestSubject(comp, 'doc-msg-notFoundIndexPattern').length).toBe(1);\n  });\n\n  test('renders notFound msg', async () => {\n    mockSearchApi.mockImplementation(() => throwError({ status: 404 }));\n    const comp = await mountDoc(true);\n    expect(findTestSubject(comp, 'doc-msg-notFound').length).toBe(1);\n  });\n\n  test('renders error msg', async () => {\n    mockSearchApi.mockImplementation(() => throwError({ error: 'something else' }));\n    const comp = await mountDoc(true);\n    expect(findTestSubject(comp, 'doc-msg-error').length).toBe(1);\n  });\n\n  test('renders opensearch hit ', async () => {\n    mockSearchApi.mockImplementation(() =>\n      of({ rawResponse: { hits: { total: 1, hits: [{ _id: 1, _source: { test: 1 } }] } } })\n    );\n    const comp = await mountDoc(true);\n    expect(findTestSubject(comp, 'doc-hit').length).toBe(1);\n  });\n});", "meta": {"repo": "opensearch-project/OpenSearch-Dashboards", "stars": 1844, "component": "src/plugins/discover/public/application/components/doc/doc.tsx", "test": "src/plugins/discover/public/application/components/doc/doc.test.tsx"}}
{"input": "import * as React from 'react';\nimport type { ForwardRefComponent } from '@fluentui/react-utilities';\nimport { useCustomStyleHook_unstable } from '@fluentui/react-shared-contexts';\n\nimport { useAppItemStatic_unstable } from './useAppItemStatic';\nimport { renderAppItemStatic_unstable } from './renderAppItemStatic';\nimport { useAppItemStaticStyles_unstable } from './useAppItemStaticStyles.styles';\nimport type { AppItemStaticProps } from './AppItemStatic.types';\n\n/**\n * AppItemStatic component - Static application item in the navigation menu.\n */\nexport const AppItemStatic: ForwardRefComponent<AppItemStaticProps> = React.forwardRef((props, ref) => {\n  const state = useAppItemStatic_unstable(props, ref);\n\n  useAppItemStaticStyles_unstable(state);\n  useCustomStyleHook_unstable('useAppItemStaticStyles_unstable')(state);\n\n  return renderAppItemStatic_unstable(state);\n});\n\nAppItemStatic.displayName = 'AppItemStatic';", "output": "import * as React from 'react';\nimport { isConformant } from '../../testing/isConformant';\nimport { AppItemStatic } from './AppItemStatic';\nimport { appItemStaticClassNames } from './useAppItemStaticStyles.styles';\nimport { AppItemStaticProps } from './AppItemStatic.types';\n\ndescribe('AppItemStatic', () => {\n  isConformant({\n    Component: AppItemStatic as React.FunctionComponent<AppItemStaticProps>,\n    displayName: 'AppItemStatic',\n    testOptions: {\n      'has-static-classnames': [\n        {\n          props: { icon: 'Test Icon', content: 'Some Content' },\n          expectedClassNames: {\n            root: appItemStaticClassNames.root,\n            icon: appItemStaticClassNames.icon,\n          },\n        },\n      ],\n    },\n  });\n});", "meta": {"repo": "microsoft/fluentui", "stars": 19349, "component": "packages/react-components/react-nav/library/src/components/AppItemStatic/AppItemStatic.tsx", "test": "packages/react-components/react-nav/library/src/components/AppItemStatic/AppItemStatic.test.tsx"}}
{"input": "import { defineComponent, computed, ref, onMounted, watch, toRefs } from 'vue';\nimport {\n  ArrowTriangleDownFilledIcon as TDArrowTriangleDownFilledIcon,\n  ArrowTriangleUpFilledIcon as TDArrowTriangleUpFilledIcon,\n} from 'tdesign-icons-vue-next';\nimport { isNumber, isFunction } from 'lodash-es';\n\nimport props from './props';\nimport { useTNodeJSX, useGlobalIcon, usePrefixClass } from '@tdesign/shared-hooks';\n\nimport Skeleton from '../skeleton';\nimport Tween from '@tdesign/common-js/statistic/tween';\nimport { COLOR_MAP, getFormatValue } from '@tdesign/common-js/statistic/utils';\n\nexport default defineComponent({\n  name: 'TStatistic',\n  props,\n  setup(props, { expose }) {\n    const COMPONENT_NAME = usePrefixClass('statistic');\n    const renderTNodeJSX = useTNodeJSX();\n    const { ArrowTriangleUpFilledIcon, ArrowTriangleDownFilledIcon } = useGlobalIcon({\n      ArrowTriangleUpFilledIcon: TDArrowTriangleUpFilledIcon,\n      ArrowTriangleDownFilledIcon: TDArrowTriangleDownFilledIcon,\n    });\n    const trendIcons = {\n      increase: <ArrowTriangleUpFilledIcon />,\n      decrease: <ArrowTriangleDownFilledIcon />,\n    };\n    const numberValue = computed(() => (isNumber(props.value) ? props.value : 0));\n    const innerValue = ref(props.animation?.valueFrom ?? props.value);\n    const innerDecimalPlaces = computed(\n      () => props.decimalPlaces ?? numberValue.value.toString().split('.')[1]?.length ?? 0,\n    );\n\n    const tween = ref<Tween>();\n    const { value } = toRefs(props);\n\n    const start = (from: number = props.animation?.valueFrom ?? 0, to: number = numberValue.value) => {\n      if (from !== to) {\n        tween.value = new Tween({\n          from: {\n            value: from,\n          },\n          to: {\n            value: to,\n          },\n          duration: props.animation.duration,\n          onUpdate: (keys) => {\n            innerValue.value = Number(keys.value.toFixed(innerDecimalPlaces.value));\n          },\n          onFinish: () => {\n            innerValue.value = to;\n          },\n        });\n        tween.value?.start();\n      }\n    };\n\n    const formatValue = computed(() => {\n      if (isFunction(props.format)) {\n        return props.format(innerValue.value);\n      }\n\n      return getFormatValue(innerValue.value, props.decimalPlaces, props.separator);\n    });\n\n    const contentStyle = computed(() => {\n      const { color } = props;\n      return {\n        color: COLOR_MAP[color] || color,\n      };\n    });\n\n    watch(\n      () => props.animationStart,\n      (value) => {\n        if (props.animation && value && !tween.value) {\n          start();\n        }\n      },\n    );\n    watch(value, (value) => {\n      if (tween.value) {\n        (tween.value as any)?.stop();\n        tween.value = null;\n      }\n      innerValue.value = value;\n      if (props.animationStart && props.animation) {\n        start();\n      }\n    });\n\n    onMounted(() => props.animation && props.animationStart && start());\n\n    expose({ start });\n\n    return () => {\n      const trendIcon = props.trend ? trendIcons[props.trend] : null;\n      const prefix = renderTNodeJSX('prefix') || (trendIcon && props.trendPlacement !== 'right' ? trendIcon : null);\n      const suffix = renderTNodeJSX('suffix') || (trendIcon && props.trendPlacement === 'right' ? trendIcon : null);\n      const title = renderTNodeJSX('title');\n      const unit = renderTNodeJSX('unit');\n      const extra = renderTNodeJSX('extra');\n\n      return (\n        <div class={COMPONENT_NAME.value}>\n          {title && <div class={`${COMPONENT_NAME.value}-title`}>{title}</div>}\n          <Skeleton animation=\"gradient\" theme=\"text\" loading={!!props.loading}>\n            <div class={`${COMPONENT_NAME.value}-content`} style={contentStyle.value}>\n              {prefix && <span class={`${COMPONENT_NAME.value}-content-prefix`}>{prefix}</span>}\n              <span class={`${COMPONENT_NAME.value}-content-value`}>{formatValue.value}</span>\n              {unit && <span class={`${COMPONENT_NAME.value}-content-unit`}>{unit}</span>}\n              {suffix && <span class={`${COMPONENT_NAME.value}-content-suffix`}>{suffix}</span>}\n            </div>\n          </Skeleton>\n          {extra && <div class={`${COMPONENT_NAME.value}-extra`}>{extra}</div>}\n        </div>\n      );\n    };\n  },\n});", "output": "import { mount } from '@vue/test-utils';\nimport Statistic from '@tdesign/components/statistic';\n\ndescribe('Statistic', () => {\n  describe(':props', () => {\n    it('title', () => {\n      const wrapper = mount({\n        render() {\n          return <Statistic title=\"Total Assets\" value={82.76} />;\n        },\n      });\n      expect(wrapper.find('.t-statistic-title').exists()).toBe(true);\n      expect(wrapper.find('.t-statistic-title').text()).toBe('Total Assets');\n    });\n\n    it('value', () => {\n      const wrapper = mount({\n        render() {\n          return <Statistic title=\"Total Assets\" value={82.76} unit=\"%\" trend=\"increase\" />;\n        },\n      });\n      expect(wrapper.find('.t-statistic-content-value').exists()).toBe(true);\n      expect(wrapper.find('.t-statistic-content-value').text()).toBe('82.76');\n    });\n\n    it('unit', () => {\n      const wrapper = mount(Statistic, {\n        propsData: {\n          title: 'Total Sales',\n          value: 1000,\n          unit: 'pcs',\n        },\n      });\n\n      expect(wrapper.find('.t-statistic-content-unit').text()).toBe('pcs');\n    });\n\n    it('decimalPlaces', () => {\n      const wrapper = mount({\n        render() {\n          return <Statistic title=\"Total Assets\" value={123.45678} decimalPlaces={3} />;\n        },\n      });\n      expect(wrapper.find('.t-statistic-content-value').exists()).toBe(true);\n      expect(wrapper.find('.t-statistic-content-value').text()).toBe('123.457');\n    });\n\n    it('prefix', () => {\n      const wrapper = mount(Statistic, {\n        propsData: {\n          title: 'Total Sales',\n          value: 1000,\n          prefix: '$',\n        },\n      });\n\n      expect(wrapper.find('.t-statistic-content-prefix').text()).toBe('$');\n    });\n\n    it('suffix', () => {\n      const wrapper = mount(Statistic, {\n        propsData: {\n          title: 'Total Sales',\n          value: 1000,\n          suffix: 'K',\n        },\n      });\n\n      expect(wrapper.find('.t-statistic-content-suffix').text()).toBe('K');\n    });\n\n    it('loading', async () => {\n      const wrapper = mount(Statistic, {\n        propsData: {\n          title: 'Downloads',\n          value: 1000,\n          loading: true,\n        },\n      });\n\n      expect(wrapper.find('.t-statistic-title').text()).toBe('Downloads');\n      expect(wrapper.find('.t-skeleton').exists()).toBe(true);\n      expect(wrapper.find('.t-skeleton__row').exists()).toBe(true);\n    });\n\n    it('trend=\"increase\"', () => {\n      const wrapper = mount(Statistic, {\n        propsData: {\n          title: 'Total Sales',\n          value: 1000,\n          trend: 'increase',\n        },\n      });\n\n      const trendIconElement = wrapper.find('.t-icon.t-icon-arrow-triangle-up-filled');\n      expect(trendIconElement.exists()).toBe(true);\n      expect(trendIconElement.element.tagName).toBe('svg');\n    });\n\n    it('trend=\"decrease\"', () => {\n      const wrapper = mount(Statistic, {\n        propsData: {\n          title: 'Total Sales',\n          value: 1000,\n          trend: 'decrease',\n        },\n      });\n\n      const trendIconElement = wrapper.find('.t-icon.t-icon-arrow-triangle-down-filled');\n      expect(trendIconElement.exists()).toBe(true);\n      expect(trendIconElement.element.tagName).toBe('svg');\n    });\n  });\n});", "meta": {"repo": "Tencent/tdesign-vue-next", "stars": 1770, "component": "packages/components/statistic/statistic.tsx", "test": "packages/components/statistic/__tests__/statistic.test.tsx"}}
{"input": "/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0; you may not use this file except in compliance with the Elastic License\n * 2.0.\n */\n\nimport { ColorMappingInputData, PaletteOutput, getFallbackDataBounds } from '@kbn/coloring';\nimport React, {\n  useLayoutEffect,\n  useCallback,\n  useMemo,\n  useRef,\n  useState,\n  useContext,\n  useEffect,\n} from 'react';\nimport { i18n } from '@kbn/i18n';\nimport useDeepCompareEffect from 'react-use/lib/useDeepCompareEffect';\nimport {\n  EuiButtonIcon,\n  EuiDataGrid,\n  EuiDataGridRefProps,\n  EuiDataGridControlColumn,\n  EuiDataGridColumn,\n  EuiDataGridSorting,\n  EuiDataGridStyle,\n} from '@elastic/eui';\nimport { CustomPaletteState, EmptyPlaceholder } from '@kbn/charts-plugin/public';\nimport { ClickTriggerEvent } from '@kbn/charts-plugin/public';\nimport { IconChartDatatable } from '@kbn/chart-icons';\nimport { getOriginalId } from '@kbn/transpose-utils';\nimport { useKbnPalettes } from '@kbn/palettes';\nimport type { IFieldFormat } from '@kbn/field-formats-plugin/common';\nimport { getColorCategories, getLegacyColorCategories } from '@kbn/chart-expressions-common';\nimport { css } from '@emotion/react';\nimport { DATA_GRID_DENSITY_STYLE_MAP } from '@kbn/unified-data-table/src/hooks/use_data_grid_density';\nimport { DATA_GRID_STYLE_NORMAL } from '@kbn/unified-data-table/src/constants';\nimport { useKibanaIsDarkMode } from '@kbn/react-kibana-context-theme/hooks';\nimport type { LensTableRowContextMenuEvent } from '../../../types';\nimport { RowHeightMode } from '../../../../common/types';\nimport { LensGridDirection } from '../../../../common/expressions';\nimport { findMinMaxByColumnId, shouldColorByTerms } from '../../../shared_components';\nimport type {\n  DataContextType,\n  DatatableRenderProps,\n  LensSortAction,\n  LensResizeAction,\n  LensToggleAction,\n  LensPagesizeAction,\n} from './types';\nimport { createGridColumns } from './columns';\nimport { createGridCell } from './cell_value';\nimport {\n  buildSchemaDetectors,\n  createGridFilterHandler,\n  createGridHideHandler,\n  createGridResizeHandler,\n  createGridSortingConfig,\n  createTransposeColumnFilterHandler,\n} from './table_actions';\nimport { getFinalSummaryConfiguration } from '../../../../common/expressions/impl/datatable/summary';\nimport { DEFAULT_HEADER_ROW_HEIGHT, DEFAULT_HEADER_ROW_HEIGHT_LINES } from './constants';\nimport {\n  getDatatableColumn,\n  isNumericField,\n} from '../../../../common/expressions/impl/datatable/utils';\nimport { CellColorFn, getCellColorFn } from '../../../shared_components/coloring/get_cell_color_fn';\nimport { getColumnAlignment } from '../utils';\n\nexport const DataContext = React.createContext<DataContextType>({});\n\nconst DATA_GRID_STYLE_DEFAULT: EuiDataGridStyle = {\n  border: 'horizontal',\n  header: 'shade',\n  footer: 'shade',\n};\n\nexport const DEFAULT_PAGE_SIZE = 10;\nconst PAGE_SIZE_OPTIONS = [DEFAULT_PAGE_SIZE, 20, 30, 50, 100];\n\nexport const DatatableComponent = (props: DatatableRenderProps) => {\n  const dataGridRef = useRef<EuiDataGridRefProps>(null);\n\n  const isInteractive = props.interactive;\n  const isDarkMode = useKibanaIsDarkMode();\n  const palettes = useKbnPalettes();\n\n  const [columnConfig, setColumnConfig] = useState({\n    columns: props.args.columns,\n    sortingColumnId: props.args.sortingColumnId,\n    sortingDirection: props.args.sortingDirection,\n  });\n  const [firstLocalTable, updateTable] = useState(props.data);\n\n  // ** Pagination config\n  const [pagination, setPagination] = useState<{ pageIndex: number; pageSize: number } | undefined>(\n    undefined\n  );\n\n  useLayoutEffect(() => {\n    // Temporary solution: DataGrid should provide onRender callback\n    setTimeout(() => {\n      props.renderComplete();\n    }, 300);\n  }, [props]);\n\n  useEffect(() => {\n    setPagination(\n      props.args.pageSize\n        ? {\n            pageIndex: 0,\n            pageSize: props.args.pageSize ?? DEFAULT_PAGE_SIZE,\n          }\n        : undefined\n    );\n  }, [props.args.pageSize]);\n\n  useDeepCompareEffect(() => {\n    setColumnConfig({\n      columns: props.args.columns,\n      sortingColumnId: props.args.sortingColumnId,\n      sortingDirection: props.args.sortingDirection,\n    });\n  }, [props.args.columns, props.args.sortingColumnId, props.args.sortingDirection]);\n\n  useDeepCompareEffect(() => {\n    updateTable(props.data);\n  }, [props.data]);\n\n  const firstTableRef = useRef(firstLocalTable);\n  firstTableRef.current = firstLocalTable;\n\n  useEffect(() => {\n    if (!pagination?.pageIndex && !pagination?.pageSize) return;\n    const lastPageIndex = firstLocalTable.rows.length\n      ? Math.ceil(firstLocalTable.rows.length / pagination.pageSize) - 1\n      : 0;\n    /**\n     * When the underlying data changes, there might be a case when actual pagination page\n     * doesn't exist anymore - if the number of rows has decreased.\n     * Set the last page as an actual.\n     */\n    setPagination((pag) => {\n      if (!pag) {\n        return pag;\n      }\n      return {\n        pageIndex: pag.pageIndex > lastPageIndex ? lastPageIndex : pag.pageIndex,\n        pageSize: pag.pageSize,\n      };\n    });\n  }, [pagination?.pageIndex, pagination?.pageSize, firstLocalTable.rows.length]);\n\n  const untransposedDataRef = useRef(props.untransposedData);\n  untransposedDataRef.current = props.untransposedData;\n\n  const hasAtLeastOneRowClickAction = props.rowHasRowClickTriggerActions?.some((x) => x);\n\n  const { getType, dispatchEvent, renderMode, formatFactory, syncColors } = props;\n\n  const formatters: Record<string, IFieldFormat> = useMemo(\n    () =>\n      firstLocalTable.columns.reduce(\n        (map, column) => ({\n          ...map,\n          [column.id]: formatFactory(column.meta?.params),\n        }),\n        {}\n      ),\n    [firstLocalTable, formatFactory]\n  );\n\n  const onClickValue = useCallback(\n    (data: ClickTriggerEvent['data']) => {\n      dispatchEvent({ name: 'filter', data });\n    },\n    [dispatchEvent]\n  );\n\n  const onEditAction = useCallback(\n    (\n      data:\n        | LensSortAction['data']\n        | LensResizeAction['data']\n        | LensToggleAction['data']\n        | LensPagesizeAction['data']\n    ) => {\n      dispatchEvent({ name: 'edit', data });\n    },\n    [dispatchEvent]\n  );\n\n  const onChangeItemsPerPage = useCallback(\n    (pageSize: number) => onEditAction({ action: 'pagesize', size: pageSize }),\n    [onEditAction]\n  );\n\n  // active page isn't persisted, so we manage this state locally\n  const onChangePage = useCallback(\n    (pageIndex: number) => {\n      setPagination((_pagination) => {\n        if (_pagination) {\n          return { pageSize: _pagination?.pageSize, pageIndex };\n        }\n      });\n    },\n    [setPagination]\n  );\n\n  const onRowContextMenuClick = useCallback(\n    (data: LensTableRowContextMenuEvent['data']) => {\n      dispatchEvent({ name: 'tableRowContextMenuClick', data });\n    },\n    [dispatchEvent]\n  );\n\n  const handleFilterClick = useMemo(\n    () => (isInteractive ? createGridFilterHandler(firstTableRef, onClickValue) : undefined),\n    [firstTableRef, onClickValue, isInteractive]\n  );\n\n  const columnCellValueActions = useMemo(\n    () => (isInteractive ? props.columnCellValueActions : undefined),\n    [props.columnCellValueActions, isInteractive]\n  );\n\n  const handleTransposedColumnClick = useMemo(\n    () =>\n      isInteractive\n        ? createTransposeColumnFilterHandler(onClickValue, untransposedDataRef)\n        : undefined,\n    [onClickValue, untransposedDataRef, isInteractive]\n  );\n\n  const bucketedColumns = useMemo(\n    () =>\n      columnConfig.columns\n        .filter((_col, index) => {\n          const col = firstTableRef.current.columns[index];\n          return getType(col?.meta)?.type === 'buckets';\n        })\n        .map((col) => col.columnId),\n    [firstTableRef, columnConfig, getType]\n  );\n\n  const isEmpty =\n    firstLocalTable.rows.length === 0 ||\n    (bucketedColumns.length > 0 &&\n      props.data.rows.every((row) => bucketedColumns.every((col) => row[col] == null)));\n\n  const visibleColumns = useMemo(\n    () =>\n      columnConfig.columns\n        .filter((col) => !!col.columnId && !col.hidden)\n        .map((col) => col.columnId),\n    [columnConfig]\n  );\n\n  const isReadOnlySorted = renderMode !== 'edit';\n\n  const onColumnResize = useMemo(\n    () => createGridResizeHandler(columnConfig, setColumnConfig, onEditAction),\n    [onEditAction, setColumnConfig, columnConfig]\n  );\n\n  const onColumnHide = useMemo(\n    () =>\n      isInteractive\n        ? createGridHideHandler(columnConfig, setColumnConfig, onEditAction)\n        : undefined,\n    [onEditAction, setColumnConfig, columnConfig, isInteractive]\n  );\n\n  const isNumericMap: Map<string, boolean> = useMemo(\n    () =>\n      firstLocalTable.columns.reduce((acc, column) => {\n        acc.set(column.id, isNumericField(column.meta));\n        return acc;\n      }, new Map<string, boolean>()),\n    [firstLocalTable.columns]\n  );\n\n  const alignments: Map<string, 'left' | 'right' | 'center'> = useMemo(() => {\n    return columnConfig.columns.reduce((acc, column) => {\n      acc.set(column.columnId, getColumnAlignment(column, isNumericMap.get(column.columnId)));\n      return acc;\n    }, new Map<string, 'left' | 'right' | 'center'>());\n  }, [columnConfig.columns, isNumericMap]);\n\n  const minMaxByColumnId: Map<string, { min: number; max: number }> = useMemo(() => {\n    return findMinMaxByColumnId(\n      columnConfig.columns\n        .filter(({ columnId }) => isNumericMap.get(columnId))\n        .map(({ columnId }) => columnId),\n      props.data\n    );\n  }, [props.data, isNumericMap, columnConfig]);\n\n  const headerRowHeight = props.args.headerRowHeight ?? DEFAULT_HEADER_ROW_HEIGHT;\n  const headerRowLines = props.args.headerRowHeightLines ?? DEFAULT_HEADER_ROW_HEIGHT_LINES;\n\n  const columns: EuiDataGridColumn[] = useMemo(\n    () =>\n      createGridColumns(\n        bucketedColumns,\n        firstLocalTable,\n        handleFilterClick,\n        handleTransposedColumnClick,\n        isReadOnlySorted,\n        columnConfig,\n        visibleColumns,\n        formatFactory,\n        onColumnResize,\n        onColumnHide,\n        alignments,\n        headerRowHeight,\n        headerRowLines,\n        columnCellValueActions,\n        dataGridRef.current?.closeCellPopover,\n        props.columnFilterable\n      ),\n    [\n      bucketedColumns,\n      firstLocalTable,\n      handleFilterClick,\n      handleTransposedColumnClick,\n      isReadOnlySorted,\n      columnConfig,\n      visibleColumns,\n      formatFactory,\n      onColumnResize,\n      onColumnHide,\n      alignments,\n      headerRowHeight,\n      headerRowLines,\n      columnCellValueActions,\n      props.columnFilterable,\n    ]\n  );\n\n  const schemaDetectors = useMemo(\n    () => buildSchemaDetectors(columns, columnConfig, firstLocalTable, formatters),\n    [columns, firstLocalTable, columnConfig, formatters]\n  );\n\n  const trailingControlColumns: EuiDataGridControlColumn[] = useMemo(() => {\n    if (!hasAtLeastOneRowClickAction || !onRowContextMenuClick || !isInteractive) {\n      return [];\n    }\n    return [\n      {\n        headerCellRender: () => null,\n        width: 40,\n        id: 'trailingControlColumn',\n        rowCellRender: function RowCellRender({ rowIndex }) {\n          const { rowHasRowClickTriggerActions } = useContext(DataContext);\n          return (\n            <EuiButtonIcon\n              aria-label={i18n.translate('xpack.lens.table.actionsLabel', {\n                defaultMessage: 'Show actions',\n              })}\n              iconType={\n                !!rowHasRowClickTriggerActions && !rowHasRowClickTriggerActions[rowIndex]\n                  ? 'empty'\n                  : 'boxesVertical'\n              }\n              color=\"text\"\n              onClick={() => {\n                onRowContextMenuClick({\n                  rowIndex,\n                  table: firstTableRef.current,\n                  columns: columnConfig.columns.map((col) => col.columnId),\n                });\n              }}\n            />\n          );\n        },\n      },\n    ];\n  }, [\n    firstTableRef,\n    onRowContextMenuClick,\n    columnConfig,\n    hasAtLeastOneRowClickAction,\n    isInteractive,\n  ]);\n\n  const renderCellValue = useMemo(() => {\n    const cellColorFnMap = new Map<string, CellColorFn>();\n    const getCellColor = (\n      columnId: string,\n      palette?: PaletteOutput<CustomPaletteState>,\n      colorMapping?: string\n    ): CellColorFn => {\n      const originalId = getOriginalId(columnId); // workout what bucket the value belongs to\n\n      if (cellColorFnMap.has(originalId)) {\n        return cellColorFnMap.get(originalId)!;\n      }\n\n      const colInfo = getDatatableColumn(firstLocalTable, originalId);\n      const isBucketed = bucketedColumns.some((id) => id === columnId);\n      const colorByTerms = shouldColorByTerms(colInfo?.meta.type, isBucketed);\n      const categoryRows = (untransposedDataRef.current ?? firstLocalTable)?.rows;\n\n      const data: ColorMappingInputData = colorByTerms\n        ? {\n            type: 'categories',\n            categories: colorMapping\n              ? getColorCategories(categoryRows, originalId, [null])\n              : getLegacyColorCategories(categoryRows, originalId, [null]),\n          }\n        : {\n            type: 'ranges',\n            bins: 0,\n            ...(minMaxByColumnId.get(originalId) ?? getFallbackDataBounds()),\n          };\n      const colorFn = getCellColorFn(\n        props.paletteService,\n        palettes,\n        data,\n        colorByTerms,\n        isDarkMode,\n        syncColors,\n        palette,\n        colorMapping\n      );\n      cellColorFnMap.set(originalId, colorFn);\n\n      return colorFn;\n    };\n\n    return createGridCell(\n      formatters,\n      columnConfig,\n      DataContext,\n      isDarkMode,\n      getCellColor,\n      props.args.fitRowToContent\n    );\n  }, [\n    formatters,\n    columnConfig,\n    isDarkMode,\n    props.args.fitRowToContent,\n    props.paletteService,\n    palettes,\n    firstLocalTable,\n    bucketedColumns,\n    minMaxByColumnId,\n    syncColors,\n  ]);\n\n  const columnVisibility = useMemo(\n    () => ({\n      visibleColumns,\n      setVisibleColumns: () => {},\n    }),\n    [visibleColumns]\n  );\n\n  const sorting = useMemo<EuiDataGridSorting | undefined>(\n    () =>\n      createGridSortingConfig(\n        columnConfig.sortingColumnId,\n        columnConfig.sortingDirection as LensGridDirection,\n        onEditAction\n      ),\n    [onEditAction, columnConfig]\n  );\n\n  const renderSummaryRow = useMemo(() => {\n    const columnsWithSummary = columnConfig.columns\n      .filter((col) => !!col.columnId && !col.hidden)\n      .map((config) => ({\n        columnId: config.columnId,\n        summaryRowValue: config.summaryRowValue,\n        ...getFinalSummaryConfiguration(config.columnId, config, props.data),\n      }))\n      .filter(({ summaryRow }) => summaryRow !== 'none');\n\n    if (columnsWithSummary.length) {\n      const summaryLookup = Object.fromEntries(\n        columnsWithSummary.map(({ summaryRowValue, summaryLabel, columnId }) => [\n          columnId,\n          summaryLabel === '' ? `${summaryRowValue}` : `${summaryLabel}: ${summaryRowValue}`,\n        ])\n      );\n      return ({ columnId }: { columnId: string }) => {\n        const currentAlignment = alignments.get(columnId);\n        const alignmentClassName = `lnsTableCell--${currentAlignment}`;\n        const columnName =\n          columns.find(({ id }) => id === columnId)?.displayAsText?.replace(/ /g, '-') || columnId;\n        return summaryLookup[columnId] != null ? (\n          <div\n            className={`lnsTableCell ${alignmentClassName}`}\n            data-test-subj={`lnsDataTable-footer-${columnName}`}\n          >\n            {summaryLookup[columnId]}\n          </div>\n        ) : null;\n      };\n    }\n  }, [columnConfig.columns, alignments, props.data, columns]);\n\n  const gridStyle = useMemo<EuiDataGridStyle>(\n    () => ({\n      ...DATA_GRID_STYLE_DEFAULT,\n      ...(props.args.density\n        ? DATA_GRID_DENSITY_STYLE_MAP[props.args.density]\n        : DATA_GRID_STYLE_NORMAL),\n    }),\n    [props.args.density]\n  );\n\n  if (isEmpty) {\n    return (\n      <div\n        css={datatableContainerStyles}\n        className=\"eui-scrollBar\"\n        data-test-subj=\"lnsVisualizationContainer\"\n      >\n        <EmptyPlaceholder icon={IconChartDatatable} />\n      </div>\n    );\n  }\n\n  const dataGridAriaLabel =\n    props.args.title ||\n    i18n.translate('xpack.lens.table.defaultAriaLabel', {\n      defaultMessage: 'Data table visualization',\n    });\n\n  return (\n    <div\n      css={datatableContainerStyles}\n      className=\"eui-scrollBar\"\n      data-test-subj=\"lnsVisualizationContainer\"\n    >\n      <DataContext.Provider\n        value={{\n          table: firstLocalTable,\n          rowHasRowClickTriggerActions: props.rowHasRowClickTriggerActions,\n          alignments,\n          minMaxByColumnId,\n          handleFilterClick,\n        }}\n      >\n        <EuiDataGrid\n          aria-label={dataGridAriaLabel}\n          data-test-subj=\"lnsDataTable\"\n          rowHeightsOptions={{\n            defaultHeight: props.args.fitRowToContent\n              ? RowHeightMode.auto\n              : props.args.rowHeightLines && props.args.rowHeightLines !== 1\n              ? {\n                  lineCount: props.args.rowHeightLines,\n                }\n              : undefined,\n          }}\n          inMemory={{ level: 'sorting' }}\n          columns={columns}\n          columnVisibility={columnVisibility}\n          trailingControlColumns={trailingControlColumns}\n          rowCount={firstLocalTable.rows.length}\n          renderCellValue={renderCellValue}\n          gridStyle={gridStyle}\n          schemaDetectors={schemaDetectors}\n          sorting={sorting}\n          pagination={\n            pagination && {\n              ...pagination,\n              pageSizeOptions: PAGE_SIZE_OPTIONS,\n              onChangeItemsPerPage,\n              onChangePage,\n            }\n          }\n          onColumnResize={onColumnResize}\n          toolbarVisibility={false}\n          renderFooterCellValue={renderSummaryRow}\n          ref={dataGridRef}\n        />\n      </DataContext.Provider>\n    </div>\n  );\n};\n\nconst datatableContainerStyles = css`\n  height: 100%;\n  overflow: auto hidden;\n  user-select: text;\n\n  .lnsTableCell--multiline {\n    white-space: pre-wrap;\n  }\n\n  .lnsTableCell--left {\n    text-align: left;\n  }\n\n  .lnsTableCell--right {\n    text-align: right;\n  }\n\n  .lnsTableCell--center {\n    text-align: center;\n  }\n`;", "output": "/*\n * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n * or more contributor license agreements. Licensed under the Elastic License\n * 2.0; you may not use this file except in compliance with the Elastic License\n * 2.0.\n */\n\nimport React from 'react';\nimport { fireEvent, render, screen, within } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { I18nProvider } from '@kbn/i18n-react';\nimport { faker } from '@faker-js/faker';\nimport { act } from 'react-dom/test-utils';\nimport { IFieldFormat } from '@kbn/field-formats-plugin/common';\nimport { coreMock } from '@kbn/core/public/mocks';\nimport { chartPluginMock } from '@kbn/charts-plugin/public/mocks';\nimport { Datatable } from '@kbn/expressions-plugin/common';\nimport { DatatableComponent } from './table_basic';\nimport type { DatatableProps } from '../../../../common/expressions';\nimport { LENS_EDIT_PAGESIZE_ACTION } from './constants';\nimport { DatatableRenderProps } from './types';\nimport { PaletteOutput } from '@kbn/coloring';\nimport { getTransposeId } from '@kbn/transpose-utils';\nimport { CustomPaletteState } from '@kbn/charts-plugin/common';\nimport { getCellColorFn } from '../../../shared_components/coloring/get_cell_color_fn';\nimport { DataGridDensity } from '@kbn/unified-data-table';\n\njest.mock('../../../shared_components/coloring/get_cell_color_fn', () => {\n  const mod = jest.requireActual('../../../shared_components/coloring/get_cell_color_fn');\n  return {\n    ...mod,\n    getCellColorFn: jest.fn(mod.getCellColorFn),\n  };\n});\n\nconst { theme: setUpMockTheme } = coreMock.createSetup();\n\nfunction sampleArgs() {\n  const indexPatternId = 'indexPatternId';\n  const data: Datatable = {\n    type: 'datatable',\n    columns: [\n      {\n        id: 'a',\n        name: 'a',\n        meta: {\n          type: 'string',\n          source: 'esaggs',\n          field: 'a',\n          sourceParams: { type: 'terms', indexPatternId },\n        },\n      },\n      {\n        id: 'b',\n        name: 'b',\n        meta: {\n          type: 'date',\n          field: 'b',\n          source: 'esaggs',\n          sourceParams: {\n            type: 'date_histogram',\n            indexPatternId,\n          },\n        },\n      },\n      {\n        id: 'c',\n        name: 'c',\n        meta: {\n          type: 'number',\n          source: 'esaggs',\n          field: 'c',\n          sourceParams: { indexPatternId, type: 'count' },\n        },\n      },\n      {\n        id: 'd',\n        name: 'd',\n        meta: {\n          type: 'number',\n          source: 'esaggs',\n          field: 'd',\n          params: { id: 'range' },\n          sourceParams: { indexPatternId, type: 'range' },\n        },\n      },\n    ],\n    rows: [{ a: 'shoes', b: 1588024800000, c: 3 }],\n  };\n\n  const args: DatatableProps['args'] = {\n    title: 'My fanci metric chart',\n    columns: [\n      { columnId: 'a', type: 'lens_datatable_column' },\n      { columnId: 'b', type: 'lens_datatable_column' },\n      { columnId: 'c', type: 'lens_datatable_column' },\n    ],\n    sortingColumnId: '',\n    sortingDirection: 'none',\n    rowHeightLines: 1,\n  };\n\n  return { data, args };\n}\n\nfunction copyData<T>(data: T): T {\n  return JSON.parse(JSON.stringify(data));\n}\n\ndescribe('DatatableComponent', () => {\n  let onDispatchEvent: jest.Mock;\n  let renderComplete: jest.Mock;\n\n  let { data, args } = sampleArgs();\n  beforeEach(() => {\n    onDispatchEvent = jest.fn();\n    renderComplete = jest.fn();\n    const sample = sampleArgs();\n    data = sample.data;\n    args = sample.args;\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  const renderDatatableComponent = (propsOverrides: Partial<DatatableRenderProps> = {}) => {\n    const props: DatatableRenderProps = {\n      data,\n      args,\n      formatFactory: () => ({ convert: (x) => x } as IFieldFormat),\n      dispatchEvent: onDispatchEvent,\n      getType: jest.fn().mockReturnValue({\n        type: 'buckets',\n      }),\n      paletteService: chartPluginMock.createPaletteRegistry(),\n      theme: setUpMockTheme,\n      renderMode: 'edit' as const,\n      interactive: true,\n      syncColors: false,\n      renderComplete,\n      ...propsOverrides,\n    };\n    const rtlRender = render(<DatatableComponent {...props} />, { wrapper: I18nProvider });\n    return {\n      ...rtlRender,\n      rerender: (newProps: Partial<DatatableRenderProps>) =>\n        rtlRender.rerender(<DatatableComponent {...props} {...newProps} />),\n    };\n  };\n\n  test('it renders the title and value', () => {\n    renderDatatableComponent();\n    expect(screen.getByLabelText('My fanci metric chart')).toBeInTheDocument();\n    expect(screen.getByRole('row')).toBeInTheDocument();\n    expect(screen.queryAllByRole('gridcell').map((cell) => cell.textContent)).toEqual([\n      'shoes',\n      '1588024800000',\n      '3',\n    ]);\n  });\n\n  test('it renders actions column when there are row actions', () => {\n    const rowHasRowClickTriggerActions = [true, true, true];\n    renderDatatableComponent({ rowHasRowClickTriggerActions });\n    expect(screen.getByRole('button', { name: 'Show actions' })).toBeInTheDocument();\n  });\n  test('it does not render actions column when there are row actions', () => {\n    const rowHasRowClickTriggerActions = [false, false, false];\n    renderDatatableComponent({ rowHasRowClickTriggerActions });\n    expect(screen.queryByRole('button', { name: 'Show actions' })).not.toBeInTheDocument();\n  });\n\n  test('it renders custom row height if set to another value than 1', () => {\n    renderDatatableComponent({\n      args: {\n        ...args,\n        rowHeightLines: 5,\n      },\n    });\n    screen.getAllByRole('gridcell').forEach((cell) => {\n      expect(cell.firstChild).toHaveClass('euiDataGridRowCell__content--lineCountHeight');\n    });\n  });\n\n  test('it should render hide, reset, and sort actions on header even when it is in read only mode', async () => {\n    renderDatatableComponent({ renderMode: 'view' });\n    await userEvent.click(screen.getByTestId('dataGridHeaderCellActionButton-a'));\n    const actionPopover = screen.getByRole('dialog');\n    const actions = within(actionPopover)\n      .getAllByRole('button')\n      .map((button) => button.textContent);\n    expect(actions).toEqual(['Sort ascending', 'Sort descending', 'Reset width', 'Hide']);\n  });\n\n  test('it invokes executeTriggerActions with correct context on click on top value', async () => {\n    renderDatatableComponent({ columnFilterable: [true, true, true] });\n    await userEvent.hover(screen.getAllByTestId('dataGridRowCell')[0]);\n    await userEvent.click(screen.getByTestId('lensDatatableFilterOut'));\n\n    expect(onDispatchEvent).toHaveBeenCalledWith({\n      name: 'filter',\n      data: {\n        data: [\n          {\n            column: 0,\n            row: 0,\n            table: data,\n            value: 'shoes',\n          },\n        ],\n        negate: true,\n      },\n    });\n  });\n\n  test('it invokes executeTriggerActions with correct context on click on timefield', async () => {\n    renderDatatableComponent({ columnFilterable: [true, true, true] });\n    await userEvent.hover(screen.getAllByTestId('dataGridRowCell')[1]);\n    await userEvent.click(screen.getByTestId('lensDatatableFilterFor'));\n\n    expect(onDispatchEvent).toHaveBeenCalledWith({\n      name: 'filter',\n      data: {\n        data: [\n          {\n            column: 1,\n            row: 0,\n            table: data,\n            value: 1588024800000,\n          },\n        ],\n        negate: false,\n      },\n    });\n  });\n\n  test('it invokes executeTriggerActions with correct context on click on timefield from range', async () => {\n    const dataWithTimestamp: Datatable = {\n      type: 'datatable',\n      columns: [\n        {\n          id: 'a',\n          name: 'a',\n          meta: {\n            type: 'date',\n            source: 'esaggs',\n            field: 'a',\n            sourceParams: { type: 'date_range', indexPatternId: 'a' },\n          },\n        },\n        {\n          id: 'b',\n          name: 'b',\n          meta: {\n            type: 'number',\n            source: 'esaggs',\n            sourceParams: { type: 'count', indexPatternId: 'a' },\n          },\n        },\n      ],\n      rows: [{ a: 1588024800000, b: 3 }],\n    };\n\n    renderDatatableComponent({\n      data: dataWithTimestamp,\n      columnFilterable: [true, true, true],\n      args: {\n        title: '',\n        columns: [\n          { columnId: 'a', type: 'lens_datatable_column' },\n          { columnId: 'b', type: 'lens_datatable_column' },\n        ],\n        sortingColumnId: '',\n        sortingDirection: 'none',\n        rowHeightLines: 1,\n      },\n    });\n\n    await userEvent.hover(screen.getAllByTestId('dataGridRowCell')[0]);\n    await userEvent.click(screen.getByTestId('lensDatatableFilterFor'));\n\n    expect(onDispatchEvent).toHaveBeenCalledWith({\n      name: 'filter',\n      data: {\n        data: [\n          {\n            column: 0,\n            row: 0,\n            table: dataWithTimestamp,\n            value: 1588024800000,\n          },\n        ],\n        negate: false,\n      },\n    });\n  });\n\n  test('it should not invoke executeTriggerActions if interactivity is set to false', async () => {\n    renderDatatableComponent({ columnFilterable: [true, true, true], interactive: false });\n    await userEvent.hover(screen.getAllByTestId('dataGridRowCell')[0]);\n    expect(screen.queryByTestId('lensDatatableFilterOut')).not.toBeInTheDocument();\n  });\n\n  test('it shows emptyPlaceholder for undefined bucketed data', () => {\n    renderDatatableComponent({\n      data: {\n        ...data,\n        rows: [{ a: undefined, b: undefined, c: undefined }],\n      },\n    });\n    expect(screen.getByTestId('lnsVisualizationContainer')).toHaveTextContent('No results found');\n  });\n\n  test('it renders the table with the given sorting', async () => {\n    renderDatatableComponent({\n      args: {\n        ...args,\n        sortingColumnId: 'b',\n        sortingDirection: 'desc',\n      },\n    });\n    expect(screen.getByTestId('dataGridHeaderCellSortingIcon-b')).toHaveAttribute(\n      'data-euiicon-type',\n      'sortDown'\n    );\n    await userEvent.click(screen.getByTestId('dataGridHeaderCellActionButton-b'));\n    fireEvent.click(screen.getByRole('button', { name: 'Sort ascending' }));\n\n    expect(onDispatchEvent).toHaveBeenCalledWith({\n      name: 'edit',\n      data: {\n        action: 'sort',\n        columnId: 'b',\n        direction: 'asc',\n      },\n    });\n  });\n\n  test('it renders the table with the given sorting in readOnly mode', () => {\n    renderDatatableComponent({\n      args: {\n        ...args,\n        sortingColumnId: 'b',\n        sortingDirection: 'desc',\n      },\n    });\n    expect(screen.getByTestId('dataGridHeaderCellSortingIcon-b')).toHaveAttribute(\n      'data-euiicon-type',\n      'sortDown'\n    );\n  });\n\n  test('it does not render a hidden column', () => {\n    renderDatatableComponent({\n      args: {\n        ...args,\n        columns: [\n          { columnId: 'a', hidden: true, type: 'lens_datatable_column' },\n          { columnId: 'b', type: 'lens_datatable_column' },\n          { columnId: 'c', type: 'lens_datatable_column' },\n        ],\n        sortingColumnId: 'b',\n        sortingDirection: 'desc',\n      },\n    });\n    expect(screen.queryAllByRole('gridcell').map((cell) => cell.textContent)).toEqual([\n      '1588024800000',\n      '3',\n    ]);\n  });\n\n  test('it adds explicit alignment to context', () => {\n    renderDatatableComponent({\n      args: {\n        ...args,\n        columns: [\n          { columnId: 'a', alignment: 'center', type: 'lens_datatable_column', colorMode: 'none' },\n          { columnId: 'b', alignment: 'center', type: 'lens_datatable_column', colorMode: 'none' },\n          { columnId: 'c', alignment: 'center', type: 'lens_datatable_column', colorMode: 'none' },\n          { columnId: 'd', alignment: 'center', type: 'lens_datatable_column', colorMode: 'none' },\n        ],\n      },\n    });\n    const alignmentsClassNames = screen\n      .getAllByTestId('lnsTableCellContent')\n      .map((cell) => cell.className);\n\n    expect(alignmentsClassNames).toEqual([\n      'lnsTableCell--center', // set via args\n      'lnsTableCell--center', // set via args\n      'lnsTableCell--center', // set via args\n      'lnsTableCell--center', // set via args\n    ]);\n  });\n\n  test('it adds default alignment data to context', () => {\n    renderDatatableComponent({\n      args: {\n        ...args,\n        columns: [\n          { columnId: 'a', type: 'lens_datatable_column', colorMode: 'none' },\n          { columnId: 'b', type: 'lens_datatable_column', colorMode: 'none' },\n          { columnId: 'c', type: 'lens_datatable_column', colorMode: 'none' },\n          { columnId: 'd', type: 'lens_datatable_column', colorMode: 'none' },\n        ],\n        sortingColumnId: 'b',\n        sortingDirection: 'desc',\n      },\n    });\n    const alignmentsClassNames = screen\n      .getAllByTestId('lnsTableCellContent')\n      .map((cell) => cell.className);\n\n    expect(alignmentsClassNames).toEqual([\n      'lnsTableCell--left', // default for string\n      'lnsTableCell--left', // default for date\n      'lnsTableCell--right', // default for number\n      'lnsTableCell--left', // default for range\n    ]);\n  });\n\n  test('it should refresh the table header when the datatable data changes', () => {\n    const { rerender } = renderDatatableComponent();\n    const newData = copyData(data);\n    newData.columns[0].name = 'new a';\n    rerender({ data: newData });\n    expect(screen.getAllByTestId('dataGridHeader')[0]).toHaveTextContent('new a');\n  });\n\n  test('it does render a summary footer if at least one column has it configured', () => {\n    renderDatatableComponent({\n      args: {\n        ...args,\n        columns: [\n          ...args.columns.slice(0, 2),\n          {\n            columnId: 'c',\n            type: 'lens_datatable_column',\n            summaryRow: 'sum',\n            summaryLabel: 'Sum',\n            summaryRowValue: 3,\n          },\n        ],\n        sortingColumnId: 'b',\n        sortingDirection: 'desc',\n      },\n    });\n    expect(screen.queryByTestId('lnsDataTable-footer-a')).not.toBeInTheDocument();\n    expect(screen.getByTestId('lnsDataTable-footer-c')).toHaveTextContent('Sum: 3');\n  });\n\n  test('it does render a summary footer with just the raw value for empty label', () => {\n    renderDatatableComponent({\n      args: {\n        ...args,\n        columns: [\n          ...args.columns.slice(0, 2),\n          {\n            columnId: 'c',\n            type: 'lens_datatable_column',\n            summaryRow: 'sum',\n            summaryLabel: '',\n            summaryRowValue: 3,\n          },\n        ],\n        sortingColumnId: 'b',\n        sortingDirection: 'desc',\n      },\n    });\n    expect(screen.getByTestId('lnsDataTable-footer-c')).toHaveTextContent('3');\n  });\n\n  test('it does not render the summary row if the only column with summary is hidden', () => {\n    renderDatatableComponent({\n      args: {\n        ...args,\n        columns: [\n          ...args.columns.slice(0, 2),\n          {\n            columnId: 'c',\n            type: 'lens_datatable_column',\n            summaryRow: 'sum',\n            summaryLabel: '',\n            summaryRowValue: 3,\n            hidden: true,\n          },\n        ],\n        sortingColumnId: 'b',\n        sortingDirection: 'desc',\n      },\n    });\n    expect(screen.queryByTestId('lnsDataTable-footer-c')).not.toBeInTheDocument();\n  });\n\n  describe('pagination', () => {\n    it('disables pagination by default', async () => {\n      renderDatatableComponent();\n      expect(screen.queryByTestId('tablePaginationPopoverButton')).not.toBeInTheDocument();\n    });\n\n    it('enables pagination', async () => {\n      const rowNumbers = 13;\n      const pageSize = 4;\n      data.rows = new Array(rowNumbers).fill({\n        a: 'shoes',\n        b: 1588024800000,\n        c: faker.number.int(),\n      });\n\n      args.pageSize = pageSize;\n\n      const numberOfPages = Math.ceil(rowNumbers / pageSize);\n\n      renderDatatableComponent({\n        args,\n        data,\n      });\n      expect(screen.queryByTestId('tablePaginationPopoverButton')).toBeInTheDocument();\n      expect(screen.getByRole('button', { name: `Page 1 of ${numberOfPages}` })).toHaveAttribute(\n        'aria-current',\n        'page'\n      );\n      const newIndex = 3;\n      await userEvent.click(\n        screen.getByRole('link', { name: `Page ${newIndex} of ${numberOfPages}` })\n      );\n      expect(\n        screen.getByRole('button', { name: `Page ${newIndex} of ${numberOfPages}` })\n      ).toHaveAttribute('aria-current', 'page');\n    });\n    it('dynamically toggles pagination', async () => {\n      const argsWithoutPagination = copyData(args);\n      delete argsWithoutPagination.pageSize;\n\n      const rowNumbers = 13;\n      const pageSize = 4;\n      data.rows = new Array(rowNumbers).fill({\n        a: 'shoes',\n        b: 1588024800000,\n        c: faker.number.int(),\n      });\n\n      args.pageSize = pageSize;\n\n      const { rerender } = renderDatatableComponent({\n        args,\n        data,\n      });\n      expect(screen.queryByTestId('tablePaginationPopoverButton')).toBeInTheDocument();\n      await act(async () => {\n        rerender({ args: argsWithoutPagination });\n      });\n      expect(screen.queryByTestId('tablePaginationPopoverButton')).not.toBeInTheDocument();\n    });\n\n    it('dispatches event when page size changed', async () => {\n      args.pageSize = 2;\n      data.rows = new Array(20).fill({\n        a: 'shoes',\n        b: 1588024800000,\n        c: faker.number.int(),\n      });\n      renderDatatableComponent({\n        args,\n      });\n      await userEvent.click(screen.getByTestId('tablePaginationPopoverButton'));\n      const sizeToChangeTo = 100;\n      fireEvent.click(screen.getByRole('button', { name: `${sizeToChangeTo} rows` }));\n\n      expect(onDispatchEvent).toHaveBeenCalledTimes(1);\n      expect(onDispatchEvent).toHaveBeenCalledWith({\n        name: 'edit',\n        data: {\n          action: LENS_EDIT_PAGESIZE_ACTION,\n          size: sizeToChangeTo,\n        },\n      });\n    });\n\n    it('doesnt change page position when changing the data to a bigger set', async () => {\n      const rowNumbers = 10;\n      const pageSize = 2;\n      const numberOfPages = Math.ceil(rowNumbers / pageSize);\n      data.rows = new Array(rowNumbers).fill({\n        a: 'shoes',\n        b: 1588024800000,\n        c: faker.number.int(),\n      });\n\n      args.pageSize = pageSize;\n\n      const { rerender } = renderDatatableComponent({\n        args,\n        data,\n      });\n      const newIndex = 3;\n      await userEvent.click(\n        screen.getByRole('link', { name: `Page ${newIndex} of ${numberOfPages}` })\n      );\n      expect(\n        screen.getByRole('button', { name: `Page ${newIndex} of ${numberOfPages}` })\n      ).toHaveAttribute('aria-current', 'page');\n\n      await act(async () => {\n        rerender({\n          data: {\n            ...data,\n            rows: new Array(20).fill({ a: 'shoes', b: 1588024800000, c: 3 }),\n          },\n        });\n      });\n      const newNumberOfPages = Math.ceil(20 / pageSize);\n\n      // keeps existing page if more data is added\n      expect(\n        screen.getByRole('button', { name: `Page ${newIndex} of ${newNumberOfPages}` })\n      ).toHaveAttribute('aria-current', 'page');\n    });\n\n    it('resets page position if rows change so page will be empty', async () => {\n      const rowNumbers = 10;\n      const pageSize = 2;\n      const numberOfPages = Math.ceil(rowNumbers / pageSize);\n      data.rows = new Array(rowNumbers).fill({\n        a: 'shoes',\n        b: 1588024800000,\n        c: faker.number.int(),\n      });\n\n      args.pageSize = pageSize;\n\n      const { rerender } = renderDatatableComponent({\n        args,\n        data,\n      });\n      const newIndex = 3;\n      await userEvent.click(\n        screen.getByRole('link', { name: `Page ${newIndex} of ${numberOfPages}` })\n      );\n      expect(\n        screen.getByRole('button', { name: `Page ${newIndex} of ${numberOfPages}` })\n      ).toHaveAttribute('aria-current', 'page');\n\n      await act(async () => {\n        rerender({\n          args: {\n            ...args,\n            pageSize: 2,\n          },\n          data: {\n            ...data,\n            rows: new Array(4).fill({ a: 'shoes', b: 1588024800000, c: 3 }),\n          },\n        });\n      });\n      // resets to the last page if the current page becomes out of bounds\n      expect(screen.getByTestId('euiDataGridBody')).toHaveAttribute(\n        'aria-label',\n        'My fanci metric chart; Page 2 of 2.'\n      );\n    });\n  });\n\n  describe('renderCellValue', () => {\n    describe('getCellColor', () => {\n      const palette: PaletteOutput<CustomPaletteState> = {\n        type: 'palette',\n        name: 'default',\n        params: {\n          colors: [],\n          gradient: false,\n          stops: [],\n          range: 'number',\n          rangeMin: 0,\n          rangeMax: 100,\n        },\n      };\n\n      describe('caching', () => {\n        test('caches getCellColorFn by columnId', () => {\n          args.columns[0].palette = palette;\n          args.columns[0].colorMode = 'cell';\n          data.rows.push(\n            ...[\n              { a: 'pants', b: 1588024800000, c: 4 },\n              { a: 'hat', b: 1588024800000, c: 5 },\n              { a: 'bag', b: 1588024800000, c: 6 },\n            ]\n          );\n\n          renderDatatableComponent();\n\n          expect(getCellColorFn).toBeCalledTimes(2); // 2 initial renders of table\n        });\n\n        test('caches getCellColorFn by columnId with transpose columns', () => {\n          const columnId1 = getTransposeId('a', 'test');\n          const columnId2 = getTransposeId('b', 'test');\n\n          renderDatatableComponent({\n            data: {\n              ...data,\n              rows: [{ [columnId1]: 'shoe', [columnId2]: 'hat' }],\n              columns: [columnId1, columnId2].map((id) => ({\n                ...data.columns[0],\n                id,\n              })),\n            },\n            args: {\n              ...args,\n              columns: [columnId1, columnId2].map((columnId) => ({\n                ...args.columns[0],\n                palette,\n                colorMode: 'cell',\n                columnId,\n              })),\n            },\n          });\n\n          expect(getCellColorFn).toBeCalledTimes(2); // 2 initial renders of table\n        });\n      });\n\n      const color = 'red';\n\n      test('should correctly color numerical values', () => {\n        args.columns[0].palette = palette;\n        args.columns[0].colorMode = 'cell';\n\n        (getCellColorFn as jest.Mock).mockReturnValue(() => color);\n\n        renderDatatableComponent();\n\n        const cellColors = screen\n          .queryAllByRole('gridcell')\n          .map((cell) => [cell.textContent, cell.style.backgroundColor]);\n\n        expect(cellColors).toEqual([\n          ['shoes', 'red'],\n          ['1588024800000', ''],\n          ['3', ''],\n        ]);\n      });\n\n      test('should correctly color string values', () => {\n        args.columns[2].palette = palette;\n        args.columns[2].colorMode = 'cell';\n\n        (getCellColorFn as jest.Mock).mockReturnValue(() => color);\n\n        renderDatatableComponent();\n\n        const cellColors = screen\n          .queryAllByRole('gridcell')\n          .map((cell) => [cell.textContent, cell.style.backgroundColor]);\n\n        expect(cellColors).toEqual([\n          ['shoes', ''],\n          ['1588024800000', ''],\n          ['3', 'red'],\n        ]);\n      });\n    });\n  });\n\n  describe('gridStyle', () => {\n    it('should apply default grid style when density is not provided', () => {\n      renderDatatableComponent();\n      const table = screen.getByTestId('lnsDataTable');\n      expect(table).toHaveClass(/cellPadding-m-fontSize-m/);\n    });\n    it('should apply normal grid style when density is normal', () => {\n      renderDatatableComponent({\n        args: {\n          ...args,\n          density: DataGridDensity.NORMAL,\n        },\n      });\n      const table = screen.getByTestId('lnsDataTable');\n      expect(table).toHaveClass(/cellPadding-m-fontSize-m/);\n    });\n    it('should apply compact grid style when density is compact', () => {\n      renderDatatableComponent({\n        args: {\n          ...args,\n          density: DataGridDensity.COMPACT,\n        },\n      });\n      const table = screen.getByTestId('lnsDataTable');\n      expect(table).toHaveClass(/cellPadding-s-fontSize-s/);\n    });\n    it('should apply expanded grid style when density is expanded', () => {\n      renderDatatableComponent({\n        args: {\n          ...args,\n          density: DataGridDensity.EXPANDED,\n        },\n      });\n      const table = screen.getByTestId('lnsDataTable');\n      expect(table).toHaveClass(/cellPadding-l-fontSize-l/);\n    });\n    it('should update grid style when density changes', () => {\n      const { rerender } = renderDatatableComponent({\n        args: {\n          ...args,\n          density: DataGridDensity.NORMAL,\n        },\n      });\n      const table = screen.getByTestId('lnsDataTable');\n      expect(table).toHaveClass(/cellPadding-m-fontSize-m/);\n      rerender({\n        args: {\n          ...args,\n          density: DataGridDensity.COMPACT,\n        },\n      });\n      expect(table).toHaveClass(/cellPadding-s-fontSize-s/);\n    });\n  });\n});", "meta": {"repo": "elastic/kibana", "stars": 20552, "component": "x-pack/platform/plugins/shared/lens/public/visualizations/datatable/components/table_basic.tsx", "test": "x-pack/platform/plugins/shared/lens/public/visualizations/datatable/components/table_basic.test.tsx"}}
{"input": "/*\n * SPDX-License-Identifier: Apache-2.0\n *\n * The OpenSearch Contributors require contributions made to\n * this file be licensed under the Apache-2.0 license or a\n * compatible open source license.\n *\n * Any modifications Copyright OpenSearch Contributors. See\n * GitHub history for details.\n */\n\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport React from 'react';\nimport { FormattedMessage, I18nProvider } from '@osd/i18n/react';\nimport { EuiCallOut, EuiLink, EuiLoadingSpinner, EuiPage, EuiPageContent } from '@elastic/eui';\nimport { IndexPatternsContract } from '../../../../../../../../data/public';\nimport { OpenSearchRequestState, useOpenSearchDocSearch } from './use_opensearch_doc_search';\nimport { DocViewer } from '../doc_viewer/doc_viewer';\n\nexport interface DocProps {\n  /**\n   * Id of the doc in OpenSearch\n   */\n  id: string;\n  /**\n   * Index in OpenSearch to query\n   */\n  index: string;\n  /**\n   * IndexPattern ID used to get IndexPattern entity\n   * that's used for adding additional fields (stored_fields, script_fields, docvalue_fields)\n   */\n  indexPatternId: string;\n  /**\n   * IndexPatternService to get a given index pattern by ID\n   */\n  indexPatternService: IndexPatternsContract;\n}\n\nexport function Doc(props: DocProps) {\n  const [reqState, hit, indexPattern] = useOpenSearchDocSearch(props);\n  return (\n    <I18nProvider>\n      <EuiPage className=\"discover.context.appPage\" data-test-subj=\"discoverAppPage\">\n        <EuiPageContent paddingSize=\"s\">\n          {reqState === OpenSearchRequestState.NotFoundIndexPattern && (\n            <EuiCallOut\n              color=\"danger\"\n              data-test-subj={`doc-msg-notFoundIndexPattern`}\n              iconType=\"alert\"\n              title={\n                <FormattedMessage\n                  id=\"explore.discover.doc.failedToLocateIndexPattern\"\n                  defaultMessage=\"No index pattern matches ID {indexPatternId}\"\n                  values={{ indexPatternId: props.indexPatternId }}\n                />\n              }\n            />\n          )}\n          {reqState === OpenSearchRequestState.NotFound && (\n            <EuiCallOut\n              color=\"danger\"\n              data-test-subj={`doc-msg-notFound`}\n              iconType=\"alert\"\n              title={\n                <FormattedMessage\n                  id=\"explore.discover.doc.failedToLocateDocumentDescription\"\n                  defaultMessage=\"Cannot find document\"\n                />\n              }\n            >\n              <FormattedMessage\n                id=\"explore.discover.doc.couldNotFindDocumentsDescription\"\n                defaultMessage=\"No documents match that ID.\"\n              />\n            </EuiCallOut>\n          )}\n\n          {reqState === OpenSearchRequestState.Error && (\n            <EuiCallOut\n              color=\"danger\"\n              data-test-subj={`doc-msg-error`}\n              iconType=\"alert\"\n              title={\n                <FormattedMessage\n                  id=\"explore.discover.doc.failedToExecuteQueryDescription\"\n                  defaultMessage=\"Cannot run search\"\n                />\n              }\n            >\n              <FormattedMessage\n                id=\"explore.discover.doc.somethingWentWrongDescription\"\n                defaultMessage=\"{indexName} is missing.\"\n                values={{ indexName: props.index }}\n              />{' '}\n              <EuiLink\n                href={`https://opensearch.org/docs/latest/opensearch/rest-api/index-apis/exists/`}\n                target=\"_blank\"\n              >\n                <FormattedMessage\n                  id=\"explore.explore.discover.doc.somethingWentWrongDescriptionAddon\"\n                  defaultMessage=\"Please ensure the index exists.\"\n                />\n              </EuiLink>\n            </EuiCallOut>\n          )}\n\n          {reqState === OpenSearchRequestState.Loading && (\n            <EuiCallOut data-test-subj={`doc-msg-loading`}>\n              <EuiLoadingSpinner size=\"m\" />{' '}\n              <FormattedMessage\n                id=\"explore.discover.doc.loadingDescription\"\n                defaultMessage=\"Loading\u2026\"\n              />\n            </EuiCallOut>\n          )}\n\n          {reqState === OpenSearchRequestState.Found && hit !== null && indexPattern && (\n            <div data-test-subj=\"doc-hit\">\n              <DocViewer hit={hit} indexPattern={indexPattern} />\n            </div>\n          )}\n        </EuiPageContent>\n      </EuiPage>\n    </I18nProvider>\n  );\n}", "output": "/*\n * SPDX-License-Identifier: Apache-2.0\n *\n * The OpenSearch Contributors require contributions made to\n * this file be licensed under the Apache-2.0 license or a\n * compatible open source license.\n *\n * Any modifications Copyright OpenSearch Contributors. See\n * GitHub history for details.\n */\n\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport { throwError, of } from 'rxjs';\nimport React from 'react';\nimport { act } from 'react-dom/test-utils';\nimport { mountWithIntl } from 'test_utils/enzyme_helpers';\nimport { ReactWrapper } from 'enzyme';\nimport { findTestSubject } from 'test_utils/helpers';\nimport { Doc, DocProps } from './doc';\n\nconst mockSearchApi = jest.fn();\n\njest.mock('../../../opensearch_dashboards_services', () => {\n  let registry: any[] = [];\n\n  return {\n    getServices: () => ({\n      metadata: {\n        branch: 'test',\n      },\n      data: {\n        search: {\n          search: mockSearchApi,\n        },\n      },\n    }),\n    getDocViewsRegistry: () => ({\n      addDocView(view: any) {\n        registry.push(view);\n      },\n      getDocViewsSorted() {\n        return registry;\n      },\n      resetRegistry: () => {\n        registry = [];\n      },\n    }),\n    getDocViewsLinksRegistry: () => ({\n      addDocViewLink(view: any) {\n        registry.push(view);\n      },\n      getDocViewsLinksSorted() {\n        return registry;\n      },\n      resetRegistry: () => {\n        registry = [];\n      },\n    }),\n  };\n});\n\nbeforeEach(() => {\n  jest.clearAllMocks();\n});\n\nconst waitForPromises = async () =>\n  act(async () => {\n    await new Promise((resolve) => setTimeout(resolve));\n  });\n\n/**\n * this works but logs ugly error messages until we're using React 16.9\n * should be adapted when we upgrade\n */\nasync function mountDoc(update = false, indexPatternGetter: any = null) {\n  const indexPattern = {\n    getComputedFields: () => [],\n  };\n  const indexPatternService = {\n    get: indexPatternGetter ? indexPatternGetter : jest.fn(() => Promise.resolve(indexPattern)),\n    isLongNumeralsSupported: jest.fn(),\n  } as any;\n\n  const props = {\n    id: '1',\n    index: 'index1',\n    indexPatternId: 'xyz',\n    indexPatternService,\n  } as DocProps;\n  let comp!: ReactWrapper;\n  await act(async () => {\n    comp = mountWithIntl(<Doc {...props} />);\n    if (update) comp.update();\n  });\n  if (update) {\n    await waitForPromises();\n    comp.update();\n  }\n  return comp;\n}\n\ndescribe('Test of <Doc /> of Discover', () => {\n  test('renders loading msg', async () => {\n    const comp = await mountDoc();\n    expect(findTestSubject(comp, 'doc-msg-loading').length).toBe(1);\n  });\n\n  test('renders IndexPattern notFound msg', async () => {\n    const indexPatternGetter = jest.fn(() => Promise.reject({ savedObjectId: '007' }));\n    const comp = await mountDoc(true, indexPatternGetter);\n    expect(findTestSubject(comp, 'doc-msg-notFoundIndexPattern').length).toBe(1);\n  });\n\n  test('renders notFound msg', async () => {\n    mockSearchApi.mockImplementation(() => throwError({ status: 404 }));\n    const comp = await mountDoc(true);\n    expect(findTestSubject(comp, 'doc-msg-notFound').length).toBe(1);\n  });\n\n  test('renders error msg', async () => {\n    mockSearchApi.mockImplementation(() => throwError({ error: 'something else' }));\n    const comp = await mountDoc(true);\n    expect(findTestSubject(comp, 'doc-msg-error').length).toBe(1);\n  });\n\n  test('renders opensearch hit ', async () => {\n    mockSearchApi.mockImplementation(() =>\n      of({ rawResponse: { hits: { total: 1, hits: [{ _id: 1, _source: { test: 1 } }] } } })\n    );\n    const comp = await mountDoc(true);\n    expect(findTestSubject(comp, 'doc-hit').length).toBe(1);\n  });\n});", "meta": {"repo": "opensearch-project/OpenSearch-Dashboards", "stars": 1844, "component": "src/plugins/explore/public/application/legacy/discover/application/components/doc/doc.tsx", "test": "src/plugins/explore/public/application/legacy/discover/application/components/doc/doc.test.tsx"}}
{"input": "import * as React from 'react';\nimport Dropdown from '~components/dropdown/Dropdown';\nimport TextField from '~components/TextField';\nimport CopyToClipboard from '~components/copyToClipboard/CopyToClipboard';\nimport { DTExampleProps, DTOptionsProps, DTHelpProps, DTMetadata } from '~types/dataTypes';\nimport { AlphanumericState, GenerationOptionsType } from './Alphanumeric.state';\nimport styles from './Alphanumeric.scss';\nimport sharedStyles from '../../../styles/shared.scss';\n\nconst Copy = ({ content, tooltip, message }: any): JSX.Element => (\n\t<span className={styles.copy}>\n\t\t<CopyToClipboard content={content} message={message} tooltip={tooltip} />\n\t</span>\n);\n\nexport const Example = ({ i18n, data, onUpdate }: DTExampleProps): JSX.Element => {\n\tconst onChange = (value: any): void => {\n\t\tonUpdate({\n\t\t\texample: value,\n\t\t\tvalue: value\n\t\t});\n\t};\n\n\tconst options = [\n\t\t{ value: 'LxL xLx', label: `V6M 4C1 ${i18n.exampleCanPostalCode}` },\n\t\t{ value: 'xxxxx', label: `90210 ${i18n.exampleUSZipCode}` },\n\t\t{ value: 'LLLxxLLLxLL', label: `eZg29gdF5K1 ${i18n.examplePassword}` }\n\t];\n\n\treturn <Dropdown value={data.example} onChange={(i: any): void => onChange(i.value)} options={options} />;\n};\n\nexport const Options = ({ coreI18n, data, throttle, onUpdate }: DTOptionsProps): JSX.Element => {\n\tconst titleColError = data.value.trim() === '' ? coreI18n.requiredField : '';\n\n\treturn (\n\t\t<TextField\n\t\t\terror={titleColError}\n\t\t\tvalue={data.value}\n\t\t\tonChange={(e: any): void => onUpdate({ ...data, value: e.target.value })}\n\t\t\tstyle={{ width: '100%' }}\n\t\t\tthrottle={throttle}\n\t\t/>\n\t);\n};\nOptions.defaultProps = {\n\tthrottle: true\n};\n\nexport const Help = ({ coreI18n, i18n }: DTHelpProps): JSX.Element => (\n\t<>\n\t\t<p>{i18n.helpIntro}</p>\n\n\t\t<div className={styles.row}>\n\t\t\t<div className={styles.col1}>\n\t\t\t\t<label className={sharedStyles.pill}>L</label>\n\t\t\t</div>\n\t\t\t<div className={sharedStyles.copyCol}>\n\t\t\t\t<Copy content=\"L\" message={coreI18n.copiedToClipboard} tooltip={coreI18n.copyToClipboard} />\n\t\t\t</div>\n\t\t\t<div className={styles.col2} dangerouslySetInnerHTML={{ __html: i18n.help1 }} />\n\t\t\t<div className={styles.col3}>\n\t\t\t\t<label className={sharedStyles.pill}>V</label>\n\t\t\t</div>\n\t\t\t<div className={sharedStyles.copyCol}>\n\t\t\t\t<Copy content=\"V\" message={coreI18n.copiedToClipboard} tooltip={coreI18n.copyToClipboard} />\n\t\t\t</div>\n\t\t\t<div className={styles.col4} dangerouslySetInnerHTML={{ __html: i18n.help2 }} />\n\t\t</div>\n\t\t<div className={styles.row}>\n\t\t\t<div className={styles.col1}>\n\t\t\t\t<label className={sharedStyles.pill}>l</label>\n\t\t\t</div>\n\t\t\t<div className={sharedStyles.copyCol}>\n\t\t\t\t<Copy content=\"l\" message={coreI18n.copiedToClipboard} tooltip={coreI18n.copyToClipboard} />\n\t\t\t</div>\n\t\t\t<div className={styles.col2} dangerouslySetInnerHTML={{ __html: i18n.help3 }} />\n\t\t\t<div className={styles.col3}>\n\t\t\t\t<label className={sharedStyles.pill}>v</label>\n\t\t\t</div>\n\t\t\t<div className={sharedStyles.copyCol}>\n\t\t\t\t<Copy content=\"v\" message={coreI18n.copiedToClipboard} tooltip={coreI18n.copyToClipboard} />\n\t\t\t</div>\n\t\t\t<div className={styles.col4} dangerouslySetInnerHTML={{ __html: i18n.help4 }} />\n\t\t</div>\n\t\t<div className={styles.row}>\n\t\t\t<div className={styles.col1}>\n\t\t\t\t<label className={sharedStyles.pill}>D</label>\n\t\t\t</div>\n\t\t\t<div className={sharedStyles.copyCol}>\n\t\t\t\t<Copy content=\"D\" message={coreI18n.copiedToClipboard} tooltip={coreI18n.copyToClipboard} />\n\t\t\t</div>\n\t\t\t<div className={styles.col2} dangerouslySetInnerHTML={{ __html: i18n.help5 }} />\n\t\t\t<div className={styles.col3}>\n\t\t\t\t<label className={sharedStyles.pill}>F</label>\n\t\t\t</div>\n\t\t\t<div className={sharedStyles.copyCol}>\n\t\t\t\t<Copy content=\"F\" message={coreI18n.copiedToClipboard} tooltip={coreI18n.copyToClipboard} />\n\t\t\t</div>\n\t\t\t<div className={styles.col4} dangerouslySetInnerHTML={{ __html: i18n.help6 }} />\n\t\t</div>\n\t\t<div className={styles.row}>\n\t\t\t<div className={styles.col1}>\n\t\t\t\t<label className={sharedStyles.pill}>C</label>\n\t\t\t</div>\n\t\t\t<div className={sharedStyles.copyCol}>\n\t\t\t\t<Copy content=\"C\" message={coreI18n.copiedToClipboard} tooltip={coreI18n.copyToClipboard} />\n\t\t\t</div>\n\t\t\t<div className={styles.col2} dangerouslySetInnerHTML={{ __html: i18n.help7 }} />\n\t\t\t<div className={styles.col3}>\n\t\t\t\t<label className={sharedStyles.pill}>x</label>\n\t\t\t</div>\n\t\t\t<div className={sharedStyles.copyCol}>\n\t\t\t\t<Copy content=\"x\" message={coreI18n.copiedToClipboard} tooltip={coreI18n.copyToClipboard} />\n\t\t\t</div>\n\t\t\t<div className={styles.col4} dangerouslySetInnerHTML={{ __html: i18n.help8 }} />\n\t\t</div>\n\t\t<div className={styles.row}>\n\t\t\t<div className={styles.col1}>\n\t\t\t\t<label className={sharedStyles.pill}>c</label>\n\t\t\t</div>\n\t\t\t<div className={sharedStyles.copyCol}>\n\t\t\t\t<Copy content=\"c\" message={coreI18n.copiedToClipboard} tooltip={coreI18n.copyToClipboard} />\n\t\t\t</div>\n\t\t\t<div className={styles.col2} dangerouslySetInnerHTML={{ __html: i18n.help9 }} />\n\t\t\t<div className={styles.col3}>\n\t\t\t\t<label className={sharedStyles.pill}>X</label>\n\t\t\t</div>\n\t\t\t<div className={sharedStyles.copyCol}>\n\t\t\t\t<Copy content=\"X\" message={coreI18n.copiedToClipboard} tooltip={coreI18n.copyToClipboard} />\n\t\t\t</div>\n\t\t\t<div className={styles.col4} dangerouslySetInnerHTML={{ __html: i18n.help10 }} />\n\t\t</div>\n\t\t<div className={styles.row}>\n\t\t\t<div className={styles.col1}>\n\t\t\t\t<label className={sharedStyles.pill}>E</label>\n\t\t\t</div>\n\t\t\t<div className={sharedStyles.copyCol}>\n\t\t\t\t<Copy content=\"E\" message={coreI18n.copiedToClipboard} tooltip={coreI18n.copyToClipboard} />\n\t\t\t</div>\n\t\t\t<div className={styles.col2} dangerouslySetInnerHTML={{ __html: i18n.help11 }} />\n\t\t\t<div className={styles.col3}>\n\t\t\t\t<label className={sharedStyles.pill}>H</label>\n\t\t\t</div>\n\t\t\t<div className={sharedStyles.copyCol}>\n\t\t\t\t<Copy content=\"H\" message={coreI18n.copiedToClipboard} tooltip={coreI18n.copyToClipboard} />\n\t\t\t</div>\n\t\t\t<div className={styles.col4} dangerouslySetInnerHTML={{ __html: i18n.help12 }} />\n\t\t</div>\n\t</>\n);\n\nexport const rowStateReducer = (state: AlphanumericState): GenerationOptionsType => ({ value: state.value });\n\nexport const getMetadata = (): DTMetadata => ({\n\tsql: {\n\t\tfield: 'varchar(255)',\n\t\tfield_Oracle: 'varchar2(255)',\n\t\tfield_MSSQL: 'VARCHAR(255) NULL'\n\t},\n\tgeneral: {\n\t\tdataType: 'infer'\n\t}\n});", "output": "import React from 'react';\nimport sinon from 'sinon';\nimport { render, fireEvent } from '@testing-library/react';\nimport { Options, Help, Example } from '../Alphanumeric';\nimport { initialState } from '../Alphanumeric.state';\nimport * as langUtils from '~utils/langUtils';\nconst i18n = require('../i18n/en.json');\n\nconst defaultProps = {\n\tcoreI18n: {},\n\tcountryI18n: {},\n\ti18n,\n\tid: 'id',\n\tgridPanelDimensions: { width: 100, height: 100 },\n\tisCountryNamesLoading: false,\n\tisCountryNamesLoaded: false,\n\tcountryNamesMap: null\n};\n\ndescribe('Example', () => {\n\tit('renders', () => {\n\t\tsinon.stub(langUtils, 'getStrings').returns({ core: {} });\n\n\t\tconst data = { ...initialState };\n\t\tconst onUpdate = jest.fn();\n\t\tconst { container } = render(<Example {...defaultProps} data={data} onUpdate={onUpdate} />);\n\t\texpect(container).toBeTruthy();\n\t});\n});\n\ndescribe('Options', () => {\n\tit('changing the content should call callback', () => {\n\t\tconst data = { ...initialState };\n\t\tconst onUpdate = jest.fn();\n\t\tconst { container } = render(<Options {...defaultProps} data={data} onUpdate={onUpdate} throttle={false} />);\n\t\tconst field = container.querySelector('input');\n\n\t\t// @ts-ignore\n\t\tfireEvent.change(field, {\n\t\t\ttarget: {\n\t\t\t\tvalue: 'new value!!'\n\t\t\t}\n\t\t});\n\n\t\texpect(onUpdate).toBeCalledWith({\n\t\t\t...initialState,\n\t\t\tvalue: 'new value!!'\n\t\t});\n\t});\n});\n\ndescribe('Help', () => {\n\tit('renders', () => {\n\t\tconst { container } = render(<Help {...defaultProps} />);\n\t\texpect(container).toBeTruthy();\n\t});\n});", "meta": {"repo": "benkeen/generatedata", "stars": 2254, "component": "client/src/plugins/dataTypes/Alphanumeric/Alphanumeric.tsx", "test": "client/src/plugins/dataTypes/Alphanumeric/__tests__/Alphanumeric.test.tsx"}}
{"input": "import React from \"react\";\nimport { makeStyles, createStyles, Theme } from \"@material-ui/core/styles\";\nimport { Link as MuiLink, Typography } from \"@material-ui/core\";\nimport clsx from \"clsx\";\nimport {\n  Toc as TocModel,\n  TocBuilder as TocModelBuilder\n} from \"../../lib/toc-utils\";\nimport { MarkdownHeading, MarkdownHeadingProps } from \"../MarkdownHeading\";\n\nconst useStyles = makeStyles((theme: Theme) =>\n  createStyles({\n    root: {\n      \"& > ul\": {\n        padding: \"0 !important\"\n      }\n    },\n    title: {\n      fontWeight: theme.typography.fontWeightBold,\n      paddingBottom: theme.spacing(1)\n    },\n    tocUl: {\n      listStyleType: \"none\",\n      paddingLeft: \"1rem\"\n    }\n  })\n);\n\nfunction variantToLevel(variant: string): number {\n  return parseInt(variant.replace(\"h\", \"\"), 10);\n}\n\nfunction isMarkdownHeadingElement(\n  element: JSX.Element\n): element is React.ReactElement<MarkdownHeadingProps> {\n  return typeof element.type === \"function\" && element.type === MarkdownHeading;\n}\n\nfunction buildTocModelFromContent(\n  content: React.ReactElement,\n  levelStart = 1\n): TocModel {\n  const builder = new TocModelBuilder();\n  React.Children.forEach(content, (element) => {\n    if (isMarkdownHeadingElement(element)) {\n      builder.addSection(\n        variantToLevel(element.props.variant) - levelStart + 1,\n        element.props.children,\n        element.props.id\n      );\n    }\n  });\n\n  return builder.getToc();\n}\n\ntype TocSectionProps = {\n  children: React.ReactNode;\n  title: string;\n  id: string;\n};\n\nfunction TocSection({ title, id, children }: TocSectionProps) {\n  const classes = useStyles();\n\n  return (\n    <li>\n      <MuiLink href={`#${id}`}>{title}</MuiLink>\n      {children ? <ul className={classes.tocUl}>{children}</ul> : null}\n    </li>\n  );\n}\n\nexport type MarkdownTocProps = {\n  className?: string;\n  content?: React.ReactElement;\n  levelStart?: number;\n};\n\nexport function MarkdownToc({\n  className,\n  content,\n  levelStart = 1\n}: MarkdownTocProps) {\n  const classes = useStyles();\n\n  if (!content) {\n    return null;\n  }\n\n  const model = buildTocModelFromContent(content, levelStart);\n  if (model.children.length === 0) {\n    return null;\n  }\n\n  return (\n    <div className={clsx(classes.root, className)}>\n      <Typography variant=\"subtitle2\" className={classes.title}>\n        Table of contents\n      </Typography>\n      <ul className={classes.tocUl}>\n        {model.render((title: string, id: string, children: JSX.Element[]) => (\n          <TocSection title={title} id={id} key={id}>\n            {children}\n          </TocSection>\n        ))}\n      </ul>\n    </div>\n  );\n}", "output": "import React from \"react\";\nimport { compiler as mdCompiler } from \"markdown-to-jsx\";\nimport TestRenderer from \"react-test-renderer\";\nimport { MarkdownHeading } from \"../MarkdownHeading\";\nimport { MarkdownToc } from \"./MarkdownToc\";\n\nconst markdown = `# Header 1\nLorem Ipsum\n\n## Header 1.1\n\n### Header 1.1.1\n\n### Header 1.1.2\n\n## Header 1.2\n\n#### Subtitle without direct parent\n\ntest\n\n# Header 2\n\nhello`;\n\nconst options = {\n  overrides: {\n    h1: {\n      component: MarkdownHeading,\n      props: { variant: \"h1\" }\n    },\n    h2: {\n      component: MarkdownHeading,\n      props: { variant: \"h2\" }\n    },\n    h3: {\n      component: MarkdownHeading,\n      props: { variant: \"h3\" }\n    },\n    h4: {\n      component: MarkdownHeading,\n      props: { variant: \"h4\" }\n    }\n  }\n};\n\ndescribe(\"Toc\", () => {\n  const content = mdCompiler(markdown, options) as React.ReactElement<{\n    children: React.ReactElement;\n  }>;\n\n  it(\"renders correctly\", () => {\n    const tree = TestRenderer.create(\n      <MarkdownToc content={content.props.children} />\n    );\n    expect(tree.toJSON()).toMatchSnapshot();\n  });\n});", "meta": {"repo": "thomvaill/log4brains", "stars": 1270, "component": "packages/web/nextjs/src/components/MarkdownToc/MarkdownToc.tsx", "test": "packages/web/nextjs/src/components/MarkdownToc/MarkdownToc.test.tsx"}}
